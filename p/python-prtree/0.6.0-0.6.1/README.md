# Comparing `tmp/python_prtree-0.6.0.tar.gz` & `tmp/python_prtree-0.6.1.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "python_prtree-0.6.0.tar", last modified: Wed Nov  2 15:09:23 2022, max compression
+gzip compressed data, was "python_prtree-0.6.1.tar", last modified: Sat Apr 13 00:48:56 2024, max compression
```

## Comparing `python_prtree-0.6.0.tar` & `python_prtree-0.6.1.tar`

### file list

```diff
@@ -1,564 +1,593 @@
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.889537 python_prtree-0.6.0/
--rw-r--r--   0 runner    (1001) docker     (121)     1088 2022-11-02 15:09:19.000000 python_prtree-0.6.0/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (121)     1062 2022-11-02 15:09:19.000000 python_prtree-0.6.0/LICENSE
--rw-r--r--   0 runner    (1001) docker     (121)      162 2022-11-02 15:09:19.000000 python_prtree-0.6.0/MANIFEST.in
--rw-r--r--   0 runner    (1001) docker     (121)     5987 2022-11-02 15:09:23.889537 python_prtree-0.6.0/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (121)     5517 2022-11-02 15:09:19.000000 python_prtree-0.6.0/README.md
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.837537 python_prtree-0.6.0/cpp/
--rw-r--r--   0 runner    (1001) docker     (121)     5276 2022-11-02 15:09:19.000000 python_prtree-0.6.0/cpp/main.cc
--rw-r--r--   0 runner    (1001) docker     (121)     2480 2022-11-02 15:09:19.000000 python_prtree-0.6.0/cpp/parallel.h
--rw-r--r--   0 runner    (1001) docker     (121)    31109 2022-11-02 15:09:19.000000 python_prtree-0.6.0/cpp/prtree.h
--rw-r--r--   0 runner    (1001) docker     (121)    33515 2022-11-02 15:09:19.000000 python_prtree-0.6.0/cpp/small_vector.h
--rw-r--r--   0 runner    (1001) docker     (121)      301 2022-11-02 15:09:19.000000 python_prtree-0.6.0/requirements.txt
--rw-r--r--   0 runner    (1001) docker     (121)       38 2022-11-02 15:09:23.889537 python_prtree-0.6.0/setup.cfg
--rw-r--r--   0 runner    (1001) docker     (121)     3705 2022-11-02 15:09:19.000000 python_prtree-0.6.0/setup.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.833537 python_prtree-0.6.0/src/
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.837537 python_prtree-0.6.0/src/python_prtree/
--rw-r--r--   0 runner    (1001) docker     (121)     2007 2022-11-02 15:09:19.000000 python_prtree-0.6.0/src/python_prtree/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.837537 python_prtree-0.6.0/src/python_prtree.egg-info/
--rw-r--r--   0 runner    (1001) docker     (121)     5987 2022-11-02 15:09:23.000000 python_prtree-0.6.0/src/python_prtree.egg-info/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (121)    20980 2022-11-02 15:09:23.000000 python_prtree-0.6.0/src/python_prtree.egg-info/SOURCES.txt
--rw-r--r--   0 runner    (1001) docker     (121)        1 2022-11-02 15:09:23.000000 python_prtree-0.6.0/src/python_prtree.egg-info/dependency_links.txt
--rw-r--r--   0 runner    (1001) docker     (121)        1 2022-11-02 15:09:23.000000 python_prtree-0.6.0/src/python_prtree.egg-info/not-zip-safe
--rw-r--r--   0 runner    (1001) docker     (121)      153 2022-11-02 15:09:23.000000 python_prtree-0.6.0/src/python_prtree.egg-info/requires.txt
--rw-r--r--   0 runner    (1001) docker     (121)       14 2022-11-02 15:09:23.000000 python_prtree-0.6.0/src/python_prtree.egg-info/top_level.txt
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.833537 python_prtree-0.6.0/third/
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.837537 python_prtree-0.6.0/third/cereal/
--rw-r--r--   0 runner    (1001) docker     (121)      525 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/.gitignore
--rw-r--r--   0 runner    (1001) docker     (121)     8714 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/.travis.yml
--rw-r--r--   0 runner    (1001) docker     (121)     2228 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (121)       81 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/Config.cmake.in
--rw-r--r--   0 runner    (1001) docker     (121)     1519 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/LICENSE
--rw-r--r--   0 runner    (1001) docker     (121)     2684 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/README.md
--rw-r--r--   0 runner    (1001) docker     (121)      978 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/appveyor.yml
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.837537 python_prtree-0.6.0/third/cereal/doc/
--rw-r--r--   0 runner    (1001) docker     (121)      689 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/doc/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (121)     6115 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/doc/DoxygenLayout.xml
--rw-r--r--   0 runner    (1001) docker     (121)    80217 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/doc/doxygen.in
--rw-r--r--   0 runner    (1001) docker     (121)     1139 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/doc/footer.html
--rw-r--r--   0 runner    (1001) docker     (121)     2038 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/doc/mainpage.dox
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.833537 python_prtree-0.6.0/third/cereal/include/
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.837537 python_prtree-0.6.0/third/cereal/include/cereal/
--rw-r--r--   0 runner    (1001) docker     (121)    14820 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/access.hpp
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.837537 python_prtree-0.6.0/third/cereal/include/cereal/archives/
--rw-r--r--   0 runner    (1001) docker     (121)     6034 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/archives/adapters.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     6760 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/archives/binary.hpp
--rw-r--r--   0 runner    (1001) docker     (121)    43681 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/archives/json.hpp
--rw-r--r--   0 runner    (1001) docker     (121)    14780 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/archives/portable_binary.hpp
--rw-r--r--   0 runner    (1001) docker     (121)    39071 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/archives/xml.hpp
--rw-r--r--   0 runner    (1001) docker     (121)    45263 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/cereal.hpp
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.837537 python_prtree-0.6.0/third/cereal/include/cereal/details/
--rw-r--r--   0 runner    (1001) docker     (121)    15930 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/details/helpers.hpp
--rw-r--r--   0 runner    (1001) docker     (121)    37111 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/details/polymorphic_impl.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2902 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/details/polymorphic_impl_fwd.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     4918 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/details/static_object.hpp
--rw-r--r--   0 runner    (1001) docker     (121)    96668 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/details/traits.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2931 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/details/util.hpp
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.837537 python_prtree-0.6.0/third/cereal/include/cereal/external/
--rw-r--r--   0 runner    (1001) docker     (121)      921 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/LICENSE
--rw-r--r--   0 runner    (1001) docker     (121)     4446 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/base64.hpp
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.841537 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/
--rw-r--r--   0 runner    (1001) docker     (121)      678 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/LICENSE
--rw-r--r--   0 runner    (1001) docker     (121)    10815 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/allocators.h
--rw-r--r--   0 runner    (1001) docker     (121)     2365 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/cursorstreamwrapper.h
--rw-r--r--   0 runner    (1001) docker     (121)   119446 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/document.h
--rw-r--r--   0 runner    (1001) docker     (121)    10989 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/encodedstream.h
--rw-r--r--   0 runner    (1001) docker     (121)    30191 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/encodings.h
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.841537 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/error/
--rw-r--r--   0 runner    (1001) docker     (121)     4080 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/error/en.h
--rw-r--r--   0 runner    (1001) docker     (121)     6374 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/error/error.h
--rw-r--r--   0 runner    (1001) docker     (121)     3113 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/filereadstream.h
--rw-r--r--   0 runner    (1001) docker     (121)     3244 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/filewritestream.h
--rw-r--r--   0 runner    (1001) docker     (121)     4070 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/fwd.h
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.841537 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/internal/
--rw-r--r--   0 runner    (1001) docker     (121)     9218 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/internal/biginteger.h
--rw-r--r--   0 runner    (1001) docker     (121)    12730 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/internal/diyfp.h
--rw-r--r--   0 runner    (1001) docker     (121)     8195 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/internal/dtoa.h
--rw-r--r--   0 runner    (1001) docker     (121)     3064 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/internal/ieee754.h
--rw-r--r--   0 runner    (1001) docker     (121)    10194 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/internal/itoa.h
--rw-r--r--   0 runner    (1001) docker     (121)     6879 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/internal/meta.h
--rw-r--r--   0 runner    (1001) docker     (121)     3637 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/internal/pow10.h
--rw-r--r--   0 runner    (1001) docker     (121)    26328 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/internal/regex.h
--rw-r--r--   0 runner    (1001) docker     (121)     7345 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/internal/stack.h
--rw-r--r--   0 runner    (1001) docker     (121)     2255 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/internal/strfunc.h
--rw-r--r--   0 runner    (1001) docker     (121)     9155 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/internal/strtod.h
--rw-r--r--   0 runner    (1001) docker     (121)     1482 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/internal/swap.h
--rw-r--r--   0 runner    (1001) docker     (121)     4187 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/istreamwrapper.h
--rw-r--r--   0 runner    (1001) docker     (121)     2595 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/memorybuffer.h
--rw-r--r--   0 runner    (1001) docker     (121)     2772 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/memorystream.h
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.841537 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/msinttypes/
--rw-r--r--   0 runner    (1001) docker     (121)     1569 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/msinttypes/LICENSE
--rw-r--r--   0 runner    (1001) docker     (121)     8372 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/msinttypes/inttypes.h
--rw-r--r--   0 runner    (1001) docker     (121)     9386 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/msinttypes/stdint.h
--rw-r--r--   0 runner    (1001) docker     (121)     2422 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/ostreamwrapper.h
--rw-r--r--   0 runner    (1001) docker     (121)    61159 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/pointer.h
--rw-r--r--   0 runner    (1001) docker     (121)    10703 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/prettywriter.h
--rw-r--r--   0 runner    (1001) docker     (121)    25306 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/rapidjson.h
--rw-r--r--   0 runner    (1001) docker     (121)    95072 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/reader.h
--rw-r--r--   0 runner    (1001) docker     (121)   105031 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/schema.h
--rw-r--r--   0 runner    (1001) docker     (121)     6851 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/stream.h
--rw-r--r--   0 runner    (1001) docker     (121)     4063 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/stringbuffer.h
--rw-r--r--   0 runner    (1001) docker     (121)    27313 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/writer.h
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.845537 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidxml/
--rw-r--r--   0 runner    (1001) docker     (121)     2804 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidxml/license.txt
--rw-r--r--   0 runner    (1001) docker     (121)   113504 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidxml/manual.html
--rw-r--r--   0 runner    (1001) docker     (121)   119560 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidxml/rapidxml.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     3862 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidxml/rapidxml_iterators.hpp
--rw-r--r--   0 runner    (1001) docker     (121)    15689 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidxml/rapidxml_print.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     3324 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/external/rapidxml/rapidxml_utils.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     6552 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/macros.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     6596 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/specialize.hpp
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.845537 python_prtree-0.6.0/third/cereal/include/cereal/types/
--rw-r--r--   0 runner    (1001) docker     (121)     3501 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/types/array.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2309 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/types/atomic.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     7553 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/types/base_class.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     5455 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/types/bitset.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     5545 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/types/boost_variant.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2899 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/types/chrono.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     5376 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/types/common.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2375 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/types/complex.hpp
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.845537 python_prtree-0.6.0/third/cereal/include/cereal/types/concepts/
--rw-r--r--   0 runner    (1001) docker     (121)     3210 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/types/concepts/pair_associative_container.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2448 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/types/deque.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2886 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/types/forward_list.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     1975 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/types/functional.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2432 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/types/list.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     1833 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/types/map.hpp
--rw-r--r--   0 runner    (1001) docker     (121)    16846 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/types/memory.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2555 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/types/optional.hpp
--rw-r--r--   0 runner    (1001) docker     (121)    22311 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/types/polymorphic.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     4761 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/types/queue.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     3548 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/types/set.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2880 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/types/stack.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2935 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/types/string.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     4633 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/types/tuple.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     1893 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/types/unordered_map.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     3718 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/types/unordered_set.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2127 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/types/utility.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     3942 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/types/valarray.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     4185 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/types/variant.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     4845 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/types/vector.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2342 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/include/cereal/version.hpp
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.845537 python_prtree-0.6.0/third/cereal/sandbox/
--rw-r--r--   0 runner    (1001) docker     (121)      585 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/sandbox/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (121)    15356 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/sandbox/performance.cpp
--rw-r--r--   0 runner    (1001) docker     (121)    18434 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/sandbox/sandbox.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     9851 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/sandbox/sandbox_json.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     5558 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/sandbox/sandbox_rtti.cpp
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.845537 python_prtree-0.6.0/third/cereal/sandbox/sandbox_shared_lib/
--rw-r--r--   0 runner    (1001) docker     (121)       56 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/sandbox/sandbox_shared_lib/CMakeLists.txt
--rwxr-xr-x   0 runner    (1001) docker     (121)      321 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/sandbox/sandbox_shared_lib/base.cpp
--rwxr-xr-x   0 runner    (1001) docker     (121)      968 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/sandbox/sandbox_shared_lib/base.hpp
--rwxr-xr-x   0 runner    (1001) docker     (121)      331 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/sandbox/sandbox_shared_lib/derived.cpp
--rwxr-xr-x   0 runner    (1001) docker     (121)      610 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/sandbox/sandbox_shared_lib/derived.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     7330 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/sandbox/sandbox_vs.cpp
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.849537 python_prtree-0.6.0/third/cereal/scripts/
--rwxr-xr-x   0 runner    (1001) docker     (121)      386 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/scripts/add_rapidjson_prefix.sh
--rw-r--r--   0 runner    (1001) docker     (121)     2648 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/scripts/appveyor.bat
--rwxr-xr-x   0 runner    (1001) docker     (121)      269 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/scripts/renameincludes.sh
--rwxr-xr-x   0 runner    (1001) docker     (121)      785 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/scripts/updatecoverage.sh
--rwxr-xr-x   0 runner    (1001) docker     (121)      531 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/scripts/updatedoc.in
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.857537 python_prtree-0.6.0/third/cereal/unittests/
--rw-r--r--   0 runner    (1001) docker     (121)     3594 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (121)     2107 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/array.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     3561 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/array.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2117 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/atomic.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     5063 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/atomic.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     4687 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/basic_string.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     3683 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/basic_string.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2117 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/bitset.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     3027 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/bitset.hpp
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.857537 python_prtree-0.6.0/third/cereal/unittests/boost/
--rw-r--r--   0 runner    (1001) docker     (121)     1540 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/boost/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (121)     2169 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/boost/boost_variant.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     3452 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/boost/boost_variant.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2117 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/chrono.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     3756 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/chrono.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     3261 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/cmake-config-module.cmake
--rw-r--r--   0 runner    (1001) docker     (121)     7519 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/common.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2127 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/complex.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     2938 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/complex.hpp
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.857537 python_prtree-0.6.0/third/cereal/unittests/cpp17/
--rw-r--r--   0 runner    (1001) docker     (121)     1552 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/cpp17/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (121)     2222 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/cpp17/optional.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     3218 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/cpp17/optional.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2226 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/cpp17/variant.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     2692 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/cpp17/variant.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2107 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/defer.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     5713 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/defer.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2115 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/deque.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     3791 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/deque.hpp
--rw-r--r--   0 runner    (1001) docker     (121)   266816 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/doctest.h
--rw-r--r--   0 runner    (1001) docker     (121)     2177 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/forward_list.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     3871 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/forward_list.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2097 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/list.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     3478 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/list.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2253 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/load_construct.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     8772 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/load_construct.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2553 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/map.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     5925 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/map.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2663 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/memory.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     4647 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/memory.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2187 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/memory_cycles.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     4111 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/memory_cycles.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2137 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/multimap.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     4864 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/multimap.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2137 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/multiset.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     4363 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/multiset.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2096 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/pair.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     3598 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/pair.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2087 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/pod.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     5530 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/pod.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2773 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/polymorphic.cpp
--rw-r--r--   0 runner    (1001) docker     (121)    24153 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/polymorphic.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     4928 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/portability_test.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     5093 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/portable_binary_archive.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     5881 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/portable_binary_archive.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2197 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/priority_queue.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     4814 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/priority_queue.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2107 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/queue.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     4193 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/queue.hpp
--rw-r--r--   0 runner    (1001) docker     (121)      579 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/run_portability_test.cmake
--rwxr-xr-x   0 runner    (1001) docker     (121)      123 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/run_valgrind.sh
--rw-r--r--   0 runner    (1001) docker     (121)     2087 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/set.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     3362 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/set.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2107 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/stack.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     4194 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/stack.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2127 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/structs.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     2700 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/structs.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2207 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/structs_minimal.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     8195 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/structs_minimal.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2247 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/structs_specialized.cpp
--rw-r--r--   0 runner    (1001) docker     (121)    12734 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/structs_specialized.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2107 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/tuple.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     3967 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/tuple.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     1934 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/unordered_loads.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     4859 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/unordered_loads.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2187 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/unordered_map.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     4746 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/unordered_map.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2237 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/unordered_multimap.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     6662 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/unordered_multimap.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2237 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/unordered_multiset.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     5241 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/unordered_multiset.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2187 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/unordered_set.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     4369 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/unordered_set.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2237 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/user_data_adapters.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     3522 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/user_data_adapters.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2051 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/valarray.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     3888 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/valarray.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2117 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/vector.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     4210 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/vector.hpp
--rw-r--r--   0 runner    (1001) docker     (121)     2755 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/versioning.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     5824 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/cereal/unittests/versioning.hpp
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.857537 python_prtree-0.6.0/third/pybind11/
--rw-r--r--   0 runner    (1001) docker     (121)     1304 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/.appveyor.yml
--rw-r--r--   0 runner    (1001) docker     (121)      996 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/.clang-format
--rw-r--r--   0 runner    (1001) docker     (121)     2210 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/.clang-tidy
--rw-r--r--   0 runner    (1001) docker     (121)     2196 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/.cmake-format.yaml
--rw-r--r--   0 runner    (1001) docker     (121)       36 2022-11-02 15:09:19.000000 python_prtree-0.6.0/third/pybind11/.git
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.857537 python_prtree-0.6.0/third/pybind11/.github/
--rw-r--r--   0 runner    (1001) docker     (121)      182 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/.github/CODEOWNERS
--rw-r--r--   0 runner    (1001) docker     (121)    15259 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/.github/CONTRIBUTING.md
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.857537 python_prtree-0.6.0/third/pybind11/.github/ISSUE_TEMPLATE/
--rw-r--r--   0 runner    (1001) docker     (121)     2016 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/.github/ISSUE_TEMPLATE/bug-report.yml
--rw-r--r--   0 runner    (1001) docker     (121)      328 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/.github/ISSUE_TEMPLATE/config.yml
--rw-r--r--   0 runner    (1001) docker     (121)      559 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/.github/dependabot.yml
--rw-r--r--   0 runner    (1001) docker     (121)      116 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/.github/labeler.yml
--rw-r--r--   0 runner    (1001) docker     (121)       50 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/.github/labeler_merged.yml
--rw-r--r--   0 runner    (1001) docker     (121)      645 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/.github/pull_request_template.md
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.861537 python_prtree-0.6.0/third/pybind11/.github/workflows/
--rw-r--r--   0 runner    (1001) docker     (121)    28225 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/.github/workflows/ci.yml
--rw-r--r--   0 runner    (1001) docker     (121)     2120 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/.github/workflows/configure.yml
--rw-r--r--   0 runner    (1001) docker     (121)     1214 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/.github/workflows/format.yml
--rw-r--r--   0 runner    (1001) docker     (121)      333 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/.github/workflows/labeler.yml
--rw-r--r--   0 runner    (1001) docker     (121)     2516 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/.github/workflows/pip.yml
--rw-r--r--   0 runner    (1001) docker     (121)     2824 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/.github/workflows/upstream.yml
--rw-r--r--   0 runner    (1001) docker     (121)      487 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/.gitignore
--rw-r--r--   0 runner    (1001) docker     (121)     3477 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/.pre-commit-config.yaml
--rw-r--r--   0 runner    (1001) docker     (121)       62 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/.readthedocs.yml
--rw-r--r--   0 runner    (1001) docker     (121)    10999 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (121)     1684 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/LICENSE
--rw-r--r--   0 runner    (1001) docker     (121)      256 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/MANIFEST.in
--rw-r--r--   0 runner    (1001) docker     (121)     7656 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/README.rst
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.861537 python_prtree-0.6.0/third/pybind11/docs/
--rw-r--r--   0 runner    (1001) docker     (121)      653 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/Doxyfile
--rw-r--r--   0 runner    (1001) docker     (121)     7417 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/Makefile
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.861537 python_prtree-0.6.0/third/pybind11/docs/_static/
--rw-r--r--   0 runner    (1001) docker     (121)      254 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/_static/theme_overrides.css
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.861537 python_prtree-0.6.0/third/pybind11/docs/advanced/
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.865537 python_prtree-0.6.0/third/pybind11/docs/advanced/cast/
--rw-r--r--   0 runner    (1001) docker     (121)     3937 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/advanced/cast/chrono.rst
--rw-r--r--   0 runner    (1001) docker     (121)     3409 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/advanced/cast/custom.rst
--rw-r--r--   0 runner    (1001) docker     (121)    14283 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/advanced/cast/eigen.rst
--rw-r--r--   0 runner    (1001) docker     (121)     3889 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/advanced/cast/functional.rst
--rw-r--r--   0 runner    (1001) docker     (121)     1556 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/advanced/cast/index.rst
--rw-r--r--   0 runner    (1001) docker     (121)    12433 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/advanced/cast/overview.rst
--rw-r--r--   0 runner    (1001) docker     (121)     9703 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/advanced/cast/stl.rst
--rw-r--r--   0 runner    (1001) docker     (121)     9363 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/advanced/cast/strings.rst
--rw-r--r--   0 runner    (1001) docker     (121)    48319 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/advanced/classes.rst
--rw-r--r--   0 runner    (1001) docker     (121)     8453 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/advanced/embedding.rst
--rw-r--r--   0 runner    (1001) docker     (121)    17806 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/advanced/exceptions.rst
--rw-r--r--   0 runner    (1001) docker     (121)    26827 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/advanced/functions.rst
--rw-r--r--   0 runner    (1001) docker     (121)    12446 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/advanced/misc.rst
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.865537 python_prtree-0.6.0/third/pybind11/docs/advanced/pycpp/
--rw-r--r--   0 runner    (1001) docker     (121)      278 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/advanced/pycpp/index.rst
--rw-r--r--   0 runner    (1001) docker     (121)    17447 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/advanced/pycpp/numpy.rst
--rw-r--r--   0 runner    (1001) docker     (121)     9030 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/advanced/pycpp/object.rst
--rw-r--r--   0 runner    (1001) docker     (121)     5710 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/advanced/pycpp/utilities.rst
--rw-r--r--   0 runner    (1001) docker     (121)     6367 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/advanced/smart_ptrs.rst
--rw-r--r--   0 runner    (1001) docker     (121)     9368 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/basics.rst
--rw-r--r--   0 runner    (1001) docker     (121)     2962 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/benchmark.py
--rw-r--r--   0 runner    (1001) docker     (121)     3168 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/benchmark.rst
--rw-r--r--   0 runner    (1001) docker     (121)    99067 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/changelog.rst
--rw-r--r--   0 runner    (1001) docker     (121)    16451 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/classes.rst
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.865537 python_prtree-0.6.0/third/pybind11/docs/cmake/
--rw-r--r--   0 runner    (1001) docker     (121)      273 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/cmake/index.rst
--rw-r--r--   0 runner    (1001) docker     (121)    26267 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/compiling.rst
--rw-r--r--   0 runner    (1001) docker     (121)    12082 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/conf.py
--rw-r--r--   0 runner    (1001) docker     (121)    14599 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/faq.rst
--rw-r--r--   0 runner    (1001) docker     (121)      613 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/index.rst
--rw-r--r--   0 runner    (1001) docker     (121)     3277 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/installing.rst
--rw-r--r--   0 runner    (1001) docker     (121)     3079 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/limitations.rst
--rw-r--r--   0 runner    (1001) docker     (121)    58510 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/pybind11-logo.png
--rw-r--r--   0 runner    (1001) docker     (121)    44653 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/pybind11_vs_boost_python1.png
--rw-r--r--   0 runner    (1001) docker     (121)    87708 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/pybind11_vs_boost_python1.svg
--rw-r--r--   0 runner    (1001) docker     (121)    41121 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/pybind11_vs_boost_python2.png
--rw-r--r--   0 runner    (1001) docker     (121)    85853 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/pybind11_vs_boost_python2.svg
--rw-r--r--   0 runner    (1001) docker     (121)     2647 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/reference.rst
--rw-r--r--   0 runner    (1001) docker     (121)     4414 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/release.rst
--rw-r--r--   0 runner    (1001) docker     (121)      130 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/requirements.txt
--rw-r--r--   0 runner    (1001) docker     (121)    23491 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/docs/upgrade.rst
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.833537 python_prtree-0.6.0/third/pybind11/include/
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.865537 python_prtree-0.6.0/third/pybind11/include/pybind11/
--rw-r--r--   0 runner    (1001) docker     (121)    23920 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/include/pybind11/attr.h
--rw-r--r--   0 runner    (1001) docker     (121)     7069 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/include/pybind11/buffer_info.h
--rw-r--r--   0 runner    (1001) docker     (121)    64793 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/include/pybind11/cast.h
--rw-r--r--   0 runner    (1001) docker     (121)     8907 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/include/pybind11/chrono.h
--rw-r--r--   0 runner    (1001) docker     (121)      120 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/include/pybind11/common.h
--rw-r--r--   0 runner    (1001) docker     (121)     2096 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/include/pybind11/complex.h
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.869537 python_prtree-0.6.0/third/pybind11/include/pybind11/detail/
--rw-r--r--   0 runner    (1001) docker     (121)    28526 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/include/pybind11/detail/class.h
--rw-r--r--   0 runner    (1001) docker     (121)    51655 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/include/pybind11/detail/common.h
--rw-r--r--   0 runner    (1001) docker     (121)     5491 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/include/pybind11/detail/descr.h
--rw-r--r--   0 runner    (1001) docker     (121)    17971 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/include/pybind11/detail/init.h
--rw-r--r--   0 runner    (1001) docker     (121)    24196 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/include/pybind11/detail/internals.h
--rw-r--r--   0 runner    (1001) docker     (121)    44414 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/include/pybind11/detail/type_caster_base.h
--rw-r--r--   0 runner    (1001) docker     (121)     1513 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/include/pybind11/detail/typeid.h
--rw-r--r--   0 runner    (1001) docker     (121)    31441 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/include/pybind11/eigen.h
--rw-r--r--   0 runner    (1001) docker     (121)    12175 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/include/pybind11/embed.h
--rw-r--r--   0 runner    (1001) docker     (121)     5589 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/include/pybind11/eval.h
--rw-r--r--   0 runner    (1001) docker     (121)     4755 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/include/pybind11/functional.h
--rw-r--r--   0 runner    (1001) docker     (121)     6848 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/include/pybind11/gil.h
--rw-r--r--   0 runner    (1001) docker     (121)     8851 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/include/pybind11/iostream.h
--rw-r--r--   0 runner    (1001) docker     (121)    78036 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/include/pybind11/numpy.h
--rw-r--r--   0 runner    (1001) docker     (121)     9781 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/include/pybind11/operators.h
--rw-r--r--   0 runner    (1001) docker     (121)     2181 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/include/pybind11/options.h
--rw-r--r--   0 runner    (1001) docker     (121)   125927 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/include/pybind11/pybind11.h
--rw-r--r--   0 runner    (1001) docker     (121)    80901 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/include/pybind11/pytypes.h
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.869537 python_prtree-0.6.0/third/pybind11/include/pybind11/stl/
--rw-r--r--   0 runner    (1001) docker     (121)     3551 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/include/pybind11/stl/filesystem.h
--rw-r--r--   0 runner    (1001) docker     (121)    14438 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/include/pybind11/stl.h
--rw-r--r--   0 runner    (1001) docker     (121)    26992 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/include/pybind11/stl_bind.h
--rw-r--r--   0 runner    (1001) docker     (121)     2575 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/noxfile.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.869537 python_prtree-0.6.0/third/pybind11/pybind11/
--rw-r--r--   0 runner    (1001) docker     (121)      216 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/pybind11/__init__.py
--rw-r--r--   0 runner    (1001) docker     (121)     1158 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/pybind11/__main__.py
--rw-r--r--   0 runner    (1001) docker     (121)      202 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/pybind11/_version.py
--rw-r--r--   0 runner    (1001) docker     (121)      137 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/pybind11/_version.pyi
--rw-r--r--   0 runner    (1001) docker     (121)      662 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/pybind11/commands.py
--rw-r--r--   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/pybind11/py.typed
--rw-r--r--   0 runner    (1001) docker     (121)    17483 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/pybind11/setup_helpers.py
--rw-r--r--   0 runner    (1001) docker     (121)     2038 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/pybind11/setup_helpers.pyi
--rw-r--r--   0 runner    (1001) docker     (121)      957 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/pyproject.toml
--rw-r--r--   0 runner    (1001) docker     (121)     1910 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/setup.cfg
--rw-r--r--   0 runner    (1001) docker     (121)     5057 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/setup.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.877537 python_prtree-0.6.0/third/pybind11/tests/
--rw-r--r--   0 runner    (1001) docker     (121)    21095 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (121)     4841 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/conftest.py
--rw-r--r--   0 runner    (1001) docker     (121)    11734 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/constructor_stats.h
--rw-r--r--   0 runner    (1001) docker     (121)     1781 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/cross_module_gil_utils.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     1022 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/env.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.877537 python_prtree-0.6.0/third/pybind11/tests/extra_python_package/
--rw-r--r--   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/extra_python_package/pytest.ini
--rw-r--r--   0 runner    (1001) docker     (121)     7578 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/extra_python_package/test_files.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.877537 python_prtree-0.6.0/third/pybind11/tests/extra_setuptools/
--rw-r--r--   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/extra_setuptools/pytest.ini
--rw-r--r--   0 runner    (1001) docker     (121)     4221 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/extra_setuptools/test_setuphelper.py
--rw-r--r--   0 runner    (1001) docker     (121)     2847 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/local_bindings.h
--rw-r--r--   0 runner    (1001) docker     (121)     5743 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/object.h
--rw-r--r--   0 runner    (1001) docker     (121)     6264 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/pybind11_cross_module_tests.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     3686 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/pybind11_tests.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     3018 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/pybind11_tests.h
--rw-r--r--   0 runner    (1001) docker     (121)      693 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/pytest.ini
--rw-r--r--   0 runner    (1001) docker     (121)      877 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/requirements.txt
--rw-r--r--   0 runner    (1001) docker     (121)      855 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_async.cpp
--rw-r--r--   0 runner    (1001) docker     (121)      558 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_async.py
--rw-r--r--   0 runner    (1001) docker     (121)     8567 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_buffers.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     5055 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_buffers.py
--rw-r--r--   0 runner    (1001) docker     (121)    15872 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_builtin_casters.cpp
--rw-r--r--   0 runner    (1001) docker     (121)    18372 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_builtin_casters.py
--rw-r--r--   0 runner    (1001) docker     (121)     4118 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_call_policies.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     6573 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_call_policies.py
--rw-r--r--   0 runner    (1001) docker     (121)     9243 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_callbacks.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     6044 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_callbacks.py
--rw-r--r--   0 runner    (1001) docker     (121)     3370 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_chrono.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     5727 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_chrono.py
--rw-r--r--   0 runner    (1001) docker     (121)    23812 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_class.cpp
--rw-r--r--   0 runner    (1001) docker     (121)    14508 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_class.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.877537 python_prtree-0.6.0/third/pybind11/tests/test_cmake_build/
--rw-r--r--   0 runner    (1001) docker     (121)     2639 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_cmake_build/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (121)      673 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_cmake_build/embed.cpp
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.881537 python_prtree-0.6.0/third/pybind11/tests/test_cmake_build/installed_embed/
--rw-r--r--   0 runner    (1001) docker     (121)     1171 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_cmake_build/installed_embed/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.881537 python_prtree-0.6.0/third/pybind11/tests/test_cmake_build/installed_function/
--rw-r--r--   0 runner    (1001) docker     (121)     1293 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_cmake_build/installed_function/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.881537 python_prtree-0.6.0/third/pybind11/tests/test_cmake_build/installed_target/
--rw-r--r--   0 runner    (1001) docker     (121)     1685 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_cmake_build/installed_target/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (121)      152 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_cmake_build/main.cpp
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.881537 python_prtree-0.6.0/third/pybind11/tests/test_cmake_build/subdirectory_embed/
--rw-r--r--   0 runner    (1001) docker     (121)     1353 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_cmake_build/subdirectory_embed/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.881537 python_prtree-0.6.0/third/pybind11/tests/test_cmake_build/subdirectory_function/
--rw-r--r--   0 runner    (1001) docker     (121)     1163 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_cmake_build/subdirectory_function/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.881537 python_prtree-0.6.0/third/pybind11/tests/test_cmake_build/subdirectory_target/
--rw-r--r--   0 runner    (1001) docker     (121)     1368 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_cmake_build/subdirectory_target/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (121)      273 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_cmake_build/test.py
--rw-r--r--   0 runner    (1001) docker     (121)     4254 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_const_name.cpp
--rw-r--r--   0 runner    (1001) docker     (121)      650 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_const_name.py
--rw-r--r--   0 runner    (1001) docker     (121)     5934 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_constants_and_functions.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     1522 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_constants_and_functions.py
--rw-r--r--   0 runner    (1001) docker     (121)    10718 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_copy_move.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     4646 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_copy_move.py
--rw-r--r--   0 runner    (1001) docker     (121)     7210 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_custom_type_casters.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     4088 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_custom_type_casters.py
--rw-r--r--   0 runner    (1001) docker     (121)     1259 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_custom_type_setup.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     1114 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_custom_type_setup.py
--rw-r--r--   0 runner    (1001) docker     (121)     2816 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_docstring_options.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     1630 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_docstring_options.py
--rw-r--r--   0 runner    (1001) docker     (121)    18169 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_eigen.cpp
--rw-r--r--   0 runner    (1001) docker     (121)    28283 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_eigen.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.881537 python_prtree-0.6.0/third/pybind11/tests/test_embed/
--rw-r--r--   0 runner    (1001) docker     (121)     1798 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_embed/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (121)      733 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_embed/catch.cpp
--rw-r--r--   0 runner    (1001) docker     (121)      543 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_embed/external_module.cpp
--rw-r--r--   0 runner    (1001) docker     (121)    14173 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_embed/test_interpreter.cpp
--rw-r--r--   0 runner    (1001) docker     (121)      280 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_embed/test_interpreter.py
--rw-r--r--   0 runner    (1001) docker     (121)      300 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_embed/test_trampoline.py
--rw-r--r--   0 runner    (1001) docker     (121)     5722 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_enum.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     9132 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_enum.py
--rw-r--r--   0 runner    (1001) docker     (121)     3168 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_eval.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     1183 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_eval.py
--rw-r--r--   0 runner    (1001) docker     (121)      143 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_eval_call.py
--rw-r--r--   0 runner    (1001) docker     (121)    10197 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_exceptions.cpp
--rw-r--r--   0 runner    (1001) docker     (121)      399 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_exceptions.h
--rw-r--r--   0 runner    (1001) docker     (121)     9038 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_exceptions.py
--rw-r--r--   0 runner    (1001) docker     (121)    18419 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_factory_constructors.cpp
--rw-r--r--   0 runner    (1001) docker     (121)    16731 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_factory_constructors.py
--rw-r--r--   0 runner    (1001) docker     (121)     1673 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_gil_scoped.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     3128 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_gil_scoped.py
--rw-r--r--   0 runner    (1001) docker     (121)     4122 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_iostream.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     7958 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_iostream.py
--rw-r--r--   0 runner    (1001) docker     (121)     9236 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_kwargs_and_defaults.cpp
--rw-r--r--   0 runner    (1001) docker     (121)    13998 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_kwargs_and_defaults.py
--rw-r--r--   0 runner    (1001) docker     (121)     4401 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_local_bindings.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     8101 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_local_bindings.py
--rw-r--r--   0 runner    (1001) docker     (121)    21327 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_methods_and_attributes.cpp
--rw-r--r--   0 runner    (1001) docker     (121)    17804 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_methods_and_attributes.py
--rw-r--r--   0 runner    (1001) docker     (121)     4021 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_modules.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     2843 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_modules.py
--rw-r--r--   0 runner    (1001) docker     (121)    12305 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_multiple_inheritance.cpp
--rw-r--r--   0 runner    (1001) docker     (121)    12034 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_multiple_inheritance.py
--rw-r--r--   0 runner    (1001) docker     (121)    19774 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_numpy_array.cpp
--rw-r--r--   0 runner    (1001) docker     (121)    20339 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_numpy_array.py
--rw-r--r--   0 runner    (1001) docker     (121)    20154 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_numpy_dtypes.cpp
--rw-r--r--   0 runner    (1001) docker     (121)    14036 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_numpy_dtypes.py
--rw-r--r--   0 runner    (1001) docker     (121)     4461 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_numpy_vectorize.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     9710 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_numpy_vectorize.py
--rw-r--r--   0 runner    (1001) docker     (121)     2777 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_opaque_types.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     1907 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_opaque_types.py
--rw-r--r--   0 runner    (1001) docker     (121)     9463 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_operator_overloading.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     4392 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_operator_overloading.py
--rw-r--r--   0 runner    (1001) docker     (121)     6646 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_pickling.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     2286 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_pickling.py
--rw-r--r--   0 runner    (1001) docker     (121)    20878 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_pytypes.cpp
--rw-r--r--   0 runner    (1001) docker     (121)    19010 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_pytypes.py
--rw-r--r--   0 runner    (1001) docker     (121)    20580 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_sequences_and_iterators.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     8059 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_sequences_and_iterators.py
--rw-r--r--   0 runner    (1001) docker     (121)    19040 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_smart_ptr.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     9620 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_smart_ptr.py
--rw-r--r--   0 runner    (1001) docker     (121)    20722 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_stl.cpp
--rw-r--r--   0 runner    (1001) docker     (121)    11662 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_stl.py
--rw-r--r--   0 runner    (1001) docker     (121)     4622 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_stl_binders.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     8071 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_stl_binders.py
--rw-r--r--   0 runner    (1001) docker     (121)     4597 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_tagbased_polymorphic.cpp
--rw-r--r--   0 runner    (1001) docker     (121)      765 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_tagbased_polymorphic.py
--rw-r--r--   0 runner    (1001) docker     (121)     1855 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_thread.cpp
--rw-r--r--   0 runner    (1001) docker     (121)      875 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_thread.py
--rw-r--r--   0 runner    (1001) docker     (121)      603 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_union.cpp
--rw-r--r--   0 runner    (1001) docker     (121)      172 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_union.py
--rw-r--r--   0 runner    (1001) docker     (121)    23102 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_virtual_functions.cpp
--rw-r--r--   0 runner    (1001) docker     (121)    13146 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/test_virtual_functions.py
--rw-r--r--   0 runner    (1001) docker     (121)     3226 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/valgrind-numpy-scipy.supp
--rw-r--r--   0 runner    (1001) docker     (121)     2657 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tests/valgrind-python.supp
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.881537 python_prtree-0.6.0/third/pybind11/tools/
--rw-r--r--   0 runner    (1001) docker     (121)     2350 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tools/FindCatch.cmake
--rw-r--r--   0 runner    (1001) docker     (121)     3105 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tools/FindEigen3.cmake
--rw-r--r--   0 runner    (1001) docker     (121)    10378 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tools/FindPythonLibsNew.cmake
--rwxr-xr-x   0 runner    (1001) docker     (121)     1423 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tools/check-style.sh
--rw-r--r--   0 runner    (1001) docker     (121)      952 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tools/cmake_uninstall.cmake.in
--rw-r--r--   0 runner    (1001) docker     (121)     1122 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tools/libsize.py
--rwxr-xr-x   0 runner    (1001) docker     (121)     1306 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tools/make_changelog.py
--rw-r--r--   0 runner    (1001) docker     (121)    14579 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tools/pybind11Common.cmake
--rw-r--r--   0 runner    (1001) docker     (121)     7063 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tools/pybind11Config.cmake.in
--rw-r--r--   0 runner    (1001) docker     (121)     9673 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tools/pybind11NewTools.cmake
--rw-r--r--   0 runner    (1001) docker     (121)     7447 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tools/pybind11Tools.cmake
--rw-r--r--   0 runner    (1001) docker     (121)       94 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tools/pyproject.toml
--rw-r--r--   0 runner    (1001) docker     (121)     1951 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tools/setup_global.py.in
--rw-r--r--   0 runner    (1001) docker     (121)     1089 2022-11-02 15:09:21.000000 python_prtree-0.6.0/third/pybind11/tools/setup_main.py.in
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.885537 python_prtree-0.6.0/third/snappy/
--rw-r--r--   0 runner    (1001) docker     (121)     1064 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/.appveyor.yml
--rw-r--r--   0 runner    (1001) docker     (121)       40 2022-11-02 15:09:20.000000 python_prtree-0.6.0/third/snappy/.git
--rw-r--r--   0 runner    (1001) docker     (121)       67 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/.gitignore
--rw-r--r--   0 runner    (1001) docker     (121)     2639 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/.travis.yml
--rw-r--r--   0 runner    (1001) docker     (121)       22 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/AUTHORS
--rw-r--r--   0 runner    (1001) docker     (121)     9891 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (121)     1118 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/CONTRIBUTING.md
--rw-r--r--   0 runner    (1001) docker     (121)     2645 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/COPYING
--rw-r--r--   0 runner    (1001) docker     (121)     5843 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/NEWS
--rw-r--r--   0 runner    (1001) docker     (121)     5857 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/README.md
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.885537 python_prtree-0.6.0/third/snappy/cmake/
--rw-r--r--   0 runner    (1001) docker     (121)     1633 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/cmake/SnappyConfig.cmake.in
--rw-r--r--   0 runner    (1001) docker     (121)     2049 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/cmake/config.h.in
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.885537 python_prtree-0.6.0/third/snappy/docs/
--rw-r--r--   0 runner    (1001) docker     (121)     3873 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/docs/README.md
--rw-r--r--   0 runner    (1001) docker     (121)     4388 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/format_description.txt
--rw-r--r--   0 runner    (1001) docker     (121)     5039 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/framing_format.txt
--rw-r--r--   0 runner    (1001) docker     (121)     3637 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/snappy-c.cc
--rw-r--r--   0 runner    (1001) docker     (121)     5414 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/snappy-c.h
--rw-r--r--   0 runner    (1001) docker     (121)     9806 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/snappy-internal.h
--rw-r--r--   0 runner    (1001) docker     (121)     3286 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/snappy-sinksource.cc
--rw-r--r--   0 runner    (1001) docker     (121)     7256 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/snappy-sinksource.h
--rw-r--r--   0 runner    (1001) docker     (121)     1832 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/snappy-stubs-internal.cc
--rw-r--r--   0 runner    (1001) docker     (121)    18531 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/snappy-stubs-internal.h
--rw-r--r--   0 runner    (1001) docker     (121)     2952 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/snappy-stubs-public.h.in
--rw-r--r--   0 runner    (1001) docker     (121)    20467 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/snappy-test.cc
--rw-r--r--   0 runner    (1001) docker     (121)    15748 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/snappy-test.h
--rw-r--r--   0 runner    (1001) docker     (121)    58864 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/snappy.cc
--rw-r--r--   0 runner    (1001) docker     (121)     9885 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/snappy.h
--rw-r--r--   0 runner    (1001) docker     (121)     2601 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/snappy_compress_fuzzer.cc
--rw-r--r--   0 runner    (1001) docker     (121)     2472 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/snappy_uncompress_fuzzer.cc
--rw-r--r--   0 runner    (1001) docker     (121)    51460 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/snappy_unittest.cc
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-11-02 15:09:23.889537 python_prtree-0.6.0/third/snappy/testdata/
--rw-r--r--   0 runner    (1001) docker     (121)   152089 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/testdata/alice29.txt
--rw-r--r--   0 runner    (1001) docker     (121)   125179 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/testdata/asyoulik.txt
--rw-r--r--   0 runner    (1001) docker     (121)    27512 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/testdata/baddata1.snappy
--rw-r--r--   0 runner    (1001) docker     (121)    27483 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/testdata/baddata2.snappy
--rw-r--r--   0 runner    (1001) docker     (121)    28384 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/testdata/baddata3.snappy
--rw-r--r--   0 runner    (1001) docker     (121)   123093 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/testdata/fireworks.jpeg
--rw-r--r--   0 runner    (1001) docker     (121)   118588 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/testdata/geo.protodata
--rw-r--r--   0 runner    (1001) docker     (121)   102400 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/testdata/html
--rw-r--r--   0 runner    (1001) docker     (121)   409600 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/testdata/html_x_4
--rw-r--r--   0 runner    (1001) docker     (121)   184320 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/testdata/kppkn.gtb
--rw-r--r--   0 runner    (1001) docker     (121)   426754 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/testdata/lcet10.txt
--rw-r--r--   0 runner    (1001) docker     (121)   102400 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/testdata/paper-100k.pdf
--rw-r--r--   0 runner    (1001) docker     (121)   481861 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/testdata/plrabn12.txt
--rw-r--r--   0 runner    (1001) docker     (121)   702087 2022-11-02 15:09:22.000000 python_prtree-0.6.0/third/snappy/testdata/urls.10K
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.748903 python_prtree-0.6.1/
+-rw-r--r--   0 runner    (1001) docker     (127)     1088 2024-04-13 00:48:46.000000 python_prtree-0.6.1/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (127)     1062 2024-04-13 00:48:46.000000 python_prtree-0.6.1/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (127)      162 2024-04-13 00:48:46.000000 python_prtree-0.6.1/MANIFEST.in
+-rw-r--r--   0 runner    (1001) docker     (127)     6267 2024-04-13 00:48:56.748903 python_prtree-0.6.1/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (127)     5614 2024-04-13 00:48:46.000000 python_prtree-0.6.1/README.md
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.656901 python_prtree-0.6.1/cpp/
+-rw-r--r--   0 runner    (1001) docker     (127)     5276 2024-04-13 00:48:46.000000 python_prtree-0.6.1/cpp/main.cc
+-rw-r--r--   0 runner    (1001) docker     (127)     2480 2024-04-13 00:48:46.000000 python_prtree-0.6.1/cpp/parallel.h
+-rw-r--r--   0 runner    (1001) docker     (127)    31176 2024-04-13 00:48:46.000000 python_prtree-0.6.1/cpp/prtree.h
+-rw-r--r--   0 runner    (1001) docker     (127)    33515 2024-04-13 00:48:46.000000 python_prtree-0.6.1/cpp/small_vector.h
+-rw-r--r--   0 runner    (1001) docker     (127)       16 2024-04-13 00:48:46.000000 python_prtree-0.6.1/requirements.txt
+-rw-r--r--   0 runner    (1001) docker     (127)       38 2024-04-13 00:48:56.748903 python_prtree-0.6.1/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (127)     3904 2024-04-13 00:48:46.000000 python_prtree-0.6.1/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.648901 python_prtree-0.6.1/src/
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.656901 python_prtree-0.6.1/src/python_prtree/
+-rw-r--r--   0 runner    (1001) docker     (127)     2007 2024-04-13 00:48:46.000000 python_prtree-0.6.1/src/python_prtree/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.656901 python_prtree-0.6.1/src/python_prtree.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (127)     6267 2024-04-13 00:48:56.000000 python_prtree-0.6.1/src/python_prtree.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (127)    22257 2024-04-13 00:48:56.000000 python_prtree-0.6.1/src/python_prtree.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (127)        1 2024-04-13 00:48:56.000000 python_prtree-0.6.1/src/python_prtree.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (127)        1 2024-04-13 00:48:56.000000 python_prtree-0.6.1/src/python_prtree.egg-info/not-zip-safe
+-rw-r--r--   0 runner    (1001) docker     (127)       17 2024-04-13 00:48:56.000000 python_prtree-0.6.1/src/python_prtree.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (127)       14 2024-04-13 00:48:56.000000 python_prtree-0.6.1/src/python_prtree.egg-info/top_level.txt
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.656901 python_prtree-0.6.1/third/
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.660901 python_prtree-0.6.1/third/cereal/
+-rw-r--r--   0 runner    (1001) docker     (127)      525 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/.gitignore
+-rw-r--r--   0 runner    (1001) docker     (127)     8714 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/.travis.yml
+-rw-r--r--   0 runner    (1001) docker     (127)     2228 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (127)       81 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/Config.cmake.in
+-rw-r--r--   0 runner    (1001) docker     (127)     1519 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (127)     2684 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/README.md
+-rw-r--r--   0 runner    (1001) docker     (127)      978 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/appveyor.yml
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.660901 python_prtree-0.6.1/third/cereal/doc/
+-rw-r--r--   0 runner    (1001) docker     (127)      689 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/doc/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (127)     6115 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/doc/DoxygenLayout.xml
+-rw-r--r--   0 runner    (1001) docker     (127)    80217 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/doc/doxygen.in
+-rw-r--r--   0 runner    (1001) docker     (127)     1139 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/doc/footer.html
+-rw-r--r--   0 runner    (1001) docker     (127)     2038 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/doc/mainpage.dox
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.648901 python_prtree-0.6.1/third/cereal/include/
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.660901 python_prtree-0.6.1/third/cereal/include/cereal/
+-rw-r--r--   0 runner    (1001) docker     (127)    14820 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/access.hpp
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.660901 python_prtree-0.6.1/third/cereal/include/cereal/archives/
+-rw-r--r--   0 runner    (1001) docker     (127)     6034 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/archives/adapters.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     6760 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/archives/binary.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)    43681 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/archives/json.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)    14780 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/archives/portable_binary.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)    39071 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/archives/xml.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)    45263 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/cereal.hpp
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.664901 python_prtree-0.6.1/third/cereal/include/cereal/details/
+-rw-r--r--   0 runner    (1001) docker     (127)    15930 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/details/helpers.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)    37111 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/details/polymorphic_impl.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2902 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/details/polymorphic_impl_fwd.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     4918 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/details/static_object.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)    96668 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/details/traits.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2931 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/details/util.hpp
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.664901 python_prtree-0.6.1/third/cereal/include/cereal/external/
+-rw-r--r--   0 runner    (1001) docker     (127)      921 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (127)     4446 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/base64.hpp
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.668901 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/
+-rw-r--r--   0 runner    (1001) docker     (127)      678 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (127)    10815 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/allocators.h
+-rw-r--r--   0 runner    (1001) docker     (127)     2365 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/cursorstreamwrapper.h
+-rw-r--r--   0 runner    (1001) docker     (127)   119446 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/document.h
+-rw-r--r--   0 runner    (1001) docker     (127)    10989 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/encodedstream.h
+-rw-r--r--   0 runner    (1001) docker     (127)    30191 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/encodings.h
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.668901 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/error/
+-rw-r--r--   0 runner    (1001) docker     (127)     4080 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/error/en.h
+-rw-r--r--   0 runner    (1001) docker     (127)     6374 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/error/error.h
+-rw-r--r--   0 runner    (1001) docker     (127)     3113 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/filereadstream.h
+-rw-r--r--   0 runner    (1001) docker     (127)     3244 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/filewritestream.h
+-rw-r--r--   0 runner    (1001) docker     (127)     4070 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/fwd.h
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.668901 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/internal/
+-rw-r--r--   0 runner    (1001) docker     (127)     9218 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/internal/biginteger.h
+-rw-r--r--   0 runner    (1001) docker     (127)    12730 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/internal/diyfp.h
+-rw-r--r--   0 runner    (1001) docker     (127)     8195 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/internal/dtoa.h
+-rw-r--r--   0 runner    (1001) docker     (127)     3064 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/internal/ieee754.h
+-rw-r--r--   0 runner    (1001) docker     (127)    10194 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/internal/itoa.h
+-rw-r--r--   0 runner    (1001) docker     (127)     6879 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/internal/meta.h
+-rw-r--r--   0 runner    (1001) docker     (127)     3637 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/internal/pow10.h
+-rw-r--r--   0 runner    (1001) docker     (127)    26328 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/internal/regex.h
+-rw-r--r--   0 runner    (1001) docker     (127)     7345 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/internal/stack.h
+-rw-r--r--   0 runner    (1001) docker     (127)     2255 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/internal/strfunc.h
+-rw-r--r--   0 runner    (1001) docker     (127)     9155 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/internal/strtod.h
+-rw-r--r--   0 runner    (1001) docker     (127)     1482 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/internal/swap.h
+-rw-r--r--   0 runner    (1001) docker     (127)     4187 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/istreamwrapper.h
+-rw-r--r--   0 runner    (1001) docker     (127)     2595 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/memorybuffer.h
+-rw-r--r--   0 runner    (1001) docker     (127)     2772 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/memorystream.h
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.668901 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/msinttypes/
+-rw-r--r--   0 runner    (1001) docker     (127)     1569 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/msinttypes/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (127)     8372 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/msinttypes/inttypes.h
+-rw-r--r--   0 runner    (1001) docker     (127)     9386 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/msinttypes/stdint.h
+-rw-r--r--   0 runner    (1001) docker     (127)     2422 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/ostreamwrapper.h
+-rw-r--r--   0 runner    (1001) docker     (127)    61159 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/pointer.h
+-rw-r--r--   0 runner    (1001) docker     (127)    10703 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/prettywriter.h
+-rw-r--r--   0 runner    (1001) docker     (127)    25306 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/rapidjson.h
+-rw-r--r--   0 runner    (1001) docker     (127)    95072 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/reader.h
+-rw-r--r--   0 runner    (1001) docker     (127)   105031 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/schema.h
+-rw-r--r--   0 runner    (1001) docker     (127)     6851 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/stream.h
+-rw-r--r--   0 runner    (1001) docker     (127)     4063 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/stringbuffer.h
+-rw-r--r--   0 runner    (1001) docker     (127)    27313 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/writer.h
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.672901 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidxml/
+-rw-r--r--   0 runner    (1001) docker     (127)     2804 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidxml/license.txt
+-rw-r--r--   0 runner    (1001) docker     (127)   113504 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidxml/manual.html
+-rw-r--r--   0 runner    (1001) docker     (127)   119560 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidxml/rapidxml.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     3862 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidxml/rapidxml_iterators.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)    15689 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidxml/rapidxml_print.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     3324 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/external/rapidxml/rapidxml_utils.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     6552 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/macros.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     6596 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/specialize.hpp
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.676901 python_prtree-0.6.1/third/cereal/include/cereal/types/
+-rw-r--r--   0 runner    (1001) docker     (127)     3501 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/types/array.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2309 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/types/atomic.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     7553 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/types/base_class.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     5455 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/types/bitset.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     5545 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/types/boost_variant.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2899 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/types/chrono.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     5376 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/types/common.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2375 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/types/complex.hpp
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.676901 python_prtree-0.6.1/third/cereal/include/cereal/types/concepts/
+-rw-r--r--   0 runner    (1001) docker     (127)     3210 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/types/concepts/pair_associative_container.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2448 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/types/deque.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2886 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/types/forward_list.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     1975 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/types/functional.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2432 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/types/list.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     1833 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/types/map.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)    16846 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/types/memory.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2555 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/types/optional.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)    22311 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/types/polymorphic.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     4761 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/types/queue.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     3548 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/types/set.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2880 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/types/stack.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2935 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/types/string.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     4633 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/types/tuple.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     1893 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/types/unordered_map.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     3718 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/types/unordered_set.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2127 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/types/utility.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     3942 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/types/valarray.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     4185 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/types/variant.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     4845 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/types/vector.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2342 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/include/cereal/version.hpp
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.676901 python_prtree-0.6.1/third/cereal/sandbox/
+-rw-r--r--   0 runner    (1001) docker     (127)      585 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/sandbox/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (127)    15356 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/sandbox/performance.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)    18434 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/sandbox/sandbox.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     9851 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/sandbox/sandbox_json.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     5558 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/sandbox/sandbox_rtti.cpp
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.676901 python_prtree-0.6.1/third/cereal/sandbox/sandbox_shared_lib/
+-rw-r--r--   0 runner    (1001) docker     (127)       56 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/sandbox/sandbox_shared_lib/CMakeLists.txt
+-rwxr-xr-x   0 runner    (1001) docker     (127)      321 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/sandbox/sandbox_shared_lib/base.cpp
+-rwxr-xr-x   0 runner    (1001) docker     (127)      968 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/sandbox/sandbox_shared_lib/base.hpp
+-rwxr-xr-x   0 runner    (1001) docker     (127)      331 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/sandbox/sandbox_shared_lib/derived.cpp
+-rwxr-xr-x   0 runner    (1001) docker     (127)      610 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/sandbox/sandbox_shared_lib/derived.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     7330 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/sandbox/sandbox_vs.cpp
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.676901 python_prtree-0.6.1/third/cereal/scripts/
+-rwxr-xr-x   0 runner    (1001) docker     (127)      386 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/scripts/add_rapidjson_prefix.sh
+-rw-r--r--   0 runner    (1001) docker     (127)     2648 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/scripts/appveyor.bat
+-rwxr-xr-x   0 runner    (1001) docker     (127)      269 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/scripts/renameincludes.sh
+-rwxr-xr-x   0 runner    (1001) docker     (127)      785 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/scripts/updatecoverage.sh
+-rwxr-xr-x   0 runner    (1001) docker     (127)      531 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/scripts/updatedoc.in
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.692902 python_prtree-0.6.1/third/cereal/unittests/
+-rw-r--r--   0 runner    (1001) docker     (127)     3594 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (127)     2107 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/array.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     3561 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/array.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2117 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/atomic.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     5063 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/atomic.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     4687 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/basic_string.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     3683 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/basic_string.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2117 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/bitset.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     3027 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/bitset.hpp
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.692902 python_prtree-0.6.1/third/cereal/unittests/boost/
+-rw-r--r--   0 runner    (1001) docker     (127)     1540 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/boost/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (127)     2169 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/boost/boost_variant.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     3452 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/boost/boost_variant.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2117 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/chrono.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     3756 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/chrono.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     3261 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/cmake-config-module.cmake
+-rw-r--r--   0 runner    (1001) docker     (127)     7519 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/common.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2127 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/complex.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2938 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/complex.hpp
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.692902 python_prtree-0.6.1/third/cereal/unittests/cpp17/
+-rw-r--r--   0 runner    (1001) docker     (127)     1552 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/cpp17/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (127)     2222 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/cpp17/optional.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     3218 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/cpp17/optional.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2226 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/cpp17/variant.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2692 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/cpp17/variant.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2107 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/defer.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     5713 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/defer.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2115 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/deque.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     3791 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/deque.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)   266816 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/doctest.h
+-rw-r--r--   0 runner    (1001) docker     (127)     2177 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/forward_list.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     3871 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/forward_list.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2097 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/list.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     3478 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/list.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2253 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/load_construct.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     8772 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/load_construct.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2553 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/map.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     5925 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/map.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2663 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/memory.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     4647 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/memory.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2187 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/memory_cycles.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     4111 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/memory_cycles.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2137 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/multimap.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     4864 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/multimap.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2137 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/multiset.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     4363 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/multiset.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2096 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/pair.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     3598 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/pair.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2087 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/pod.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     5530 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/pod.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2773 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/polymorphic.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)    24153 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/polymorphic.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     4928 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/portability_test.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     5093 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/portable_binary_archive.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     5881 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/portable_binary_archive.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2197 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/priority_queue.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     4814 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/priority_queue.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2107 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/queue.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     4193 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/queue.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)      579 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/run_portability_test.cmake
+-rwxr-xr-x   0 runner    (1001) docker     (127)      123 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/run_valgrind.sh
+-rw-r--r--   0 runner    (1001) docker     (127)     2087 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/set.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     3362 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/set.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2107 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/stack.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     4194 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/stack.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2127 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/structs.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2700 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/structs.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2207 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/structs_minimal.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     8195 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/structs_minimal.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2247 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/structs_specialized.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)    12734 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/structs_specialized.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2107 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/tuple.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     3967 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/tuple.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     1934 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/unordered_loads.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     4859 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/unordered_loads.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2187 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/unordered_map.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     4746 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/unordered_map.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2237 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/unordered_multimap.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     6662 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/unordered_multimap.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2237 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/unordered_multiset.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     5241 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/unordered_multiset.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2187 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/unordered_set.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     4369 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/unordered_set.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2237 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/user_data_adapters.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     3522 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/user_data_adapters.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2051 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/valarray.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     3888 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/valarray.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2117 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/vector.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     4210 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/vector.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2755 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/versioning.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     5824 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/cereal/unittests/versioning.hpp
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.696902 python_prtree-0.6.1/third/pybind11/
+-rw-r--r--   0 runner    (1001) docker     (127)     1271 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/.appveyor.yml
+-rw-r--r--   0 runner    (1001) docker     (127)      996 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/.clang-format
+-rw-r--r--   0 runner    (1001) docker     (127)     2605 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/.clang-tidy
+-rw-r--r--   0 runner    (1001) docker     (127)     2196 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/.cmake-format.yaml
+-rw-r--r--   0 runner    (1001) docker     (127)     1308 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/.codespell-ignore-lines
+-rw-r--r--   0 runner    (1001) docker     (127)       36 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/pybind11/.git
+-rw-r--r--   0 runner    (1001) docker     (127)       18 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/.gitattributes
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.696902 python_prtree-0.6.1/third/pybind11/.github/
+-rw-r--r--   0 runner    (1001) docker     (127)      182 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/.github/CODEOWNERS
+-rw-r--r--   0 runner    (1001) docker     (127)    15285 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/.github/CONTRIBUTING.md
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.696902 python_prtree-0.6.1/third/pybind11/.github/ISSUE_TEMPLATE/
+-rw-r--r--   0 runner    (1001) docker     (127)     2561 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/.github/ISSUE_TEMPLATE/bug-report.yml
+-rw-r--r--   0 runner    (1001) docker     (127)      328 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/.github/ISSUE_TEMPLATE/config.yml
+-rw-r--r--   0 runner    (1001) docker     (127)      313 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/.github/dependabot.yml
+-rw-r--r--   0 runner    (1001) docker     (127)      116 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/.github/labeler.yml
+-rw-r--r--   0 runner    (1001) docker     (127)       50 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/.github/labeler_merged.yml
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.696902 python_prtree-0.6.1/third/pybind11/.github/matchers/
+-rw-r--r--   0 runner    (1001) docker     (127)      668 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/.github/matchers/pylint.json
+-rw-r--r--   0 runner    (1001) docker     (127)      645 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/.github/pull_request_template.md
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.696902 python_prtree-0.6.1/third/pybind11/.github/workflows/
+-rw-r--r--   0 runner    (1001) docker     (127)    35430 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/.github/workflows/ci.yml
+-rw-r--r--   0 runner    (1001) docker     (127)     2271 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/.github/workflows/configure.yml
+-rw-r--r--   0 runner    (1001) docker     (127)     1491 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/.github/workflows/format.yml
+-rw-r--r--   0 runner    (1001) docker     (127)      639 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/.github/workflows/labeler.yml
+-rw-r--r--   0 runner    (1001) docker     (127)     2628 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/.github/workflows/pip.yml
+-rw-r--r--   0 runner    (1001) docker     (127)     2876 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/.github/workflows/upstream.yml
+-rw-r--r--   0 runner    (1001) docker     (127)      502 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/.gitignore
+-rw-r--r--   0 runner    (1001) docker     (127)     3703 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/.pre-commit-config.yaml
+-rw-r--r--   0 runner    (1001) docker     (127)      276 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/.readthedocs.yml
+-rw-r--r--   0 runner    (1001) docker     (127)    14018 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (127)     1684 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (127)      247 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/MANIFEST.in
+-rw-r--r--   0 runner    (1001) docker     (127)     7737 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/README.rst
+-rw-r--r--   0 runner    (1001) docker     (127)      688 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/SECURITY.md
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.700902 python_prtree-0.6.1/third/pybind11/docs/
+-rw-r--r--   0 runner    (1001) docker     (127)      607 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/Doxyfile
+-rw-r--r--   0 runner    (1001) docker     (127)     7417 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/Makefile
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.652901 python_prtree-0.6.1/third/pybind11/docs/_static/
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.704902 python_prtree-0.6.1/third/pybind11/docs/_static/css/
+-rw-r--r--   0 runner    (1001) docker     (127)       37 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/_static/css/custom.css
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.704902 python_prtree-0.6.1/third/pybind11/docs/advanced/
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.704902 python_prtree-0.6.1/third/pybind11/docs/advanced/cast/
+-rw-r--r--   0 runner    (1001) docker     (127)     3937 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/advanced/cast/chrono.rst
+-rw-r--r--   0 runner    (1001) docker     (127)     3429 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/advanced/cast/custom.rst
+-rw-r--r--   0 runner    (1001) docker     (127)    14283 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/advanced/cast/eigen.rst
+-rw-r--r--   0 runner    (1001) docker     (127)     3889 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/advanced/cast/functional.rst
+-rw-r--r--   0 runner    (1001) docker     (127)     1556 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/advanced/cast/index.rst
+-rw-r--r--   0 runner    (1001) docker     (127)    12371 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/advanced/cast/overview.rst
+-rw-r--r--   0 runner    (1001) docker     (127)     9586 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/advanced/cast/stl.rst
+-rw-r--r--   0 runner    (1001) docker     (127)     9119 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/advanced/cast/strings.rst
+-rw-r--r--   0 runner    (1001) docker     (127)    47796 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/advanced/classes.rst
+-rw-r--r--   0 runner    (1001) docker     (127)     8460 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/advanced/embedding.rst
+-rw-r--r--   0 runner    (1001) docker     (127)    17846 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/advanced/exceptions.rst
+-rw-r--r--   0 runner    (1001) docker     (127)    26727 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/advanced/functions.rst
+-rw-r--r--   0 runner    (1001) docker     (127)    16583 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/advanced/misc.rst
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.704902 python_prtree-0.6.1/third/pybind11/docs/advanced/pycpp/
+-rw-r--r--   0 runner    (1001) docker     (127)      278 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/advanced/pycpp/index.rst
+-rw-r--r--   0 runner    (1001) docker     (127)    17161 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/advanced/pycpp/numpy.rst
+-rw-r--r--   0 runner    (1001) docker     (127)     9030 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/advanced/pycpp/object.rst
+-rw-r--r--   0 runner    (1001) docker     (127)     5710 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/advanced/pycpp/utilities.rst
+-rw-r--r--   0 runner    (1001) docker     (127)     6377 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/advanced/smart_ptrs.rst
+-rw-r--r--   0 runner    (1001) docker     (127)     9240 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/basics.rst
+-rw-r--r--   0 runner    (1001) docker     (127)     2853 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/benchmark.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3168 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/benchmark.rst
+-rw-r--r--   0 runner    (1001) docker     (127)   126561 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/changelog.rst
+-rw-r--r--   0 runner    (1001) docker     (127)    17090 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/classes.rst
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.704902 python_prtree-0.6.1/third/pybind11/docs/cmake/
+-rw-r--r--   0 runner    (1001) docker     (127)      273 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/cmake/index.rst
+-rw-r--r--   0 runner    (1001) docker     (127)    26301 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/compiling.rst
+-rw-r--r--   0 runner    (1001) docker     (127)    11574 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/conf.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13293 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/faq.rst
+-rw-r--r--   0 runner    (1001) docker     (127)      613 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/index.rst
+-rw-r--r--   0 runner    (1001) docker     (127)     3277 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/installing.rst
+-rw-r--r--   0 runner    (1001) docker     (127)     3079 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/limitations.rst
+-rw-r--r--   0 runner    (1001) docker     (127)    61034 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/pybind11-logo.png
+-rw-r--r--   0 runner    (1001) docker     (127)    44653 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/pybind11_vs_boost_python1.png
+-rw-r--r--   0 runner    (1001) docker     (127)    87708 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/pybind11_vs_boost_python1.svg
+-rw-r--r--   0 runner    (1001) docker     (127)    41121 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/pybind11_vs_boost_python2.png
+-rw-r--r--   0 runner    (1001) docker     (127)    85853 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/pybind11_vs_boost_python2.svg
+-rw-r--r--   0 runner    (1001) docker     (127)     2647 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/reference.rst
+-rw-r--r--   0 runner    (1001) docker     (127)     4948 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/release.rst
+-rw-r--r--   0 runner    (1001) docker     (127)      149 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/requirements.txt
+-rw-r--r--   0 runner    (1001) docker     (127)    25209 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/docs/upgrade.rst
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.652901 python_prtree-0.6.1/third/pybind11/include/
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.708902 python_prtree-0.6.1/third/pybind11/include/pybind11/
+-rw-r--r--   0 runner    (1001) docker     (127)    24334 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/include/pybind11/attr.h
+-rw-r--r--   0 runner    (1001) docker     (127)     7750 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/include/pybind11/buffer_info.h
+-rw-r--r--   0 runner    (1001) docker     (127)    71139 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/include/pybind11/cast.h
+-rw-r--r--   0 runner    (1001) docker     (127)     8458 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/include/pybind11/chrono.h
+-rw-r--r--   0 runner    (1001) docker     (127)      120 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/include/pybind11/common.h
+-rw-r--r--   0 runner    (1001) docker     (127)     2096 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/include/pybind11/complex.h
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.712902 python_prtree-0.6.1/third/pybind11/include/pybind11/detail/
+-rw-r--r--   0 runner    (1001) docker     (127)    28563 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/include/pybind11/detail/class.h
+-rw-r--r--   0 runner    (1001) docker     (127)    53771 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/include/pybind11/detail/common.h
+-rw-r--r--   0 runner    (1001) docker     (127)     5962 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/include/pybind11/detail/descr.h
+-rw-r--r--   0 runner    (1001) docker     (127)    17858 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/include/pybind11/detail/init.h
+-rw-r--r--   0 runner    (1001) docker     (127)    29033 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/include/pybind11/detail/internals.h
+-rw-r--r--   0 runner    (1001) docker     (127)    49892 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/include/pybind11/detail/type_caster_base.h
+-rw-r--r--   0 runner    (1001) docker     (127)     1625 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/include/pybind11/detail/typeid.h
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.712902 python_prtree-0.6.1/third/pybind11/include/pybind11/eigen/
+-rw-r--r--   0 runner    (1001) docker     (127)      378 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/include/pybind11/eigen/common.h
+-rw-r--r--   0 runner    (1001) docker     (127)    32135 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/include/pybind11/eigen/matrix.h
+-rw-r--r--   0 runner    (1001) docker     (127)    18490 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/include/pybind11/eigen/tensor.h
+-rw-r--r--   0 runner    (1001) docker     (127)      316 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/include/pybind11/eigen.h
+-rw-r--r--   0 runner    (1001) docker     (127)    13459 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/include/pybind11/embed.h
+-rw-r--r--   0 runner    (1001) docker     (127)     4731 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/include/pybind11/eval.h
+-rw-r--r--   0 runner    (1001) docker     (127)     5051 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/include/pybind11/functional.h
+-rw-r--r--   0 runner    (1001) docker     (127)     8517 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/include/pybind11/gil.h
+-rw-r--r--   0 runner    (1001) docker     (127)     3876 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/include/pybind11/gil_safe_call_once.h
+-rw-r--r--   0 runner    (1001) docker     (127)     8862 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/include/pybind11/iostream.h
+-rw-r--r--   0 runner    (1001) docker     (127)    84243 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/include/pybind11/numpy.h
+-rw-r--r--   0 runner    (1001) docker     (127)     9103 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/include/pybind11/operators.h
+-rw-r--r--   0 runner    (1001) docker     (127)     2734 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/include/pybind11/options.h
+-rw-r--r--   0 runner    (1001) docker     (127)   129569 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/include/pybind11/pybind11.h
+-rw-r--r--   0 runner    (1001) docker     (127)    98953 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/include/pybind11/pytypes.h
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.712902 python_prtree-0.6.1/third/pybind11/include/pybind11/stl/
+-rw-r--r--   0 runner    (1001) docker     (127)     4185 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/include/pybind11/stl/filesystem.h
+-rw-r--r--   0 runner    (1001) docker     (127)    15532 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/include/pybind11/stl.h
+-rw-r--r--   0 runner    (1001) docker     (127)    28472 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/include/pybind11/stl_bind.h
+-rw-r--r--   0 runner    (1001) docker     (127)     1929 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/include/pybind11/type_caster_pyobject_ptr.h
+-rw-r--r--   0 runner    (1001) docker     (127)     3600 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/include/pybind11/typing.h
+-rw-r--r--   0 runner    (1001) docker     (127)     2746 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/noxfile.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.712902 python_prtree-0.6.1/third/pybind11/pybind11/
+-rw-r--r--   0 runner    (1001) docker     (127)      429 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/pybind11/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1544 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/pybind11/__main__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      228 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/pybind11/_version.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1207 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/pybind11/commands.py
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/pybind11/py.typed
+-rw-r--r--   0 runner    (1001) docker     (127)    17492 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/pybind11/setup_helpers.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2232 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/pyproject.toml
+-rw-r--r--   0 runner    (1001) docker     (127)     1495 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (127)     4855 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.732902 python_prtree-0.6.1/third/pybind11/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)    21874 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (127)     5692 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/conftest.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11736 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/constructor_stats.h
+-rw-r--r--   0 runner    (1001) docker     (127)     3578 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/cross_module_gil_utils.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     1772 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/cross_module_interleaved_error_already_set.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)      396 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/eigen_tensor_avoid_stl_array.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)      926 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/env.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.732902 python_prtree-0.6.1/third/pybind11/tests/extra_python_package/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/extra_python_package/pytest.ini
+-rw-r--r--   0 runner    (1001) docker     (127)     8481 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/extra_python_package/test_files.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.732902 python_prtree-0.6.1/third/pybind11/tests/extra_setuptools/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/extra_setuptools/pytest.ini
+-rw-r--r--   0 runner    (1001) docker     (127)     4153 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/extra_setuptools/test_setuphelper.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2847 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/local_bindings.h
+-rw-r--r--   0 runner    (1001) docker     (127)     5743 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/object.h
+-rw-r--r--   0 runner    (1001) docker     (127)     6256 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/pybind11_cross_module_tests.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     4632 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/pybind11_tests.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2685 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/pybind11_tests.h
+-rw-r--r--   0 runner    (1001) docker     (127)      768 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/pytest.ini
+-rw-r--r--   0 runner    (1001) docker     (127)      995 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/requirements.txt
+-rw-r--r--   0 runner    (1001) docker     (127)      855 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_async.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)      536 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_async.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10548 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_buffers.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     7124 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_buffers.py
+-rw-r--r--   0 runner    (1001) docker     (127)    16025 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_builtin_casters.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)    17243 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_builtin_casters.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4118 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_call_policies.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     6549 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_call_policies.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10858 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_callbacks.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     6955 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_callbacks.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3370 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_chrono.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     5691 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_chrono.py
+-rw-r--r--   0 runner    (1001) docker     (127)    24849 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_class.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)    15187 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_class.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.732902 python_prtree-0.6.1/third/pybind11/tests/test_cmake_build/
+-rw-r--r--   0 runner    (1001) docker     (127)     2581 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_cmake_build/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (127)      673 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_cmake_build/embed.cpp
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.732902 python_prtree-0.6.1/third/pybind11/tests/test_cmake_build/installed_embed/
+-rw-r--r--   0 runner    (1001) docker     (127)     1171 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_cmake_build/installed_embed/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.732902 python_prtree-0.6.1/third/pybind11/tests/test_cmake_build/installed_function/
+-rw-r--r--   0 runner    (1001) docker     (127)     1293 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_cmake_build/installed_function/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.732902 python_prtree-0.6.1/third/pybind11/tests/test_cmake_build/installed_target/
+-rw-r--r--   0 runner    (1001) docker     (127)     1685 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_cmake_build/installed_target/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (127)      152 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_cmake_build/main.cpp
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.732902 python_prtree-0.6.1/third/pybind11/tests/test_cmake_build/subdirectory_embed/
+-rw-r--r--   0 runner    (1001) docker     (127)     1609 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_cmake_build/subdirectory_embed/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.732902 python_prtree-0.6.1/third/pybind11/tests/test_cmake_build/subdirectory_function/
+-rw-r--r--   0 runner    (1001) docker     (127)     1419 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_cmake_build/subdirectory_function/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.732902 python_prtree-0.6.1/third/pybind11/tests/test_cmake_build/subdirectory_target/
+-rw-r--r--   0 runner    (1001) docker     (127)     1624 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_cmake_build/subdirectory_target/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (127)      198 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_cmake_build/test.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3831 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_const_name.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)      593 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_const_name.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5846 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_constants_and_functions.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     1551 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_constants_and_functions.py
+-rw-r--r--   0 runner    (1001) docker     (127)    26064 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_copy_move.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     4796 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_copy_move.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7572 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_custom_type_casters.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     3992 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_custom_type_casters.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1259 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_custom_type_setup.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     1091 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_custom_type_setup.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4557 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_docstring_options.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2423 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_docstring_options.py
+-rw-r--r--   0 runner    (1001) docker     (127)    19958 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_eigen_matrix.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)    29175 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_eigen_matrix.py
+-rw-r--r--   0 runner    (1001) docker     (127)      473 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_eigen_tensor.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)    10590 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_eigen_tensor.inl
+-rw-r--r--   0 runner    (1001) docker     (127)     9414 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_eigen_tensor.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.732902 python_prtree-0.6.1/third/pybind11/tests/test_embed/
+-rw-r--r--   0 runner    (1001) docker     (127)     1798 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_embed/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (127)     1315 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_embed/catch.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)      543 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_embed/external_module.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)    17396 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_embed/test_interpreter.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)      237 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_embed/test_interpreter.py
+-rw-r--r--   0 runner    (1001) docker     (127)      275 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_embed/test_trampoline.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5722 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_enum.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     9069 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_enum.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3168 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_eval.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     1143 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_eval.py
+-rw-r--r--   0 runner    (1001) docker     (127)      119 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_eval_call.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13851 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_exceptions.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)      397 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_exceptions.h
+-rw-r--r--   0 runner    (1001) docker     (127)    14537 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_exceptions.py
+-rw-r--r--   0 runner    (1001) docker     (127)    18155 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_factory_constructors.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)    16491 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_factory_constructors.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5311 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_gil_scoped.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     8507 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_gil_scoped.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3960 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_iostream.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     7144 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_iostream.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11034 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_kwargs_and_defaults.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)    14856 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_kwargs_and_defaults.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4401 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_local_bindings.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     8054 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_local_bindings.py
+-rw-r--r--   0 runner    (1001) docker     (127)    22211 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_methods_and_attributes.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)    18426 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_methods_and_attributes.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4121 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_modules.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     3963 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_modules.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12305 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_multiple_inheritance.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)    11874 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_multiple_inheritance.py
+-rw-r--r--   0 runner    (1001) docker     (127)    20936 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_numpy_array.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)    23073 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_numpy_array.py
+-rw-r--r--   0 runner    (1001) docker     (127)    21517 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_numpy_dtypes.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)    14645 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_numpy_dtypes.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4487 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_numpy_vectorize.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     9658 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_numpy_vectorize.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2777 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_opaque_types.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     1847 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_opaque_types.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9132 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_operator_overloading.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     4332 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_operator_overloading.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6719 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_pickling.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2720 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_pickling.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1555 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_python_multiple_inheritance.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)      859 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_python_multiple_inheritance.py
+-rw-r--r--   0 runner    (1001) docker     (127)    32112 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_pytypes.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)    25274 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_pytypes.py
+-rw-r--r--   0 runner    (1001) docker     (127)    21920 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_sequences_and_iterators.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     8659 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_sequences_and_iterators.py
+-rw-r--r--   0 runner    (1001) docker     (127)    19028 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_smart_ptr.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     9530 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_smart_ptr.py
+-rw-r--r--   0 runner    (1001) docker     (127)    21587 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_stl.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)    12307 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_stl.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8699 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_stl_binders.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)    11043 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_stl_binders.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4617 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_tagbased_polymorphic.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)      741 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_tagbased_polymorphic.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1855 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_thread.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)      826 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_thread.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4497 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_type_caster_pyobject_ptr.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     3260 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_type_caster_pyobject_ptr.py
+-rw-r--r--   0 runner    (1001) docker     (127)      603 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_union.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)      148 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_union.py
+-rw-r--r--   0 runner    (1001) docker     (127)      845 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_unnamed_namespace_a.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     1141 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_unnamed_namespace_a.py
+-rw-r--r--   0 runner    (1001) docker     (127)      341 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_unnamed_namespace_b.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)      143 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_unnamed_namespace_b.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1471 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_vector_unique_ptr_member.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)      329 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_vector_unique_ptr_member.py
+-rw-r--r--   0 runner    (1001) docker     (127)    22991 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_virtual_functions.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)    12913 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/test_virtual_functions.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3226 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/valgrind-numpy-scipy.supp
+-rw-r--r--   0 runner    (1001) docker     (127)     2657 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tests/valgrind-python.supp
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.736903 python_prtree-0.6.1/third/pybind11/tools/
+-rw-r--r--   0 runner    (1001) docker     (127)     2449 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tools/FindCatch.cmake
+-rw-r--r--   0 runner    (1001) docker     (127)     3105 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tools/FindEigen3.cmake
+-rw-r--r--   0 runner    (1001) docker     (127)    12183 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tools/FindPythonLibsNew.cmake
+-rw-r--r--   0 runner    (1001) docker     (127)      817 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tools/JoinPaths.cmake
+-rwxr-xr-x   0 runner    (1001) docker     (127)     1423 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tools/check-style.sh
+-rw-r--r--   0 runner    (1001) docker     (127)      952 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tools/cmake_uninstall.cmake.in
+-rw-r--r--   0 runner    (1001) docker     (127)     1117 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tools/codespell_ignore_lines_from_errors.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1031 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tools/libsize.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     2090 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tools/make_changelog.py
+-rw-r--r--   0 runner    (1001) docker     (127)      196 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tools/pybind11.pc.in
+-rw-r--r--   0 runner    (1001) docker     (127)    15032 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tools/pybind11Common.cmake
+-rw-r--r--   0 runner    (1001) docker     (127)     7101 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tools/pybind11Config.cmake.in
+-rw-r--r--   0 runner    (1001) docker     (127)    10970 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tools/pybind11NewTools.cmake
+-rw-r--r--   0 runner    (1001) docker     (127)     8569 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tools/pybind11Tools.cmake
+-rw-r--r--   0 runner    (1001) docker     (127)       94 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tools/pyproject.toml
+-rw-r--r--   0 runner    (1001) docker     (127)     2104 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tools/setup_global.py.in
+-rw-r--r--   0 runner    (1001) docker     (127)     1234 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/pybind11/tools/setup_main.py.in
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.740903 python_prtree-0.6.1/third/snappy/
+-rw-r--r--   0 runner    (1001) docker     (127)     1064 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/.appveyor.yml
+-rw-r--r--   0 runner    (1001) docker     (127)       40 2024-04-13 00:48:46.000000 python_prtree-0.6.1/third/snappy/.git
+-rw-r--r--   0 runner    (1001) docker     (127)       67 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/.gitignore
+-rw-r--r--   0 runner    (1001) docker     (127)     2639 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/.travis.yml
+-rw-r--r--   0 runner    (1001) docker     (127)       22 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/AUTHORS
+-rw-r--r--   0 runner    (1001) docker     (127)     9891 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (127)     1118 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/CONTRIBUTING.md
+-rw-r--r--   0 runner    (1001) docker     (127)     2645 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/COPYING
+-rw-r--r--   0 runner    (1001) docker     (127)     5843 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/NEWS
+-rw-r--r--   0 runner    (1001) docker     (127)     5857 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/README.md
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.740903 python_prtree-0.6.1/third/snappy/cmake/
+-rw-r--r--   0 runner    (1001) docker     (127)     1633 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/cmake/SnappyConfig.cmake.in
+-rw-r--r--   0 runner    (1001) docker     (127)     2049 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/cmake/config.h.in
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.740903 python_prtree-0.6.1/third/snappy/docs/
+-rw-r--r--   0 runner    (1001) docker     (127)     3873 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/docs/README.md
+-rw-r--r--   0 runner    (1001) docker     (127)     4388 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/format_description.txt
+-rw-r--r--   0 runner    (1001) docker     (127)     5039 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/framing_format.txt
+-rw-r--r--   0 runner    (1001) docker     (127)     3637 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/snappy-c.cc
+-rw-r--r--   0 runner    (1001) docker     (127)     5414 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/snappy-c.h
+-rw-r--r--   0 runner    (1001) docker     (127)     9806 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/snappy-internal.h
+-rw-r--r--   0 runner    (1001) docker     (127)     3286 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/snappy-sinksource.cc
+-rw-r--r--   0 runner    (1001) docker     (127)     7256 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/snappy-sinksource.h
+-rw-r--r--   0 runner    (1001) docker     (127)     1832 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/snappy-stubs-internal.cc
+-rw-r--r--   0 runner    (1001) docker     (127)    18531 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/snappy-stubs-internal.h
+-rw-r--r--   0 runner    (1001) docker     (127)     2952 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/snappy-stubs-public.h.in
+-rw-r--r--   0 runner    (1001) docker     (127)    20467 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/snappy-test.cc
+-rw-r--r--   0 runner    (1001) docker     (127)    15748 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/snappy-test.h
+-rw-r--r--   0 runner    (1001) docker     (127)    58864 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/snappy.cc
+-rw-r--r--   0 runner    (1001) docker     (127)     9885 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/snappy.h
+-rw-r--r--   0 runner    (1001) docker     (127)     2601 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/snappy_compress_fuzzer.cc
+-rw-r--r--   0 runner    (1001) docker     (127)     2472 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/snappy_uncompress_fuzzer.cc
+-rw-r--r--   0 runner    (1001) docker     (127)    51460 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/snappy_unittest.cc
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-13 00:48:56.748903 python_prtree-0.6.1/third/snappy/testdata/
+-rw-r--r--   0 runner    (1001) docker     (127)   152089 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/testdata/alice29.txt
+-rw-r--r--   0 runner    (1001) docker     (127)   125179 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/testdata/asyoulik.txt
+-rw-r--r--   0 runner    (1001) docker     (127)    27512 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/testdata/baddata1.snappy
+-rw-r--r--   0 runner    (1001) docker     (127)    27483 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/testdata/baddata2.snappy
+-rw-r--r--   0 runner    (1001) docker     (127)    28384 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/testdata/baddata3.snappy
+-rw-r--r--   0 runner    (1001) docker     (127)   123093 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/testdata/fireworks.jpeg
+-rw-r--r--   0 runner    (1001) docker     (127)   118588 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/testdata/geo.protodata
+-rw-r--r--   0 runner    (1001) docker     (127)   102400 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/testdata/html
+-rw-r--r--   0 runner    (1001) docker     (127)   409600 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/testdata/html_x_4
+-rw-r--r--   0 runner    (1001) docker     (127)   184320 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/testdata/kppkn.gtb
+-rw-r--r--   0 runner    (1001) docker     (127)   426754 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/testdata/lcet10.txt
+-rw-r--r--   0 runner    (1001) docker     (127)   102400 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/testdata/paper-100k.pdf
+-rw-r--r--   0 runner    (1001) docker     (127)   481861 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/testdata/plrabn12.txt
+-rw-r--r--   0 runner    (1001) docker     (127)   702087 2024-04-13 00:48:47.000000 python_prtree-0.6.1/third/snappy/testdata/urls.10K
```

### Comparing `python_prtree-0.6.0/CMakeLists.txt` & `python_prtree-0.6.1/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/LICENSE` & `python_prtree-0.6.1/LICENSE`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/PKG-INFO` & `python_prtree-0.6.1/README.md`

 * *Files 4% similar despite different names*

```diff
@@ -1,22 +1,7 @@
-Metadata-Version: 2.1
-Name: python_prtree
-Version: 0.6.0
-Summary: Python implementation of Priority R-Tree
-Home-page: https://github.com/atksh/python_prtree
-Author: atksh
-License: MIT
-Keywords: priority-rtree r-tree prtree rtree pybind11
-Platform: UNKNOWN
-Classifier: License :: OSI Approved :: MIT License
-Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: Python :: 3.9
-Description-Content-Type: text/markdown
-License-File: LICENSE
-
 # python_prtree
 
 _python_prtree_ is a python/c++ implementation of the Priority R-Tree (see references below), an alternative to R-Tree. The supported futures are as follows:
 
 - Construct a Priority R-Tree (PRTree) from an array of rectangles.
   - `PRTree2D`, `PRTree3D` and `PRTree4D` (2D, 3D and 4D respectively)
 - `insert` and `erase`
@@ -80,17 +65,21 @@
 # Plus, you can erase by an index.
 prtree.erase(2)
 result = prtree.batch_query(q)
 print(result)
 # [[1], [1, 3]]
 
 # Non-batch query is also supported.
-print(prtree.query(0.5, 0.5))
+print(prtree.query([0.5, 0.5, 1.0, 1.0]))
+# [1, 3]
+
+# Point query is also supported.
+print(prtree.query([0.5, 0.5]))
 # [1]
-print(prtree.query((0.5, 0.5)))
+print(prtree.query(0.5, 0.5))  # 1d-array
 # [1]
 ```
 
 ```python
 import numpy as np
 from python_prtree import PRTree2D
 
@@ -214,9 +203,7 @@
 
 ## Reference
 
 The Priority R-Tree: A Practically Efficient and Worst-Case Optimal R-Tree
 Lars Arge, Mark de Berg, Herman Haverkort, and Ke Yi
 Proceedings of the 2004 ACM SIGMOD International Conference on Management of Data (SIGMOD '04), Paris, France, June 2004, 347-358. Journal version in ACM Transactions on Algorithms.
 [author's page](https://www.cse.ust.hk/~yike/prtree/)
-
-
```

### Comparing `python_prtree-0.6.0/README.md` & `python_prtree-0.6.1/src/python_prtree.egg-info/PKG-INFO`

 * *Files 13% similar despite different names*

```diff
@@ -1,7 +1,25 @@
+Metadata-Version: 2.1
+Name: python-prtree
+Version: 0.6.1
+Summary: Python implementation of Priority R-Tree
+Home-page: https://github.com/atksh/python_prtree
+Author: atksh
+License: MIT
+Keywords: priority-rtree r-tree prtree rtree pybind11
+Classifier: License :: OSI Approved :: MIT License
+Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: Python :: 3.8
+Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
+Classifier: Programming Language :: Python :: 3.12
+Description-Content-Type: text/markdown
+License-File: LICENSE
+
 # python_prtree
 
 _python_prtree_ is a python/c++ implementation of the Priority R-Tree (see references below), an alternative to R-Tree. The supported futures are as follows:
 
 - Construct a Priority R-Tree (PRTree) from an array of rectangles.
   - `PRTree2D`, `PRTree3D` and `PRTree4D` (2D, 3D and 4D respectively)
 - `insert` and `erase`
@@ -65,17 +83,21 @@
 # Plus, you can erase by an index.
 prtree.erase(2)
 result = prtree.batch_query(q)
 print(result)
 # [[1], [1, 3]]
 
 # Non-batch query is also supported.
-print(prtree.query(0.5, 0.5))
+print(prtree.query([0.5, 0.5, 1.0, 1.0]))
+# [1, 3]
+
+# Point query is also supported.
+print(prtree.query([0.5, 0.5]))
 # [1]
-print(prtree.query((0.5, 0.5)))
+print(prtree.query(0.5, 0.5))  # 1d-array
 # [1]
 ```
 
 ```python
 import numpy as np
 from python_prtree import PRTree2D
```

### Comparing `python_prtree-0.6.0/cpp/main.cc` & `python_prtree-0.6.1/cpp/main.cc`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/cpp/parallel.h` & `python_prtree-0.6.1/cpp/parallel.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/cpp/prtree.h` & `python_prtree-0.6.1/cpp/prtree.h`

 * *Files 2% similar despite different names*

```diff
@@ -47,44 +47,46 @@
 using Real = float;
 
 namespace py = pybind11;
 
 template <class T>
 using vec = std::vector<T>;
 
-template <typename Sequence >
-inline py::array_t<typename Sequence::value_type> as_pyarray(Sequence& seq) {
+template <typename Sequence>
+inline py::array_t<typename Sequence::value_type> as_pyarray(Sequence &seq)
+{
 
   auto size = seq.size();
   auto data = seq.data();
   std::unique_ptr<Sequence> seq_ptr = std::make_unique<Sequence>(std::move(seq));
-  auto capsule = py::capsule(seq_ptr.get(), [](void *p) { std::unique_ptr<Sequence>(reinterpret_cast<Sequence*>(p)); });
+  auto capsule = py::capsule(seq_ptr.get(), [](void *p)
+                             { std::unique_ptr<Sequence>(reinterpret_cast<Sequence *>(p)); });
   seq_ptr.release();
   return py::array(size, data, capsule);
 }
 
 template <typename T>
-auto list_list_to_arrays(vec<vec<T>> out_ll){
+auto list_list_to_arrays(vec<vec<T>> out_ll)
+{
   vec<T> out_s;
   out_s.reserve(out_ll.size());
   std::size_t sum = 0;
-  for (auto &&i : out_ll) {
+  for (auto &&i : out_ll)
+  {
     out_s.push_back(i.size());
     sum += i.size();
   }
   vec<T> out;
   out.reserve(sum);
-  for(const auto &v: out_ll)
+  for (const auto &v : out_ll)
     out.insert(out.end(), v.begin(), v.end());
 
   return make_tuple(
-      std::move(as_pyarray(out_s))
-      ,
-      std::move(as_pyarray(out))
-  );
+      std::move(as_pyarray(out_s)),
+      std::move(as_pyarray(out)));
 }
 
 template <class T, size_t StaticCapacity>
 using svec = itlib::small_vector<T, StaticCapacity>;
 
 template <class T>
 using deque = std::deque<T>;
@@ -238,15 +240,15 @@
     for (int i = 0; i < D; ++i)
     {
       minima[i] = std::min(values[i], target.values[i]);
       maxima[i] = std::min(values[i + D], target.values[i + D]);
     }
     for (int i = 0; i < D; ++i)
     {
-      flags[i] = -minima[i] < maxima[i];
+      flags[i] = -minima[i] <= maxima[i];
     }
     for (int i = 0; i < D; ++i)
     {
       flag &= flags[i];
     }
     return flag;
   }
@@ -1287,15 +1289,16 @@
 #ifdef MY_DEBUG
     ProfilerStop();
     std::cout << "profiler end of find_all" << std::endl;
 #endif
     return out;
   }
 
-  auto find_all_array(const py::array_t<float> &x){
+  auto find_all_array(const py::array_t<float> &x)
+  {
     return list_list_to_arrays(std::move(find_all(x)));
   }
 
   auto find_one(const vec<float> &x)
   {
     bool is_point = false;
     if (unlikely(!(x.size() == 2 * D || x.size() == D)))
@@ -1330,14 +1333,15 @@
     vec<T> out;
     auto find_func = [&](std::unique_ptr<PRTreeLeaf<T, B, D>> &leaf)
     {
       (*leaf)(target, out);
     };
 
     bfs<T, B, D>(std::move(find_func), flat_tree, target);
+    std::sort(out.begin(), out.end());
     return out;
   }
 
   void erase(const T idx)
   {
     auto it = idx2bb.find(idx);
     if (unlikely(it == idx2bb.end()))
```

### Comparing `python_prtree-0.6.0/cpp/small_vector.h` & `python_prtree-0.6.1/cpp/small_vector.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/setup.py` & `python_prtree-0.6.1/setup.py`

 * *Files 12% similar despite different names*

```diff
@@ -5,15 +5,15 @@
 import sys
 from distutils.version import LooseVersion
 from multiprocessing import cpu_count
 
 from setuptools import Extension, find_packages, setup
 from setuptools.command.build_ext import build_ext
 
-version = "v0.6.0"
+version = "v0.6.1"
 
 sys.path.append("./tests")
 
 here = os.path.abspath(os.path.dirname(__file__))
 with open(os.path.join(here, "README.md"), encoding="utf-8") as f:
     long_description = f.read()
 
@@ -105,10 +105,14 @@
     test_suite="test_PRTree.suite",
     long_description=long_description,
     long_description_content_type="text/markdown",
     keywords="priority-rtree r-tree prtree rtree pybind11",
     classifiers=[
         "License :: OSI Approved :: MIT License",
         "Programming Language :: Python :: 3",
+        "Programming Language :: Python :: 3.8",
         "Programming Language :: Python :: 3.9",
+        "Programming Language :: Python :: 3.10",
+        "Programming Language :: Python :: 3.11",
+        "Programming Language :: Python :: 3.12",
     ],
 )
```

### Comparing `python_prtree-0.6.0/src/python_prtree/__init__.py` & `python_prtree-0.6.1/src/python_prtree/__init__.py`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/src/python_prtree.egg-info/PKG-INFO` & `python_prtree-0.6.1/PKG-INFO`

 * *Files 8% similar despite different names*

```diff
@@ -1,19 +1,22 @@
 Metadata-Version: 2.1
-Name: python-prtree
-Version: 0.6.0
+Name: python_prtree
+Version: 0.6.1
 Summary: Python implementation of Priority R-Tree
 Home-page: https://github.com/atksh/python_prtree
 Author: atksh
 License: MIT
 Keywords: priority-rtree r-tree prtree rtree pybind11
-Platform: UNKNOWN
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
+Classifier: Programming Language :: Python :: 3.12
 Description-Content-Type: text/markdown
 License-File: LICENSE
 
 # python_prtree
 
 _python_prtree_ is a python/c++ implementation of the Priority R-Tree (see references below), an alternative to R-Tree. The supported futures are as follows:
 
@@ -80,17 +83,21 @@
 # Plus, you can erase by an index.
 prtree.erase(2)
 result = prtree.batch_query(q)
 print(result)
 # [[1], [1, 3]]
 
 # Non-batch query is also supported.
-print(prtree.query(0.5, 0.5))
+print(prtree.query([0.5, 0.5, 1.0, 1.0]))
+# [1, 3]
+
+# Point query is also supported.
+print(prtree.query([0.5, 0.5]))
 # [1]
-print(prtree.query((0.5, 0.5)))
+print(prtree.query(0.5, 0.5))  # 1d-array
 # [1]
 ```
 
 ```python
 import numpy as np
 from python_prtree import PRTree2D
 
@@ -214,9 +221,7 @@
 
 ## Reference
 
 The Priority R-Tree: A Practically Efficient and Worst-Case Optimal R-Tree
 Lars Arge, Mark de Berg, Herman Haverkort, and Ke Yi
 Proceedings of the 2004 ACM SIGMOD International Conference on Management of Data (SIGMOD '04), Paris, France, June 2004, 347-358. Journal version in ACM Transactions on Algorithms.
 [author's page](https://www.cse.ust.hk/~yike/prtree/)
-
-
```

### Comparing `python_prtree-0.6.0/src/python_prtree.egg-info/SOURCES.txt` & `python_prtree-0.6.1/src/python_prtree.egg-info/SOURCES.txt`

 * *Files 4% similar despite different names*

```diff
@@ -222,34 +222,38 @@
 third/cereal/unittests/cpp17/optional.hpp
 third/cereal/unittests/cpp17/variant.cpp
 third/cereal/unittests/cpp17/variant.hpp
 third/pybind11/.appveyor.yml
 third/pybind11/.clang-format
 third/pybind11/.clang-tidy
 third/pybind11/.cmake-format.yaml
+third/pybind11/.codespell-ignore-lines
 third/pybind11/.git
+third/pybind11/.gitattributes
 third/pybind11/.gitignore
 third/pybind11/.pre-commit-config.yaml
 third/pybind11/.readthedocs.yml
 third/pybind11/CMakeLists.txt
 third/pybind11/LICENSE
 third/pybind11/MANIFEST.in
 third/pybind11/README.rst
+third/pybind11/SECURITY.md
 third/pybind11/noxfile.py
 third/pybind11/pyproject.toml
 third/pybind11/setup.cfg
 third/pybind11/setup.py
 third/pybind11/.github/CODEOWNERS
 third/pybind11/.github/CONTRIBUTING.md
 third/pybind11/.github/dependabot.yml
 third/pybind11/.github/labeler.yml
 third/pybind11/.github/labeler_merged.yml
 third/pybind11/.github/pull_request_template.md
 third/pybind11/.github/ISSUE_TEMPLATE/bug-report.yml
 third/pybind11/.github/ISSUE_TEMPLATE/config.yml
+third/pybind11/.github/matchers/pylint.json
 third/pybind11/.github/workflows/ci.yml
 third/pybind11/.github/workflows/configure.yml
 third/pybind11/.github/workflows/format.yml
 third/pybind11/.github/workflows/labeler.yml
 third/pybind11/.github/workflows/pip.yml
 third/pybind11/.github/workflows/upstream.yml
 third/pybind11/docs/Doxyfile
@@ -270,15 +274,15 @@
 third/pybind11/docs/pybind11_vs_boost_python1.svg
 third/pybind11/docs/pybind11_vs_boost_python2.png
 third/pybind11/docs/pybind11_vs_boost_python2.svg
 third/pybind11/docs/reference.rst
 third/pybind11/docs/release.rst
 third/pybind11/docs/requirements.txt
 third/pybind11/docs/upgrade.rst
-third/pybind11/docs/_static/theme_overrides.css
+third/pybind11/docs/_static/css/custom.css
 third/pybind11/docs/advanced/classes.rst
 third/pybind11/docs/advanced/embedding.rst
 third/pybind11/docs/advanced/exceptions.rst
 third/pybind11/docs/advanced/functions.rst
 third/pybind11/docs/advanced/misc.rst
 third/pybind11/docs/advanced/smart_ptrs.rst
 third/pybind11/docs/advanced/cast/chrono.rst
@@ -301,42 +305,48 @@
 third/pybind11/include/pybind11/common.h
 third/pybind11/include/pybind11/complex.h
 third/pybind11/include/pybind11/eigen.h
 third/pybind11/include/pybind11/embed.h
 third/pybind11/include/pybind11/eval.h
 third/pybind11/include/pybind11/functional.h
 third/pybind11/include/pybind11/gil.h
+third/pybind11/include/pybind11/gil_safe_call_once.h
 third/pybind11/include/pybind11/iostream.h
 third/pybind11/include/pybind11/numpy.h
 third/pybind11/include/pybind11/operators.h
 third/pybind11/include/pybind11/options.h
 third/pybind11/include/pybind11/pybind11.h
 third/pybind11/include/pybind11/pytypes.h
 third/pybind11/include/pybind11/stl.h
 third/pybind11/include/pybind11/stl_bind.h
+third/pybind11/include/pybind11/type_caster_pyobject_ptr.h
+third/pybind11/include/pybind11/typing.h
 third/pybind11/include/pybind11/detail/class.h
 third/pybind11/include/pybind11/detail/common.h
 third/pybind11/include/pybind11/detail/descr.h
 third/pybind11/include/pybind11/detail/init.h
 third/pybind11/include/pybind11/detail/internals.h
 third/pybind11/include/pybind11/detail/type_caster_base.h
 third/pybind11/include/pybind11/detail/typeid.h
+third/pybind11/include/pybind11/eigen/common.h
+third/pybind11/include/pybind11/eigen/matrix.h
+third/pybind11/include/pybind11/eigen/tensor.h
 third/pybind11/include/pybind11/stl/filesystem.h
 third/pybind11/pybind11/__init__.py
 third/pybind11/pybind11/__main__.py
 third/pybind11/pybind11/_version.py
-third/pybind11/pybind11/_version.pyi
 third/pybind11/pybind11/commands.py
 third/pybind11/pybind11/py.typed
 third/pybind11/pybind11/setup_helpers.py
-third/pybind11/pybind11/setup_helpers.pyi
 third/pybind11/tests/CMakeLists.txt
 third/pybind11/tests/conftest.py
 third/pybind11/tests/constructor_stats.h
 third/pybind11/tests/cross_module_gil_utils.cpp
+third/pybind11/tests/cross_module_interleaved_error_already_set.cpp
+third/pybind11/tests/eigen_tensor_avoid_stl_array.cpp
 third/pybind11/tests/env.py
 third/pybind11/tests/local_bindings.h
 third/pybind11/tests/object.h
 third/pybind11/tests/pybind11_cross_module_tests.cpp
 third/pybind11/tests/pybind11_tests.cpp
 third/pybind11/tests/pybind11_tests.h
 third/pybind11/tests/pytest.ini
@@ -363,16 +373,19 @@
 third/pybind11/tests/test_copy_move.py
 third/pybind11/tests/test_custom_type_casters.cpp
 third/pybind11/tests/test_custom_type_casters.py
 third/pybind11/tests/test_custom_type_setup.cpp
 third/pybind11/tests/test_custom_type_setup.py
 third/pybind11/tests/test_docstring_options.cpp
 third/pybind11/tests/test_docstring_options.py
-third/pybind11/tests/test_eigen.cpp
-third/pybind11/tests/test_eigen.py
+third/pybind11/tests/test_eigen_matrix.cpp
+third/pybind11/tests/test_eigen_matrix.py
+third/pybind11/tests/test_eigen_tensor.cpp
+third/pybind11/tests/test_eigen_tensor.inl
+third/pybind11/tests/test_eigen_tensor.py
 third/pybind11/tests/test_enum.cpp
 third/pybind11/tests/test_enum.py
 third/pybind11/tests/test_eval.cpp
 third/pybind11/tests/test_eval.py
 third/pybind11/tests/test_eval_call.py
 third/pybind11/tests/test_exceptions.cpp
 third/pybind11/tests/test_exceptions.h
@@ -401,30 +414,40 @@
 third/pybind11/tests/test_numpy_vectorize.py
 third/pybind11/tests/test_opaque_types.cpp
 third/pybind11/tests/test_opaque_types.py
 third/pybind11/tests/test_operator_overloading.cpp
 third/pybind11/tests/test_operator_overloading.py
 third/pybind11/tests/test_pickling.cpp
 third/pybind11/tests/test_pickling.py
+third/pybind11/tests/test_python_multiple_inheritance.cpp
+third/pybind11/tests/test_python_multiple_inheritance.py
 third/pybind11/tests/test_pytypes.cpp
 third/pybind11/tests/test_pytypes.py
 third/pybind11/tests/test_sequences_and_iterators.cpp
 third/pybind11/tests/test_sequences_and_iterators.py
 third/pybind11/tests/test_smart_ptr.cpp
 third/pybind11/tests/test_smart_ptr.py
 third/pybind11/tests/test_stl.cpp
 third/pybind11/tests/test_stl.py
 third/pybind11/tests/test_stl_binders.cpp
 third/pybind11/tests/test_stl_binders.py
 third/pybind11/tests/test_tagbased_polymorphic.cpp
 third/pybind11/tests/test_tagbased_polymorphic.py
 third/pybind11/tests/test_thread.cpp
 third/pybind11/tests/test_thread.py
+third/pybind11/tests/test_type_caster_pyobject_ptr.cpp
+third/pybind11/tests/test_type_caster_pyobject_ptr.py
 third/pybind11/tests/test_union.cpp
 third/pybind11/tests/test_union.py
+third/pybind11/tests/test_unnamed_namespace_a.cpp
+third/pybind11/tests/test_unnamed_namespace_a.py
+third/pybind11/tests/test_unnamed_namespace_b.cpp
+third/pybind11/tests/test_unnamed_namespace_b.py
+third/pybind11/tests/test_vector_unique_ptr_member.cpp
+third/pybind11/tests/test_vector_unique_ptr_member.py
 third/pybind11/tests/test_virtual_functions.cpp
 third/pybind11/tests/test_virtual_functions.py
 third/pybind11/tests/valgrind-numpy-scipy.supp
 third/pybind11/tests/valgrind-python.supp
 third/pybind11/tests/extra_python_package/pytest.ini
 third/pybind11/tests/extra_python_package/test_files.py
 third/pybind11/tests/extra_setuptools/pytest.ini
@@ -444,18 +467,21 @@
 third/pybind11/tests/test_embed/external_module.cpp
 third/pybind11/tests/test_embed/test_interpreter.cpp
 third/pybind11/tests/test_embed/test_interpreter.py
 third/pybind11/tests/test_embed/test_trampoline.py
 third/pybind11/tools/FindCatch.cmake
 third/pybind11/tools/FindEigen3.cmake
 third/pybind11/tools/FindPythonLibsNew.cmake
+third/pybind11/tools/JoinPaths.cmake
 third/pybind11/tools/check-style.sh
 third/pybind11/tools/cmake_uninstall.cmake.in
+third/pybind11/tools/codespell_ignore_lines_from_errors.py
 third/pybind11/tools/libsize.py
 third/pybind11/tools/make_changelog.py
+third/pybind11/tools/pybind11.pc.in
 third/pybind11/tools/pybind11Common.cmake
 third/pybind11/tools/pybind11Config.cmake.in
 third/pybind11/tools/pybind11NewTools.cmake
 third/pybind11/tools/pybind11Tools.cmake
 third/pybind11/tools/pyproject.toml
 third/pybind11/tools/setup_global.py.in
 third/pybind11/tools/setup_main.py.in
```

### Comparing `python_prtree-0.6.0/third/cereal/.gitignore` & `python_prtree-0.6.1/third/cereal/.gitignore`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/.travis.yml` & `python_prtree-0.6.1/third/cereal/.travis.yml`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/CMakeLists.txt` & `python_prtree-0.6.1/third/cereal/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/LICENSE` & `python_prtree-0.6.1/third/cereal/LICENSE`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/README.md` & `python_prtree-0.6.1/third/cereal/README.md`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/appveyor.yml` & `python_prtree-0.6.1/third/cereal/appveyor.yml`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/doc/CMakeLists.txt` & `python_prtree-0.6.1/third/cereal/doc/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/doc/DoxygenLayout.xml` & `python_prtree-0.6.1/third/cereal/doc/DoxygenLayout.xml`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/doc/doxygen.in` & `python_prtree-0.6.1/third/cereal/doc/doxygen.in`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/doc/footer.html` & `python_prtree-0.6.1/third/cereal/doc/footer.html`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/doc/mainpage.dox` & `python_prtree-0.6.1/third/cereal/doc/mainpage.dox`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/access.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/access.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/archives/adapters.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/archives/adapters.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/archives/binary.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/archives/binary.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/archives/json.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/archives/json.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/archives/portable_binary.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/archives/portable_binary.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/archives/xml.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/archives/xml.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/cereal.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/cereal.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/details/helpers.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/details/helpers.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/details/polymorphic_impl.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/details/polymorphic_impl.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/details/polymorphic_impl_fwd.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/details/polymorphic_impl_fwd.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/details/static_object.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/details/static_object.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/details/traits.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/details/traits.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/details/util.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/details/util.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/LICENSE` & `python_prtree-0.6.1/third/cereal/include/cereal/external/LICENSE`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/base64.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/external/base64.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/LICENSE` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/LICENSE`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/allocators.h` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/allocators.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/cursorstreamwrapper.h` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/cursorstreamwrapper.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/document.h` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/document.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/encodedstream.h` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/encodedstream.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/encodings.h` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/encodings.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/error/en.h` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/error/en.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/error/error.h` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/error/error.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/filereadstream.h` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/filereadstream.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/filewritestream.h` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/filewritestream.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/fwd.h` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/fwd.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/internal/biginteger.h` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/internal/biginteger.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/internal/diyfp.h` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/internal/diyfp.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/internal/dtoa.h` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/internal/dtoa.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/internal/ieee754.h` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/internal/ieee754.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/internal/itoa.h` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/internal/itoa.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/internal/meta.h` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/internal/meta.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/internal/pow10.h` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/internal/pow10.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/internal/regex.h` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/internal/regex.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/internal/stack.h` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/internal/stack.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/internal/strfunc.h` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/internal/strfunc.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/internal/strtod.h` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/internal/strtod.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/internal/swap.h` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/internal/swap.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/istreamwrapper.h` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/istreamwrapper.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/memorybuffer.h` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/memorybuffer.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/memorystream.h` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/memorystream.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/msinttypes/LICENSE` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/msinttypes/LICENSE`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/msinttypes/inttypes.h` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/msinttypes/inttypes.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/msinttypes/stdint.h` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/msinttypes/stdint.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/ostreamwrapper.h` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/ostreamwrapper.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/pointer.h` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/pointer.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/prettywriter.h` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/prettywriter.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/rapidjson.h` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/rapidjson.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/reader.h` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/reader.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/schema.h` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/schema.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/stream.h` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/stream.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/stringbuffer.h` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/stringbuffer.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidjson/writer.h` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidjson/writer.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidxml/license.txt` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidxml/license.txt`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidxml/manual.html` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidxml/manual.html`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidxml/rapidxml.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidxml/rapidxml.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidxml/rapidxml_iterators.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidxml/rapidxml_iterators.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidxml/rapidxml_print.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidxml/rapidxml_print.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/external/rapidxml/rapidxml_utils.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/external/rapidxml/rapidxml_utils.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/macros.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/macros.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/specialize.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/specialize.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/types/array.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/types/array.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/types/atomic.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/types/atomic.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/types/base_class.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/types/base_class.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/types/bitset.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/types/bitset.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/types/boost_variant.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/types/boost_variant.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/types/chrono.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/types/chrono.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/types/common.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/types/common.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/types/complex.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/types/complex.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/types/concepts/pair_associative_container.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/types/concepts/pair_associative_container.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/types/deque.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/types/deque.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/types/forward_list.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/types/forward_list.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/types/functional.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/types/functional.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/types/list.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/types/list.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/types/map.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/types/map.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/types/memory.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/types/memory.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/types/optional.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/types/optional.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/types/polymorphic.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/types/polymorphic.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/types/queue.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/types/queue.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/types/set.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/types/set.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/types/stack.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/types/stack.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/types/string.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/types/string.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/types/tuple.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/types/tuple.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/types/unordered_map.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/types/unordered_map.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/types/unordered_set.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/types/unordered_set.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/types/utility.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/types/utility.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/types/valarray.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/types/valarray.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/types/variant.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/types/variant.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/types/vector.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/types/vector.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/include/cereal/version.hpp` & `python_prtree-0.6.1/third/cereal/include/cereal/version.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/sandbox/CMakeLists.txt` & `python_prtree-0.6.1/third/cereal/sandbox/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/sandbox/performance.cpp` & `python_prtree-0.6.1/third/cereal/sandbox/performance.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/sandbox/sandbox.cpp` & `python_prtree-0.6.1/third/cereal/sandbox/sandbox.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/sandbox/sandbox_json.cpp` & `python_prtree-0.6.1/third/cereal/sandbox/sandbox_json.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/sandbox/sandbox_rtti.cpp` & `python_prtree-0.6.1/third/cereal/sandbox/sandbox_rtti.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/sandbox/sandbox_shared_lib/base.hpp` & `python_prtree-0.6.1/third/cereal/sandbox/sandbox_shared_lib/base.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/sandbox/sandbox_shared_lib/derived.hpp` & `python_prtree-0.6.1/third/cereal/sandbox/sandbox_shared_lib/derived.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/sandbox/sandbox_vs.cpp` & `python_prtree-0.6.1/third/cereal/sandbox/sandbox_vs.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/scripts/appveyor.bat` & `python_prtree-0.6.1/third/cereal/scripts/appveyor.bat`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/scripts/updatecoverage.sh` & `python_prtree-0.6.1/third/cereal/scripts/updatecoverage.sh`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/scripts/updatedoc.in` & `python_prtree-0.6.1/third/cereal/scripts/updatedoc.in`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/CMakeLists.txt` & `python_prtree-0.6.1/third/cereal/unittests/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/array.cpp` & `python_prtree-0.6.1/third/cereal/unittests/array.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/array.hpp` & `python_prtree-0.6.1/third/cereal/unittests/array.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/atomic.cpp` & `python_prtree-0.6.1/third/cereal/unittests/atomic.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/atomic.hpp` & `python_prtree-0.6.1/third/cereal/unittests/atomic.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/basic_string.cpp` & `python_prtree-0.6.1/third/cereal/unittests/basic_string.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/basic_string.hpp` & `python_prtree-0.6.1/third/cereal/unittests/basic_string.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/bitset.cpp` & `python_prtree-0.6.1/third/cereal/unittests/bitset.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/bitset.hpp` & `python_prtree-0.6.1/third/cereal/unittests/bitset.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/boost/CMakeLists.txt` & `python_prtree-0.6.1/third/cereal/unittests/boost/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/boost/boost_variant.cpp` & `python_prtree-0.6.1/third/cereal/unittests/boost/boost_variant.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/boost/boost_variant.hpp` & `python_prtree-0.6.1/third/cereal/unittests/boost/boost_variant.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/chrono.cpp` & `python_prtree-0.6.1/third/cereal/unittests/chrono.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/chrono.hpp` & `python_prtree-0.6.1/third/cereal/unittests/chrono.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/cmake-config-module.cmake` & `python_prtree-0.6.1/third/cereal/unittests/cmake-config-module.cmake`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/common.hpp` & `python_prtree-0.6.1/third/cereal/unittests/common.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/complex.cpp` & `python_prtree-0.6.1/third/cereal/unittests/complex.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/complex.hpp` & `python_prtree-0.6.1/third/cereal/unittests/complex.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/cpp17/CMakeLists.txt` & `python_prtree-0.6.1/third/cereal/unittests/cpp17/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/cpp17/optional.cpp` & `python_prtree-0.6.1/third/cereal/unittests/cpp17/optional.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/cpp17/optional.hpp` & `python_prtree-0.6.1/third/cereal/unittests/cpp17/optional.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/cpp17/variant.cpp` & `python_prtree-0.6.1/third/cereal/unittests/cpp17/variant.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/cpp17/variant.hpp` & `python_prtree-0.6.1/third/cereal/unittests/cpp17/variant.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/defer.cpp` & `python_prtree-0.6.1/third/cereal/unittests/defer.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/defer.hpp` & `python_prtree-0.6.1/third/cereal/unittests/defer.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/deque.cpp` & `python_prtree-0.6.1/third/cereal/unittests/deque.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/deque.hpp` & `python_prtree-0.6.1/third/cereal/unittests/deque.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/doctest.h` & `python_prtree-0.6.1/third/cereal/unittests/doctest.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/forward_list.cpp` & `python_prtree-0.6.1/third/cereal/unittests/forward_list.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/forward_list.hpp` & `python_prtree-0.6.1/third/cereal/unittests/forward_list.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/list.cpp` & `python_prtree-0.6.1/third/cereal/unittests/list.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/list.hpp` & `python_prtree-0.6.1/third/cereal/unittests/list.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/load_construct.cpp` & `python_prtree-0.6.1/third/cereal/unittests/load_construct.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/load_construct.hpp` & `python_prtree-0.6.1/third/cereal/unittests/load_construct.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/map.cpp` & `python_prtree-0.6.1/third/cereal/unittests/map.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/map.hpp` & `python_prtree-0.6.1/third/cereal/unittests/map.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/memory.cpp` & `python_prtree-0.6.1/third/cereal/unittests/memory.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/memory.hpp` & `python_prtree-0.6.1/third/cereal/unittests/memory.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/memory_cycles.cpp` & `python_prtree-0.6.1/third/cereal/unittests/memory_cycles.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/memory_cycles.hpp` & `python_prtree-0.6.1/third/cereal/unittests/memory_cycles.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/multimap.cpp` & `python_prtree-0.6.1/third/cereal/unittests/multimap.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/multimap.hpp` & `python_prtree-0.6.1/third/cereal/unittests/multimap.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/multiset.cpp` & `python_prtree-0.6.1/third/cereal/unittests/multiset.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/multiset.hpp` & `python_prtree-0.6.1/third/cereal/unittests/multiset.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/pair.cpp` & `python_prtree-0.6.1/third/cereal/unittests/pair.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/pair.hpp` & `python_prtree-0.6.1/third/cereal/unittests/pair.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/pod.cpp` & `python_prtree-0.6.1/third/cereal/unittests/pod.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/pod.hpp` & `python_prtree-0.6.1/third/cereal/unittests/pod.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/polymorphic.cpp` & `python_prtree-0.6.1/third/cereal/unittests/polymorphic.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/polymorphic.hpp` & `python_prtree-0.6.1/third/cereal/unittests/polymorphic.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/portability_test.cpp` & `python_prtree-0.6.1/third/cereal/unittests/portability_test.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/portable_binary_archive.cpp` & `python_prtree-0.6.1/third/cereal/unittests/portable_binary_archive.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/portable_binary_archive.hpp` & `python_prtree-0.6.1/third/cereal/unittests/portable_binary_archive.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/priority_queue.cpp` & `python_prtree-0.6.1/third/cereal/unittests/priority_queue.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/priority_queue.hpp` & `python_prtree-0.6.1/third/cereal/unittests/priority_queue.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/queue.cpp` & `python_prtree-0.6.1/third/cereal/unittests/queue.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/queue.hpp` & `python_prtree-0.6.1/third/cereal/unittests/queue.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/run_portability_test.cmake` & `python_prtree-0.6.1/third/cereal/unittests/run_portability_test.cmake`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/set.cpp` & `python_prtree-0.6.1/third/cereal/unittests/set.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/set.hpp` & `python_prtree-0.6.1/third/cereal/unittests/set.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/stack.cpp` & `python_prtree-0.6.1/third/cereal/unittests/stack.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/stack.hpp` & `python_prtree-0.6.1/third/cereal/unittests/stack.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/structs.cpp` & `python_prtree-0.6.1/third/cereal/unittests/structs.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/structs.hpp` & `python_prtree-0.6.1/third/cereal/unittests/structs.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/structs_minimal.cpp` & `python_prtree-0.6.1/third/cereal/unittests/structs_minimal.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/structs_minimal.hpp` & `python_prtree-0.6.1/third/cereal/unittests/structs_minimal.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/structs_specialized.cpp` & `python_prtree-0.6.1/third/cereal/unittests/structs_specialized.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/structs_specialized.hpp` & `python_prtree-0.6.1/third/cereal/unittests/structs_specialized.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/tuple.cpp` & `python_prtree-0.6.1/third/cereal/unittests/tuple.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/tuple.hpp` & `python_prtree-0.6.1/third/cereal/unittests/tuple.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/unordered_loads.cpp` & `python_prtree-0.6.1/third/cereal/unittests/unordered_loads.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/unordered_loads.hpp` & `python_prtree-0.6.1/third/cereal/unittests/unordered_loads.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/unordered_map.cpp` & `python_prtree-0.6.1/third/cereal/unittests/unordered_map.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/unordered_map.hpp` & `python_prtree-0.6.1/third/cereal/unittests/unordered_map.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/unordered_multimap.cpp` & `python_prtree-0.6.1/third/cereal/unittests/unordered_multimap.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/unordered_multimap.hpp` & `python_prtree-0.6.1/third/cereal/unittests/unordered_multimap.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/unordered_multiset.cpp` & `python_prtree-0.6.1/third/cereal/unittests/unordered_multiset.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/unordered_multiset.hpp` & `python_prtree-0.6.1/third/cereal/unittests/unordered_multiset.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/unordered_set.cpp` & `python_prtree-0.6.1/third/cereal/unittests/unordered_set.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/unordered_set.hpp` & `python_prtree-0.6.1/third/cereal/unittests/unordered_set.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/user_data_adapters.cpp` & `python_prtree-0.6.1/third/cereal/unittests/user_data_adapters.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/user_data_adapters.hpp` & `python_prtree-0.6.1/third/cereal/unittests/user_data_adapters.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/valarray.cpp` & `python_prtree-0.6.1/third/cereal/unittests/valarray.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/valarray.hpp` & `python_prtree-0.6.1/third/cereal/unittests/valarray.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/vector.cpp` & `python_prtree-0.6.1/third/cereal/unittests/vector.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/vector.hpp` & `python_prtree-0.6.1/third/cereal/unittests/vector.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/versioning.cpp` & `python_prtree-0.6.1/third/cereal/unittests/versioning.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/cereal/unittests/versioning.hpp` & `python_prtree-0.6.1/third/cereal/unittests/versioning.hpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/.appveyor.yml` & `python_prtree-0.6.1/third/pybind11/.appveyor.yml`

 * *Files 4% similar despite different names*

```diff
@@ -1,25 +1,23 @@
 version: 1.0.{build}
 image:
-- Visual Studio 2015
+- Visual Studio 2017
 test: off
 skip_branch_with_pr: true
 build:
   parallel: true
 platform:
 - x86
 environment:
   matrix:
   - PYTHON: 36
     CONFIG: Debug
-  - PYTHON: 27
-    CONFIG: Debug
 install:
 - ps: |
-    $env:CMAKE_GENERATOR = "Visual Studio 14 2015"
+    $env:CMAKE_GENERATOR = "Visual Studio 15 2017"
     if ($env:PLATFORM -eq "x64") { $env:PYTHON = "$env:PYTHON-x64" }
     $env:PATH = "C:\Python$env:PYTHON\;C:\Python$env:PYTHON\Scripts\;$env:PATH"
     python -W ignore -m pip install --upgrade pip wheel
     python -W ignore -m pip install pytest numpy --no-warn-script-location pytest-timeout
 - ps: |
     Start-FileDownload 'https://gitlab.com/libeigen/eigen/-/archive/3.3.7/eigen-3.3.7.zip'
     7z x eigen-3.3.7.zip -y > $null
```

### Comparing `python_prtree-0.6.0/third/pybind11/.clang-format` & `python_prtree-0.6.1/third/pybind11/.clang-format`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/.clang-tidy` & `python_prtree-0.6.1/third/pybind11/.clang-tidy`

 * *Files 23% similar despite different names*

```diff
@@ -1,72 +1,77 @@
 FormatStyle: file
 
-Checks: '
-*bugprone*,
-clang-analyzer-optin.performance.Padding,
-clang-analyzer-optin.cplusplus.VirtualCall,
-cppcoreguidelines-init-variables,
-cppcoreguidelines-prefer-member-initializer,
-cppcoreguidelines-pro-type-static-cast-downcast,
-cppcoreguidelines-slicing,
-google-explicit-constructor,
-llvm-namespace-comment,
-misc-misplaced-const,
-misc-non-copyable-objects,
-misc-static-assert,
-misc-throw-by-value-catch-by-reference,
-misc-uniqueptr-reset-release,
-misc-unused-parameters,
-modernize-avoid-bind,
-modernize-make-shared,
-modernize-redundant-void-arg,
-modernize-replace-auto-ptr,
-modernize-replace-disallow-copy-and-assign-macro,
-modernize-replace-random-shuffle,
-modernize-shrink-to-fit,
-modernize-use-auto,
-modernize-use-bool-literals,
-modernize-use-equals-default,
-modernize-use-equals-delete,
-modernize-use-default-member-init,
-modernize-use-noexcept,
-modernize-use-emplace,
-modernize-use-override,
-modernize-use-using,
-*performance*,
-readability-avoid-const-params-in-decls,
-readability-braces-around-statements,
-readability-const-return-type,
-readability-container-size-empty,
-readability-delete-null-pointer,
-readability-else-after-return,
-readability-implicit-bool-conversion,
-readability-inconsistent-declaration-parameter-name,
-readability-make-member-function-const,
-readability-misplaced-array-index,
-readability-non-const-parameter,
-readability-qualified-auto,
-readability-redundant-function-ptr-dereference,
-readability-redundant-smartptr-get,
-readability-redundant-string-cstr,
-readability-simplify-subscript-expr,
-readability-static-accessed-through-instance,
-readability-static-definition-in-anonymous-namespace,
-readability-string-compare,
-readability-suspicious-call-argument,
-readability-uniqueptr-delete-release,
--bugprone-exception-escape,
--bugprone-reserved-identifier,
--bugprone-unused-raii,
-'
+Checks: |
+  *bugprone*,
+  *performance*,
+  clang-analyzer-optin.cplusplus.VirtualCall,
+  clang-analyzer-optin.performance.Padding,
+  cppcoreguidelines-init-variables,
+  cppcoreguidelines-prefer-member-initializer,
+  cppcoreguidelines-pro-type-static-cast-downcast,
+  cppcoreguidelines-slicing,
+  google-explicit-constructor,
+  llvm-namespace-comment,
+  misc-definitions-in-headers,
+  misc-misplaced-const,
+  misc-non-copyable-objects,
+  misc-static-assert,
+  misc-throw-by-value-catch-by-reference,
+  misc-uniqueptr-reset-release,
+  misc-unused-parameters,
+  modernize-avoid-bind,
+  modernize-loop-convert,
+  modernize-make-shared,
+  modernize-redundant-void-arg,
+  modernize-replace-auto-ptr,
+  modernize-replace-disallow-copy-and-assign-macro,
+  modernize-replace-random-shuffle,
+  modernize-shrink-to-fit,
+  modernize-use-auto,
+  modernize-use-bool-literals,
+  modernize-use-default-member-init,
+  modernize-use-emplace,
+  modernize-use-equals-default,
+  modernize-use-equals-delete,
+  modernize-use-noexcept,
+  modernize-use-nullptr,
+  modernize-use-override,
+  modernize-use-using,
+  readability-avoid-const-params-in-decls,
+  readability-braces-around-statements,
+  readability-const-return-type,
+  readability-container-size-empty,
+  readability-delete-null-pointer,
+  readability-else-after-return,
+  readability-implicit-bool-conversion,
+  readability-inconsistent-declaration-parameter-name,
+  readability-make-member-function-const,
+  readability-misplaced-array-index,
+  readability-non-const-parameter,
+  readability-qualified-auto,
+  readability-redundant-function-ptr-dereference,
+  readability-redundant-smartptr-get,
+  readability-redundant-string-cstr,
+  readability-simplify-subscript-expr,
+  readability-static-accessed-through-instance,
+  readability-static-definition-in-anonymous-namespace,
+  readability-string-compare,
+  readability-suspicious-call-argument,
+  readability-uniqueptr-delete-release,
+  -bugprone-easily-swappable-parameters,
+  -bugprone-exception-escape,
+  -bugprone-reserved-identifier,
+  -bugprone-unused-raii,
 
 CheckOptions:
+- key:             modernize-use-equals-default.IgnoreMacros
+  value:           false
 - key:             performance-for-range-copy.WarnOnAllAutoCopies
   value:           true
+- key:             performance-inefficient-string-concatenation.StrictMode
+  value:           true
 - key:             performance-unnecessary-value-param.AllowedTypes
   value:           'exception_ptr$;'
 - key:             readability-implicit-bool-conversion.AllowPointerConditions
   value:           true
 
 HeaderFilterRegex: 'pybind11/.*h'
-
-WarningsAsErrors: '*'
```

### Comparing `python_prtree-0.6.0/third/pybind11/.cmake-format.yaml` & `python_prtree-0.6.1/third/pybind11/.cmake-format.yaml`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/.github/CONTRIBUTING.md` & `python_prtree-0.6.1/third/pybind11/.github/CONTRIBUTING.md`

 * *Files 2% similar despite different names*

```diff
@@ -89,37 +89,36 @@
 pip install -r tests/requirements.txt
 cmake -S . -B build -DDOWNLOAD_CATCH=ON -DDOWNLOAD_EIGEN=ON
 cmake --build build -j4
 ```
 
 Tips:
 
-* You can use `virtualenv` (from PyPI) instead of `venv` (which is Python 3
-  only).
+* You can use `virtualenv` (faster, from PyPI) instead of `venv`.
 * You can select any name for your environment folder; if it contains "env" it
   will be ignored by git.
-* If you dont have CMake 3.14+, just add cmake to the pip install command.
+* If you don't have CMake 3.14+, just add "cmake" to the pip install command.
 * You can use `-DPYBIND11_FINDPYTHON=ON` to use FindPython on CMake 3.12+
 * In classic mode, you may need to set `-DPYTHON_EXECUTABLE=/path/to/python`.
   FindPython uses `-DPython_ROOT_DIR=/path/to` or
   `-DPython_EXECUTABLE=/path/to/python`.
 
 ### Configuration options
 
-In CMake, configuration options are given with -D. Options are stored in the
+In CMake, configuration options are given with "-D". Options are stored in the
 build directory, in the `CMakeCache.txt` file, so they are remembered for each
 build directory. Two selections are special - the generator, given with `-G`,
 and the compiler, which is selected based on environment variables `CXX` and
 similar, or `-DCMAKE_CXX_COMPILER=`. Unlike the others, these cannot be changed
 after the initial run.
 
 The valid options are:
 
 * `-DCMAKE_BUILD_TYPE`: Release, Debug, MinSizeRel, RelWithDebInfo
-* `-DPYBIND11_FINDPYTHON=ON`: Use CMake 3.12+s FindPython instead of the
+* `-DPYBIND11_FINDPYTHON=ON`: Use CMake 3.12+'s FindPython instead of the
   classic, deprecated, custom FindPythonLibs
 * `-DPYBIND11_NOPYTHON=ON`: Disable all Python searching (disables tests)
 * `-DBUILD_TESTING=ON`: Enable the tests
 * `-DDOWNLOAD_CATCH=ON`: Download catch to build the C++ tests
 * `-DDOWNLOAD_EIGEN=ON`: Download Eigen for the NumPy tests
 * `-DPYBIND11_INSTALL=ON/OFF`: Enable the install target (on by default for the
   master project)
@@ -132,15 +131,15 @@
 * Use `cmake build -LH` to list the CMake options with help.
 * Use `ccmake` if available to see a curses (terminal) gui, or `cmake-gui` for
   a completely graphical interface (not present in the PyPI package).
 * Use `cmake --build build -j12` to build with 12 cores (for example).
 * Use `-G` and the name of a generator to use something different. `cmake
   --help` lists the generators available.
       - On Unix, setting `CMAKE_GENERATER=Ninja` in your environment will give
-        you automatic mulithreading on all your CMake projects!
+        you automatic multithreading on all your CMake projects!
 * Open the `CMakeLists.txt` with QtCreator to generate for that IDE.
 * You can use `-DCMAKE_EXPORT_COMPILE_COMMANDS=ON` to generate the `.json` file
   that some tools expect.
 
 </p></details>
 
 
@@ -232,20 +231,22 @@
 more complex to run, compared to `clang-format`, but support for `clang-tidy`
 is built into the pybind11 CMake configuration. To run `clang-tidy`, the
 following recipe should work. Run the `docker` command from the top-level
 directory inside your pybind11 git clone. Files will be modified in place,
 so you can use git to monitor the changes.
 
 ```bash
-docker run --rm -v $PWD:/mounted_pybind11 -it silkeh/clang:12
-apt-get update && apt-get install -y python3-dev python3-pytest
-cmake -S /mounted_pybind11/ -B build -DCMAKE_CXX_CLANG_TIDY="$(which clang-tidy);-fix" -DDOWNLOAD_EIGEN=ON -DDOWNLOAD_CATCH=ON -DCMAKE_CXX_STANDARD=17
-cmake --build build -j 2 -- --keep-going
+docker run --rm -v $PWD:/mounted_pybind11 -it silkeh/clang:15-bullseye
+apt-get update && apt-get install -y git python3-dev python3-pytest
+cmake -S /mounted_pybind11/ -B build -DCMAKE_CXX_CLANG_TIDY="$(which clang-tidy);--use-color" -DDOWNLOAD_EIGEN=ON -DDOWNLOAD_CATCH=ON -DCMAKE_CXX_STANDARD=17
+cmake --build build -j 2
 ```
 
+You can add `--fix` to the options list if you want.
+
 ### Include what you use
 
 To run include what you use, install (`brew install include-what-you-use` on
 macOS), then run:
 
 ```bash
 cmake -S . -B build-iwyu -DCMAKE_CXX_INCLUDE_WHAT_YOU_USE=$(which include-what-you-use)
@@ -253,15 +254,15 @@
 ```
 
 The report is sent to stderr; you can pipe it into a file if you wish.
 
 ### Build recipes
 
 This builds with the Intel compiler (assuming it is in your path, along with a
-recent CMake and Python 3):
+recent CMake and Python):
 
 ```bash
 python3 -m venv venv
 . venv/bin/activate
 pip install pytest
 cmake -S . -B build-intel -DCMAKE_CXX_COMPILER=$(which icpc) -DDOWNLOAD_CATCH=ON -DDOWNLOAD_EIGEN=ON -DPYBIND11_WERROR=ON
 ```
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `python_prtree-0.6.0/third/pybind11/.github/ISSUE_TEMPLATE/bug-report.yml` & `python_prtree-0.6.1/third/pybind11/.github/ISSUE_TEMPLATE/bug-report.yml`

 * *Files 10% similar despite different names*

```diff
@@ -2,28 +2,36 @@
 description: File an issue about a bug
 title: "[BUG]: "
 labels: [triage]
 body:
   - type: markdown
     attributes:
       value: |
-        Maintainers will only make a best effort to triage PRs. Please do your best to make the issue as easy to act on as possible, and only open if clearly a problem with pybind11 (ask first if unsure).
+        Please do your best to make the issue as easy to act on as possible, and only submit here if there is clearly a problem with pybind11 (ask first if unsure). **Note that a reproducer in a PR is much more likely to get immediate attention.**
+
   - type: checkboxes
     id: steps
     attributes:
       label: Required prerequisites
       description: Make sure you've completed the following steps before submitting your issue -- thank you!
       options:
         - label: Make sure you've read the [documentation](https://pybind11.readthedocs.io). Your issue may be addressed there.
           required: true
         - label: Search the [issue tracker](https://github.com/pybind/pybind11/issues) and [Discussions](https:/pybind/pybind11/discussions) to verify that this hasn't already been reported. +1 or comment there if it has.
           required: true
         - label: Consider asking first in the [Gitter chat room](https://gitter.im/pybind/Lobby) or in a [Discussion](https:/pybind/pybind11/discussions/new).
           required: false
 
+  - type: input
+    id: version
+    attributes:
+      label: What version (or hash if on master) of pybind11 are you using?
+    validations:
+      required: true
+
   - type: textarea
     id: description
     attributes:
       label: Problem description
       placeholder: >-
         Provide a short description, state the expected behavior and what
         actually happens. Include relevant information like what version of
@@ -36,10 +44,18 @@
     id: code
     attributes:
       label: Reproducible example code
       placeholder: >-
         The code should be minimal, have no external dependencies, isolate the
         function(s) that cause breakage. Submit matched and complete C++ and
         Python snippets that can be easily compiled and run to diagnose the
-        issue. If possible, make a PR with a new, failing test to give us a
-        starting point to work on!
+        issue.  Note that a reproducer in a PR is much more likely to get
+        immediate attention: failing tests in the pybind11 CI are the best
+        starting point for working out fixes.
       render: text
+
+  - type: input
+    id: regression
+    attributes:
+      label: Is this a regression? Put the last known working version here if it is.
+      description: Put the last known working version here if this is a regression.
+      value: Not a regression
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `python_prtree-0.6.0/third/pybind11/.github/pull_request_template.md` & `python_prtree-0.6.1/third/pybind11/.github/pull_request_template.md`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/.github/workflows/ci.yml` & `python_prtree-0.6.1/third/pybind11/.github/workflows/ci.yml`

 * *Files 20% similar despite different names*

```diff
@@ -5,88 +5,96 @@
   pull_request:
   push:
     branches:
       - master
       - stable
       - v*
 
+permissions: read-all
+
 concurrency:
   group: test-${{ github.ref }}
   cancel-in-progress: true
 
 env:
+  PIP_BREAK_SYSTEM_PACKAGES: 1
   PIP_ONLY_BINARY: numpy
+  FORCE_COLOR: 3
+  PYTEST_TIMEOUT: 300
+  # For cmake:
+  VERBOSE: 1
 
 jobs:
   # This is the "main" test suite, which tests a large number of different
   # versions of default compilers and Python versions in GitHub Actions.
   standard:
     strategy:
       fail-fast: false
       matrix:
-        runs-on: [ubuntu-latest, windows-2022, macos-latest]
+        runs-on: [ubuntu-20.04, windows-2022, macos-latest]
         python:
-        - '2.7'
-        - '3.5'
         - '3.6'
         - '3.9'
         - '3.10'
-        - 'pypy-3.7'
+        - '3.11'
+        - '3.12'
         - 'pypy-3.8'
+        - 'pypy-3.9'
+        - 'pypy-3.10'
 
         # Items in here will either be added to the build matrix (if not
         # present), or add new keys to an existing matrix element if all the
         # existing keys match.
         #
         # We support an optional key: args, for cmake args
         include:
           # Just add a key
-          - runs-on: ubuntu-latest
+          - runs-on: ubuntu-20.04
             python: '3.6'
             args: >
               -DPYBIND11_FINDPYTHON=ON
               -DCMAKE_CXX_FLAGS="-D_=1"
-          - runs-on: windows-latest
+          - runs-on: ubuntu-20.04
+            python: 'pypy-3.8'
+            args: >
+              -DPYBIND11_FINDPYTHON=ON
+          - runs-on: windows-2019
             python: '3.6'
             args: >
               -DPYBIND11_FINDPYTHON=ON
-          - runs-on: macos-latest
-            python: 'pypy-2.7'
           # Inject a couple Windows 2019 runs
           - runs-on: windows-2019
             python: '3.9'
-          - runs-on: windows-2019
-            python: '2.7'
 
     name: " ${{ matrix.python }}  ${{ matrix.runs-on }}  x64 ${{ matrix.args }}"
     runs-on: ${{ matrix.runs-on }}
 
     steps:
-    - uses: actions/checkout@v2
+    - uses: actions/checkout@v4
 
     - name: Setup Python ${{ matrix.python }}
-      uses: actions/setup-python@v2
+      uses: actions/setup-python@v5
       with:
         python-version: ${{ matrix.python }}
 
     - name: Setup Boost (Linux)
       # Can't use boost + define _
       if: runner.os == 'Linux' && matrix.python != '3.6'
       run: sudo apt-get install libboost-dev
 
     - name: Setup Boost (macOS)
       if: runner.os == 'macOS'
       run: brew install boost
 
     - name: Update CMake
-      uses: jwlawson/actions-setup-cmake@v1.12
+      uses: jwlawson/actions-setup-cmake@v2.0
 
     - name: Cache wheels
       if: runner.os == 'macOS'
-      uses: actions/cache@v2
+      uses: actions/cache@v4
       with:
         # This path is specific to macOS - we really only need it for PyPy NumPy wheels
         # See https://github.com/actions/cache/blob/master/examples.md#python---pip
         # for ways to do this more generally
         path: ~/Library/Caches/pip
         # Look to see if there is a cache hit for the corresponding requirements file
         key: ${{ runner.os }}-pip-${{ matrix.python }}-x64-${{ hashFiles('tests/requirements.txt') }}
@@ -96,135 +104,130 @@
         python -m pip install -r tests/requirements.txt
 
     - name: Setup annotations on Linux
       if: runner.os == 'Linux'
       run: python -m pip install pytest-github-actions-annotate-failures
 
     # First build - C++11 mode and inplace
+    # More-or-less randomly adding -DPYBIND11_SIMPLE_GIL_MANAGEMENT=ON here
+    # (same for PYBIND11_NUMPY_1_ONLY, but requires a NumPy 1.x at runtime).
     - name: Configure C++11 ${{ matrix.args }}
       run: >
         cmake -S . -B .
         -DPYBIND11_WERROR=ON
+        -DPYBIND11_DISABLE_HANDLE_TYPE_NAME_DEFAULT_IMPLEMENTATION=ON
+        -DPYBIND11_SIMPLE_GIL_MANAGEMENT=ON
+        -DPYBIND11_NUMPY_1_ONLY=ON
         -DDOWNLOAD_CATCH=ON
         -DDOWNLOAD_EIGEN=ON
         -DCMAKE_CXX_STANDARD=11
         ${{ matrix.args }}
 
     - name: Build C++11
       run: cmake --build . -j 2
 
     - name: Python tests C++11
       run: cmake --build . --target pytest -j 2
 
     - name: C++11 tests
       # TODO: Figure out how to load the DLL on Python 3.8+
-      if: "!(runner.os == 'Windows' && (matrix.python == 3.8 || matrix.python == 3.9 || matrix.python == '3.10' || matrix.python == '3.11-dev' || matrix.python == 'pypy-3.8'))"
+      if: "!(runner.os == 'Windows' && (matrix.python == 3.8 || matrix.python == 3.9 || matrix.python == '3.10' || matrix.python == '3.11' || matrix.python == 'pypy-3.8'))"
       run: cmake --build .  --target cpptest -j 2
 
     - name: Interface test C++11
       run: cmake --build . --target test_cmake_build
 
     - name: Clean directory
       run: git clean -fdx
 
     # Second build - C++17 mode and in a build directory
+    # More-or-less randomly adding -DPYBIND11_SIMPLE_GIL_MANAGEMENT=OFF here.
+    # (same for PYBIND11_NUMPY_1_ONLY, but requires a NumPy 1.x at runtime).
     - name: Configure C++17
       run: >
         cmake -S . -B build2
         -DPYBIND11_WERROR=ON
+        -DPYBIND11_SIMPLE_GIL_MANAGEMENT=OFF
+        -DPYBIND11_NUMPY_1_ONLY=ON
         -DDOWNLOAD_CATCH=ON
         -DDOWNLOAD_EIGEN=ON
         -DCMAKE_CXX_STANDARD=17
         ${{ matrix.args }}
 
     - name: Build
       run: cmake --build build2 -j 2
 
     - name: Python tests
       run: cmake --build build2 --target pytest
 
     - name: C++ tests
       # TODO: Figure out how to load the DLL on Python 3.8+
-      if: "!(runner.os == 'Windows' && (matrix.python == 3.8 || matrix.python == 3.9 || matrix.python == '3.10' || matrix.python == '3.11-dev' || matrix.python == 'pypy-3.8'))"
+      if: "!(runner.os == 'Windows' && (matrix.python == 3.8 || matrix.python == 3.9 || matrix.python == '3.10' || matrix.python == '3.11' || matrix.python == 'pypy-3.8'))"
       run: cmake --build build2 --target cpptest
 
     # Third build - C++17 mode with unstable ABI
     - name: Configure (unstable ABI)
       run: >
         cmake -S . -B build3
         -DPYBIND11_WERROR=ON
         -DDOWNLOAD_CATCH=ON
         -DDOWNLOAD_EIGEN=ON
         -DCMAKE_CXX_STANDARD=17
         -DPYBIND11_INTERNALS_VERSION=10000000
-        "-DPYBIND11_TEST_OVERRIDE=test_call_policies.cpp;test_gil_scoped.cpp;test_thread.cpp"
         ${{ matrix.args }}
 
     - name: Build (unstable ABI)
       run: cmake --build build3 -j 2
 
     - name: Python tests (unstable ABI)
       run: cmake --build build3 --target pytest
 
     - name: Interface test
       run: cmake --build build2 --target test_cmake_build
 
-    # Eventually Microsoft might have an action for setting up
-    # MSVC, but for now, this action works:
-    - name: Prepare compiler environment for Windows  2.7
-      if: matrix.python == 2.7 && runner.os == 'Windows'
-      uses: ilammy/msvc-dev-cmd@v1.10.0
-      with:
-        arch: x64
-
-    # This makes two environment variables available in the following step(s)
-    - name: Set Windows  2.7 environment variables
-      if: matrix.python == 2.7 && runner.os == 'Windows'
-      shell: bash
-      run: |
-        echo "DISTUTILS_USE_SDK=1" >> $GITHUB_ENV
-        echo "MSSdk=1" >> $GITHUB_ENV
-
     # This makes sure the setup_helpers module can build packages using
     # setuptools
     - name: Setuptools helpers test
-      run: pytest tests/extra_setuptools
-      if: "!(matrix.python == '3.5' && matrix.runs-on == 'windows-2022')"
+      run: |
+        pip install setuptools
+        pytest tests/extra_setuptools
+      if: "!(matrix.runs-on == 'windows-2022')"
 
 
   deadsnakes:
     strategy:
       fail-fast: false
       matrix:
         include:
         # TODO: Fails on 3.10, investigate
-        - python-version: "3.9"
-          python-debug: true
-          valgrind: true
-      # - python-version: "3.11-dev"
-      #   python-debug: false
+        # JOB DISABLED (NEEDS WORK): https://github.com/pybind/pybind11/issues/4889
+        # - python-version: "3.9"
+        #   python-debug: true
+        #   valgrind: true
+        - python-version: "3.11"
+          python-debug: false
 
     name: " ${{ matrix.python-version }}${{ matrix.python-debug && '-dbg' || '' }} (deadsnakes)${{ matrix.valgrind && '  Valgrind' || '' }}  x64"
-    runs-on: ubuntu-latest
+    runs-on: ubuntu-20.04
 
     steps:
-    - uses: actions/checkout@v2
+    - uses: actions/checkout@v4
 
     - name: Setup Python ${{ matrix.python-version }} (deadsnakes)
-      uses: deadsnakes/action@v2.1.1
+      uses: deadsnakes/action@v3.1.0
       with:
         python-version: ${{ matrix.python-version }}
         debug: ${{ matrix.python-debug }}
 
     - name: Update CMake
-      uses: jwlawson/actions-setup-cmake@v1.12
+      uses: jwlawson/actions-setup-cmake@v2.0
 
     - name: Valgrind cache
       if: matrix.valgrind
-      uses: actions/cache@v2
+      uses: actions/cache@v4
       id: cache-valgrind
       with:
         path: valgrind
         key: 3.16.1 # Valgrind version
 
     - name: Compile Valgrind
       if: matrix.valgrind && steps.cache-valgrind.outputs.cache-hit != 'true'
@@ -245,16 +248,14 @@
         sudo apt-get install libc6-dbg  # Needed by Valgrind
 
     - name: Prepare env
       run: |
         python -m pip install -r tests/requirements.txt
 
     - name: Configure
-      env:
-        SETUPTOOLS_USE_DISTUTILS: stdlib
       run: >
         cmake -S . -B build
         -DCMAKE_BUILD_TYPE=Debug
         -DPYBIND11_WERROR=ON
         -DDOWNLOAD_CATCH=ON
         -DDOWNLOAD_EIGEN=ON
         -DCMAKE_CXX_STANDARD=17
@@ -284,27 +285,41 @@
           - 3.7
           - 3.9
           - 7
           - 9
           - dev
         std:
           - 11
+        container_suffix:
+          - ""
         include:
           - clang: 5
             std: 14
           - clang: 10
-            std: 20
-          - clang: 10
             std: 17
+          - clang: 11
+            std: 20
+          - clang: 12
+            std: 20
+          - clang: 13
+            std: 20
+          - clang: 14
+            std: 20
+          - clang: 15
+            std: 20
+            container_suffix: "-bullseye"
+          - clang: 16
+            std: 20
+            container_suffix: "-bullseye"
 
     name: " 3  Clang ${{ matrix.clang }}  C++${{ matrix.std }}  x64"
-    container: "silkeh/clang:${{ matrix.clang }}"
+    container: "silkeh/clang:${{ matrix.clang }}${{ matrix.container_suffix }}"
 
     steps:
-    - uses: actions/checkout@v2
+    - uses: actions/checkout@v4
 
     - name: Add wget and python3
       run: apt-get update && apt-get install -y python3-dev python3-numpy python3-pytest libeigen3-dev
 
     - name: Configure
       shell: bash
       run: >
@@ -326,19 +341,19 @@
     - name: Interface test
       run: cmake --build build --target test_cmake_build
 
 
   # Testing NVCC; forces sources to behave like .cu files
   cuda:
     runs-on: ubuntu-latest
-    name: " 3.8  CUDA 11  Ubuntu 20.04"
-    container: nvidia/cuda:11.0-devel-ubuntu20.04
+    name: " 3.10  CUDA 12.2  Ubuntu 22.04"
+    container: nvidia/cuda:12.2.0-devel-ubuntu22.04
 
     steps:
-    - uses: actions/checkout@v2
+    - uses: actions/checkout@v4
 
     # tzdata will try to ask for the timezone, so set the DEBIAN_FRONTEND
     - name: Install  3
       run: apt-get update && DEBIAN_FRONTEND="noninteractive" apt-get install -y cmake git python3-dev python3-pytest python3-numpy
 
     - name: Configure
       run: cmake -S . -B build -DPYBIND11_CUDA_TESTS=ON -DPYBIND11_WERROR=ON -DDOWNLOAD_CATCH=ON
@@ -354,15 +369,15 @@
 #  # Testing CentOS 8 + PGI compilers
 #  centos-nvhpc8:
 #    runs-on: ubuntu-latest
 #    name: " 3  CentOS8 / PGI 20.11  x64"
 #    container: centos:8
 #
 #    steps:
-#    - uses: actions/checkout@v2
+#    - uses: actions/checkout@v4
 #
 #    - name: Add Python 3 and a few requirements
 #      run: yum update -y && yum install -y git python3-devel python3-numpy python3-pytest make environment-modules
 #
 #    - name: Install CMake with pip
 #      run: |
 #        python3 -m pip install --upgrade pip
@@ -390,92 +405,95 @@
 #    - name: C++ tests
 #      run: cmake --build build --target cpptest
 #
 #    - name: Interface test
 #      run: cmake --build build --target test_cmake_build
 
 
-  # Testing on CentOS 7 + PGI compilers, which seems to require more workarounds
-  centos-nvhpc7:
-    runs-on: ubuntu-latest
-    name: " 3  CentOS7 / PGI 20.9  x64"
-    container: centos:7
+  # Testing on Ubuntu + NVHPC (previous PGI) compilers, which seems to require more workarounds
+  ubuntu-nvhpc7:
+    runs-on: ubuntu-20.04
+    name: " 3  NVHPC 23.5  C++17  x64"
 
+    env:
+      # tzdata will try to ask for the timezone, so set the DEBIAN_FRONTEND
+      DEBIAN_FRONTEND: 'noninteractive'
     steps:
-    - uses: actions/checkout@v2
+    - uses: actions/checkout@v4
 
-    - name: Add Python 3 and a few requirements
-      run: yum update -y && yum install -y epel-release && yum install -y git python3-devel make environment-modules cmake3
+    - name: Add NVHPC Repo
+      run: |
+        echo 'deb [trusted=yes] https://developer.download.nvidia.com/hpc-sdk/ubuntu/amd64 /' | \
+          sudo tee /etc/apt/sources.list.d/nvhpc.list
 
-    - name: Install NVidia HPC SDK
-      run:  yum -y install https://developer.download.nvidia.com/hpc-sdk/20.9/nvhpc-20-9-20.9-1.x86_64.rpm https://developer.download.nvidia.com/hpc-sdk/20.9/nvhpc-2020-20.9-1.x86_64.rpm
+    - name: Install  3 & NVHPC
+      run: |
+        sudo apt-get update -y && \
+        sudo apt-get install -y cmake environment-modules git python3-dev python3-pip python3-numpy && \
+        sudo apt-get install -y --no-install-recommends nvhpc-23-5 && \
+        sudo rm -rf /var/lib/apt/lists/*
+        python3 -m pip install --upgrade pip
+        python3 -m pip install --upgrade pytest
 
-    # On CentOS 7, we have to filter a few tests (compiler internal error)
-    # and allow deeper template recursion (not needed on CentOS 8 with a newer
-    # standard library). On some systems, you many need further workarounds:
+    # On some systems, you many need further workarounds:
     # https://github.com/pybind/pybind11/pull/2475
     - name: Configure
       shell: bash
       run: |
         source /etc/profile.d/modules.sh
-        module load /opt/nvidia/hpc_sdk/modulefiles/nvhpc/20.9
-        cmake3 -S . -B build -DDOWNLOAD_CATCH=ON \
-                            -DCMAKE_CXX_STANDARD=11 \
+        module load /opt/nvidia/hpc_sdk/modulefiles/nvhpc/23.5
+        cmake -S . -B build -DDOWNLOAD_CATCH=ON \
+                            -DCMAKE_CXX_STANDARD=17 \
                             -DPYTHON_EXECUTABLE=$(python3 -c "import sys; print(sys.executable)") \
                             -DCMAKE_CXX_FLAGS="-Wc,--pending_instantiations=0" \
-                            -DPYBIND11_TEST_FILTER="test_smart_ptr.cpp;test_virtual_functions.cpp"
+                            -DPYBIND11_TEST_FILTER="test_smart_ptr.cpp"
 
-    # Building before installing Pip should produce a warning but not an error
     - name: Build
-      run: cmake3 --build build -j 2 --verbose
-
-    - name: Install CMake with pip
-      run: |
-        python3 -m pip install --upgrade pip
-        python3 -m pip install pytest
+      run: cmake --build build -j 2 --verbose
 
     - name: Python tests
-      run: cmake3 --build build --target pytest
+      run: cmake --build build --target pytest
 
     - name: C++ tests
-      run: cmake3 --build build --target cpptest
+      run: cmake --build build --target cpptest
 
     - name: Interface test
-      run: cmake3 --build build --target test_cmake_build
+      run: cmake --build build --target test_cmake_build
 
 
   # Testing on GCC using the GCC docker images (only recent images supported)
   gcc:
     runs-on: ubuntu-latest
     strategy:
       fail-fast: false
       matrix:
-        gcc:
-          - 7
-          - latest
-        std:
-          - 11
         include:
-          - gcc: 10
-            std: 20
+          - { gcc: 7, std: 11 }
+          - { gcc: 7, std: 17 }
+          - { gcc: 8, std: 14 }
+          - { gcc: 8, std: 17 }
+          - { gcc: 10, std: 17 }
+          - { gcc: 11, std: 20 }
+          - { gcc: 12, std: 20 }
+          - { gcc: 13, std: 20 }
 
     name: " 3  GCC ${{ matrix.gcc }}  C++${{ matrix.std }} x64"
     container: "gcc:${{ matrix.gcc }}"
 
     steps:
-    - uses: actions/checkout@v1
+    - uses: actions/checkout@v4
 
     - name: Add Python 3
       run: apt-get update; apt-get install -y python3-dev python3-numpy python3-pytest python3-pip libeigen3-dev
 
     - name: Update pip
       run: python3 -m pip install --upgrade pip
 
     - name: Update CMake
-      uses: jwlawson/actions-setup-cmake@v1.12
+      uses: jwlawson/actions-setup-cmake@v2.0
 
     - name: Configure
       shell: bash
       run: >
         cmake -S . -B build
         -DPYBIND11_WERROR=ON
         -DDOWNLOAD_CATCH=ON
@@ -490,25 +508,41 @@
 
     - name: C++ tests
       run: cmake --build build --target cpptest
 
     - name: Interface test
       run: cmake --build build --target test_cmake_build
 
+    - name: Configure - Exercise cmake -DPYBIND11_TEST_OVERRIDE
+      if: matrix.gcc == '12'
+      shell: bash
+      run: >
+        cmake -S . -B build_partial
+        -DPYBIND11_WERROR=ON
+        -DDOWNLOAD_CATCH=ON
+        -DCMAKE_CXX_STANDARD=${{ matrix.std }}
+        -DPYTHON_EXECUTABLE=$(python3 -c "import sys; print(sys.executable)")
+        "-DPYBIND11_TEST_OVERRIDE=test_call_policies.cpp;test_gil_scoped.cpp;test_thread.cpp"
+
+    - name: Build - Exercise cmake -DPYBIND11_TEST_OVERRIDE
+      if: matrix.gcc == '12'
+      run: cmake --build build_partial -j 2
+
+    - name: Python tests - Exercise cmake -DPYBIND11_TEST_OVERRIDE
+      if: matrix.gcc == '12'
+      run: cmake --build build_partial --target pytest
 
   # Testing on ICC using the oneAPI apt repo
   icc:
     runs-on: ubuntu-20.04
-    strategy:
-      fail-fast: false
 
     name: " 3  ICC latest  x64"
 
     steps:
-    - uses: actions/checkout@v2
+    - uses: actions/checkout@v4
 
     - name: Add apt repo
       run: |
         sudo apt-get update
         sudo apt-get install -y wget build-essential pkg-config cmake ca-certificates gnupg
         wget https://apt.repos.intel.com/intel-gpg-keys/GPG-PUB-KEY-INTEL-SW-PRODUCTS-2023.PUB
         sudo apt-key add GPG-PUB-KEY-INTEL-SW-PRODUCTS-2023.PUB
@@ -595,34 +629,51 @@
   # Testing on CentOS (manylinux uses a centos base, and this is an easy way
   # to get GCC 4.8, which is the manylinux1 compiler).
   centos:
     runs-on: ubuntu-latest
     strategy:
       fail-fast: false
       matrix:
-        centos:
-          - centos7  # GCC 4.8
-          - stream8
+        container:
+          - "centos:7"  # GCC 4.8
+          - "almalinux:8"
+          - "almalinux:9"
 
-    name: " 3  CentOS ${{ matrix.centos }}  x64"
-    container: "quay.io/centos/centos:${{ matrix.centos }}"
+    name: " 3  ${{ matrix.container }}  x64"
+    container: "${{ matrix.container }}"
 
     steps:
-    - uses: actions/checkout@v2
+    - name: Latest actions/checkout
+      uses: actions/checkout@v4
+      if: matrix.container != 'centos:7'
+
+    - name: Pin actions/checkout as required for centos:7
+      uses: actions/checkout@v3
+      if: matrix.container == 'centos:7'
 
-    - name: Add Python 3
+    - name: Add Python 3 (RHEL 7)
+      if: matrix.container == 'centos:7'
       run: yum update -y && yum install -y python3-devel gcc-c++ make git
 
+    - name: Add Python 3 (RHEL 8+)
+      if: matrix.container != 'centos:7'
+      run: dnf update -y && dnf install -y python3-devel gcc-c++ make git
+
     - name: Update pip
       run: python3 -m pip install --upgrade pip
 
     - name: Install dependencies
       run: |
         python3 -m pip install cmake -r tests/requirements.txt
 
+    - name: Ensure NumPy 2 is used (required Python >= 3.9)
+      if: matrix.container == 'almalinux:9'
+      run: |
+        python3 -m pip install 'numpy>=2.0.0b1' 'scipy>=1.13.0rc1'
+
     - name: Configure
       shell: bash
       run: >
         cmake -S . -B build
         -DCMAKE_BUILD_TYPE=MinSizeRel
         -DPYBIND11_WERROR=ON
         -DDOWNLOAD_CATCH=ON
@@ -641,26 +692,26 @@
 
     - name: Interface test
       run: cmake --build build --target test_cmake_build
 
 
   # This tests an "install" with the CMake tools
   install-classic:
-    name: " 3.5  Debian  x86   Install"
+    name: " 3.7  Debian  x86   Install"
     runs-on: ubuntu-latest
-    container: i386/debian:stretch
+    container: i386/debian:buster
 
     steps:
-    - uses: actions/checkout@v1
+    - uses: actions/checkout@v1  # v1 is required to run inside docker
 
     - name: Install requirements
       run: |
         apt-get update
         apt-get install -y git make cmake g++ libeigen3-dev python3-dev python3-pip
-        pip3 install "pytest==3.1.*"
+        pip3 install "pytest==6.*"
 
     - name: Configure for install
       run: >
         cmake .
         -DPYBIND11_INSTALL=1 -DPYBIND11_TEST=0
         -DPYTHON_EXECUTABLE=$(python3 -c "import sys; print(sys.executable)")
 
@@ -683,23 +734,25 @@
 
     - name: Python tests
       run: make pytest -j 2
       working-directory: /build-tests
 
 
   # This verifies that the documentation is not horribly broken, and does a
-  # basic sanity check on the SDist.
+  # basic validation check on the SDist.
   doxygen:
     name: "Documentation build test"
     runs-on: ubuntu-latest
 
     steps:
-    - uses: actions/checkout@v2
+    - uses: actions/checkout@v4
 
-    - uses: actions/setup-python@v2
+    - uses: actions/setup-python@v5
+      with:
+        python-version: "3.x"
 
     - name: Install Doxygen
       run: sudo apt-get install -y doxygen librsvg2-bin # Changed to rsvg-convert in 20.04
 
     - name: Build docs
       run: pipx run nox -s docs
 
@@ -721,44 +774,45 @@
         diff -rq $installed ./pybind11
 
   win32:
     strategy:
       fail-fast: false
       matrix:
         python:
-        - 3.5
         - 3.6
         - 3.7
         - 3.8
         - 3.9
-        - pypy-3.6
 
         include:
           - python: 3.9
-            args: -DCMAKE_CXX_STANDARD=20 -DDOWNLOAD_EIGEN=OFF
+            args: -DCMAKE_CXX_STANDARD=20
           - python: 3.8
             args: -DCMAKE_CXX_STANDARD=17
+          - python: 3.7
+            args: -DCMAKE_CXX_STANDARD=14
+
 
     name: " ${{ matrix.python }}  MSVC 2019  x86 ${{ matrix.args }}"
-    runs-on: windows-latest
+    runs-on: windows-2019
 
     steps:
-    - uses: actions/checkout@v2
+    - uses: actions/checkout@v4
 
     - name: Setup Python ${{ matrix.python }}
-      uses: actions/setup-python@v2
+      uses: actions/setup-python@v5
       with:
         python-version: ${{ matrix.python }}
         architecture: x86
 
     - name: Update CMake
-      uses: jwlawson/actions-setup-cmake@v1.12
+      uses: jwlawson/actions-setup-cmake@v2.0
 
     - name: Prepare MSVC
-      uses: ilammy/msvc-dev-cmd@v1.10.0
+      uses: ilammy/msvc-dev-cmd@v1.13.0
       with:
         arch: x86
 
     - name: Prepare env
       run: |
         python -m pip install -r tests/requirements.txt
 
@@ -773,116 +827,130 @@
         ${{ matrix.args }}
     - name: Build C++11
       run: cmake --build build -j 2
 
     - name: Python tests
       run: cmake --build build -t pytest
 
-  win32-msvc2015:
-    name: " ${{ matrix.python }}  MSVC 2015  x64"
-    runs-on: windows-latest
+  win32-debug:
     strategy:
       fail-fast: false
       matrix:
         python:
-          - 2.7
-          - 3.6
-          - 3.7
-          # todo: check/cpptest does not support 3.8+ yet
+        - 3.8
+        - 3.9
+
+        include:
+          - python: 3.9
+            args: -DCMAKE_CXX_STANDARD=20
+          - python: 3.8
+            args: -DCMAKE_CXX_STANDARD=17
+
+    name: " ${{ matrix.python }}  MSVC 2019 (Debug)  x86 ${{ matrix.args }}"
+    runs-on: windows-2019
 
     steps:
-    - uses: actions/checkout@v2
+    - uses: actions/checkout@v4
 
-    - name: Setup  ${{ matrix.python }}
-      uses: actions/setup-python@v2
+    - name: Setup Python ${{ matrix.python }}
+      uses: actions/setup-python@v5
       with:
         python-version: ${{ matrix.python }}
+        architecture: x86
 
     - name: Update CMake
-      uses: jwlawson/actions-setup-cmake@v1.12
+      uses: jwlawson/actions-setup-cmake@v2.0
 
     - name: Prepare MSVC
-      uses: ilammy/msvc-dev-cmd@v1.10.0
+      uses: ilammy/msvc-dev-cmd@v1.13.0
       with:
-        toolset: 14.0
+        arch: x86
 
     - name: Prepare env
       run: |
         python -m pip install -r tests/requirements.txt
 
     # First build - C++11 mode and inplace
-    - name: Configure
+    - name: Configure ${{ matrix.args }}
       run: >
         cmake -S . -B build
-        -G "Visual Studio 14 2015" -A x64
+        -G "Visual Studio 16 2019" -A Win32
+        -DCMAKE_BUILD_TYPE=Debug
         -DPYBIND11_WERROR=ON
         -DDOWNLOAD_CATCH=ON
         -DDOWNLOAD_EIGEN=ON
+        ${{ matrix.args }}
+    - name: Build C++11
+      run: cmake --build build --config Debug -j 2
 
-    - name: Build C++14
-      run: cmake --build build -j 2
-
-    - name: Run all checks
-      run: cmake --build build -t check
+    - name: Python tests
+      run: cmake --build build --config Debug -t pytest
 
 
-  win32-msvc2017:
-    name: " ${{ matrix.python }}  MSVC 2017  x64"
-    runs-on: windows-2016
+  windows-2022:
     strategy:
       fail-fast: false
       matrix:
         python:
-          - 2.7
-          - 3.5
-          - 3.7
-        std:
-          - 14
+        - 3.9
 
-        include:
-          - python: 2.7
-            std: 17
-            args: >
-              -DCMAKE_CXX_FLAGS="/permissive- /EHsc /GR"
-          - python: 3.7
-            std: 17
-            args: >
-              -DCMAKE_CXX_FLAGS="/permissive- /EHsc /GR"
+    name: " ${{ matrix.python }}  MSVC 2022 C++20  x64"
+    runs-on: windows-2022
 
     steps:
-    - uses: actions/checkout@v2
+    - uses: actions/checkout@v4
 
-    - name: Setup  ${{ matrix.python }}
-      uses: actions/setup-python@v2
+    - name: Setup Python ${{ matrix.python }}
+      uses: actions/setup-python@v5
       with:
         python-version: ${{ matrix.python }}
 
-    - name: Update CMake
-      uses: jwlawson/actions-setup-cmake@v1.12
-
     - name: Prepare env
+      # Ensure use of NumPy 2 (via NumPy nightlies but can be changed soon)
       run: |
-        python -m pip install -r tests/requirements.txt
+        python3 -m pip install -r tests/requirements.txt
+        python3 -m pip install 'numpy>=2.0.0b1' 'scipy>=1.13.0rc1'
 
-    # First build - C++11 mode and inplace
-    - name: Configure
+    - name: Update CMake
+      uses: jwlawson/actions-setup-cmake@v2.0
+
+    - name: Configure C++20
       run: >
         cmake -S . -B build
-        -G "Visual Studio 15 2017" -A x64
         -DPYBIND11_WERROR=ON
         -DDOWNLOAD_CATCH=ON
         -DDOWNLOAD_EIGEN=ON
-        -DCMAKE_CXX_STANDARD=${{ matrix.std }}
-        ${{ matrix.args }}
+        -DCMAKE_CXX_STANDARD=20
 
-    - name: Build ${{ matrix.std }}
+    - name: Build C++20
       run: cmake --build build -j 2
 
-    - name: Run all checks
-      run: cmake --build build -t check
+    - name: Python tests
+      run: cmake --build build --target pytest
+
+    - name: C++20 tests
+      run: cmake --build build --target cpptest -j 2
+
+    - name: Interface test C++20
+      run: cmake --build build --target test_cmake_build
+
+    - name: Configure C++20 - Exercise cmake -DPYBIND11_TEST_OVERRIDE
+      run: >
+        cmake -S . -B build_partial
+        -DPYBIND11_WERROR=ON
+        -DDOWNLOAD_CATCH=ON
+        -DDOWNLOAD_EIGEN=ON
+        -DCMAKE_CXX_STANDARD=20
+        "-DPYBIND11_TEST_OVERRIDE=test_call_policies.cpp;test_gil_scoped.cpp;test_thread.cpp"
+
+    - name: Build C++20 - Exercise cmake -DPYBIND11_TEST_OVERRIDE
+      run: cmake --build build_partial -j 2
+
+    - name: Python tests - Exercise cmake -DPYBIND11_TEST_OVERRIDE
+      run: cmake --build build_partial --target pytest
 
   mingw:
     name: " 3  windows-latest  ${{ matrix.sys }}"
     runs-on: windows-latest
     defaults:
       run:
         shell: msys2 {0}
@@ -897,28 +965,38 @@
       with:
         msystem: ${{matrix.sys}}
         install: >-
           git
           mingw-w64-${{matrix.env}}-gcc
           mingw-w64-${{matrix.env}}-python-pip
           mingw-w64-${{matrix.env}}-python-numpy
-          mingw-w64-${{matrix.env}}-python-scipy
           mingw-w64-${{matrix.env}}-cmake
           mingw-w64-${{matrix.env}}-make
           mingw-w64-${{matrix.env}}-python-pytest
           mingw-w64-${{matrix.env}}-eigen3
           mingw-w64-${{matrix.env}}-boost
           mingw-w64-${{matrix.env}}-catch
 
-    - uses: actions/checkout@v2
+    - uses: msys2/setup-msys2@v2
+      if: matrix.sys == 'mingw64'
+      with:
+        msystem: ${{matrix.sys}}
+        install: >-
+          git
+          mingw-w64-${{matrix.env}}-python-scipy
+
+    - uses: actions/checkout@v4
 
     - name: Configure C++11
       # LTO leads to many undefined reference like
       # `pybind11::detail::function_call::function_call(pybind11::detail::function_call&&)
-      run: cmake -G "MinGW Makefiles" -DCMAKE_CXX_STANDARD=11 -DDOWNLOAD_CATCH=ON -S . -B build
+      run: >-
+        cmake -G "MinGW Makefiles" -DCMAKE_CXX_STANDARD=11 -DPYBIND11_WERROR=ON -DDOWNLOAD_CATCH=ON
+        -DPYTHON_EXECUTABLE=$(python -c "import sys; print(sys.executable)")
+        -S . -B build
 
     - name: Build C++11
       run: cmake --build build -j 2
 
     - name: Python tests C++11
       run: cmake --build build --target pytest -j 2
 
@@ -928,15 +1006,18 @@
     - name: Interface test C++11
       run: PYTHONHOME=/${{matrix.sys}} PYTHONPATH=/${{matrix.sys}} cmake --build build --target test_cmake_build
 
     - name: Clean directory
       run: git clean -fdx
 
     - name: Configure C++14
-      run: cmake -G "MinGW Makefiles" -DCMAKE_CXX_STANDARD=14 -DDOWNLOAD_CATCH=ON -S . -B build2
+      run: >-
+        cmake -G "MinGW Makefiles" -DCMAKE_CXX_STANDARD=14 -DPYBIND11_WERROR=ON -DDOWNLOAD_CATCH=ON
+        -DPYTHON_EXECUTABLE=$(python -c "import sys; print(sys.executable)")
+        -S . -B build2
 
     - name: Build C++14
       run: cmake --build build2 -j 2
 
     - name: Python tests C++14
       run: cmake --build build2 --target pytest -j 2
 
@@ -946,20 +1027,176 @@
     - name: Interface test C++14
       run: PYTHONHOME=/${{matrix.sys}} PYTHONPATH=/${{matrix.sys}} cmake --build build2 --target test_cmake_build
 
     - name: Clean directory
       run: git clean -fdx
 
     - name: Configure C++17
-      run: cmake -G "MinGW Makefiles" -DCMAKE_CXX_STANDARD=17 -DDOWNLOAD_CATCH=ON -S . -B build3
+      run: >-
+        cmake -G "MinGW Makefiles" -DCMAKE_CXX_STANDARD=17 -DPYBIND11_WERROR=ON -DDOWNLOAD_CATCH=ON
+        -DPYTHON_EXECUTABLE=$(python -c "import sys; print(sys.executable)")
+        -S . -B build3
 
     - name: Build C++17
       run: cmake --build build3 -j 2
 
     - name: Python tests C++17
       run: cmake --build build3 --target pytest -j 2
 
     - name: C++17 tests
       run: PYTHONHOME=/${{matrix.sys}} PYTHONPATH=/${{matrix.sys}} cmake --build build3 --target cpptest -j 2
 
     - name: Interface test C++17
       run: PYTHONHOME=/${{matrix.sys}} PYTHONPATH=/${{matrix.sys}} cmake --build build3 --target test_cmake_build
+
+  windows_clang:
+
+    strategy:
+      matrix:
+        os: [windows-latest]
+        python: ['3.10']
+
+    runs-on: "${{ matrix.os }}"
+
+    name: " ${{ matrix.python }}  ${{ matrix.os }}  clang-latest"
+
+    steps:
+      - name: Show env
+        run: env
+
+      - name: Checkout
+        uses: actions/checkout@v4
+
+      - name: Set up Clang
+        uses: egor-tensin/setup-clang@v1
+
+      - name: Setup Python ${{ matrix.python }}
+        uses: actions/setup-python@v5
+        with:
+          python-version: ${{ matrix.python }}
+
+      - name: Update CMake
+        uses: jwlawson/actions-setup-cmake@v2.0
+
+      - name: Install ninja-build tool
+        uses: seanmiddleditch/gha-setup-ninja@v4
+
+      - name: Run pip installs
+        run: |
+          python -m pip install --upgrade pip
+          python -m pip install -r tests/requirements.txt
+
+      - name: Show Clang++ version
+        run: clang++ --version
+
+      - name: Show CMake version
+        run: cmake --version
+
+      # TODO: WERROR=ON
+      - name: Configure Clang
+        run: >
+          cmake -G Ninja -S . -B .
+          -DPYBIND11_WERROR=OFF
+          -DPYBIND11_SIMPLE_GIL_MANAGEMENT=OFF
+          -DDOWNLOAD_CATCH=ON
+          -DDOWNLOAD_EIGEN=ON
+          -DCMAKE_CXX_COMPILER=clang++
+          -DCMAKE_CXX_STANDARD=17
+
+      - name: Build
+        run: cmake --build . -j 2
+
+      - name: Python tests
+        run: cmake --build . --target pytest -j 2
+
+      - name: C++ tests
+        run: cmake --build . --target cpptest -j 2
+
+      - name: Interface test
+        run: cmake --build . --target test_cmake_build -j 2
+
+      - name: Clean directory
+        run: git clean -fdx
+
+  macos_brew_install_llvm:
+    name: "macos-latest  brew install llvm"
+    runs-on: macos-latest
+
+    env:
+      # https://apple.stackexchange.com/questions/227026/how-to-install-recent-clang-with-homebrew
+      LDFLAGS: '-L/usr/local/opt/llvm/lib -Wl,-rpath,/usr/local/opt/llvm/lib'
+
+    steps:
+      - name: Update PATH
+        run: echo "/usr/local/opt/llvm/bin" >> $GITHUB_PATH
+
+      - name: Show env
+        run: env
+
+      - name: Checkout
+        uses: actions/checkout@v4
+
+      - name: Show Clang++ version before brew install llvm
+        run: clang++ --version
+
+      - name: brew install llvm
+        run: brew install llvm
+
+      - name: Show Clang++ version after brew install llvm
+        run: clang++ --version
+
+      - name: Update CMake
+        uses: jwlawson/actions-setup-cmake@v2.0
+
+      - name: Run pip installs
+        run: |
+          python3 -m pip install --upgrade pip
+          python3 -m pip install -r tests/requirements.txt
+          python3 -m pip install numpy
+          python3 -m pip install scipy
+
+      - name: Show CMake version
+        run: cmake --version
+
+      - name: CMake Configure
+        run: >
+          cmake -S . -B .
+          -DPYBIND11_WERROR=ON
+          -DPYBIND11_SIMPLE_GIL_MANAGEMENT=OFF
+          -DDOWNLOAD_CATCH=ON
+          -DDOWNLOAD_EIGEN=ON
+          -DCMAKE_CXX_COMPILER=clang++
+          -DCMAKE_CXX_STANDARD=17
+          -DPYTHON_EXECUTABLE=$(python3 -c "import sys; print(sys.executable)")
+
+      - name: Build
+        run: cmake --build . -j 2
+
+      - name: Python tests
+        run: cmake --build . --target pytest -j 2
+
+      - name: C++ tests
+        run: cmake --build . --target cpptest -j 2
+
+      - name: Interface test
+        run: cmake --build . --target test_cmake_build -j 2
+
+      - name: CMake Configure - Exercise cmake -DPYBIND11_TEST_OVERRIDE
+        run: >
+          cmake -S . -B build_partial
+          -DPYBIND11_WERROR=ON
+          -DPYBIND11_SIMPLE_GIL_MANAGEMENT=OFF
+          -DDOWNLOAD_CATCH=ON
+          -DDOWNLOAD_EIGEN=ON
+          -DCMAKE_CXX_COMPILER=clang++
+          -DCMAKE_CXX_STANDARD=17
+          -DPYTHON_EXECUTABLE=$(python3 -c "import sys; print(sys.executable)")
+          "-DPYBIND11_TEST_OVERRIDE=test_call_policies.cpp;test_gil_scoped.cpp;test_thread.cpp"
+
+      - name: Build - Exercise cmake -DPYBIND11_TEST_OVERRIDE
+        run: cmake --build build_partial -j 2
+
+      - name: Python tests - Exercise cmake -DPYBIND11_TEST_OVERRIDE
+        run: cmake --build build_partial --target pytest -j 2
+
+      - name: Clean directory
+        run: git clean -fdx
```

### Comparing `python_prtree-0.6.0/third/pybind11/.github/workflows/configure.yml` & `python_prtree-0.6.1/third/pybind11/.github/workflows/configure.yml`

 * *Files 16% similar despite different names*

```diff
@@ -5,61 +5,69 @@
   pull_request:
   push:
     branches:
       - master
       - stable
       - v*
 
+permissions:
+  contents: read
+
+env:
+  PIP_BREAK_SYSTEM_PACKAGES: 1
+  # For cmake:
+  VERBOSE: 1
+
 jobs:
   # This tests various versions of CMake in various combinations, to make sure
   # the configure step passes.
   cmake:
     strategy:
       fail-fast: false
       matrix:
-        runs-on: [ubuntu-latest, macos-latest, windows-latest]
+        runs-on: [ubuntu-20.04, macos-latest, windows-latest]
         arch: [x64]
-        cmake: ["3.21"]
+        cmake: ["3.26"]
 
         include:
-        - runs-on: ubuntu-latest
+        - runs-on: ubuntu-20.04
+          arch: x64
+          cmake: "3.5"
+
+        - runs-on: ubuntu-20.04
           arch: x64
-          cmake: 3.4
+          cmake: "3.27"
 
         - runs-on: macos-latest
           arch: x64
-          cmake: 3.7
+          cmake: "3.7"
 
-        - runs-on: windows-2016
-          arch: x86
-          cmake: 3.8
-
-        - runs-on: windows-2016
-          arch: x86
-          cmake: 3.18
+        - runs-on: windows-2019
+          arch: x64 # x86 compilers seem to be missing on 2019 image
+          cmake: "3.18"
 
     name:  3.7  CMake ${{ matrix.cmake }}  ${{ matrix.runs-on }}
     runs-on: ${{ matrix.runs-on }}
 
     steps:
-    - uses: actions/checkout@v2
+    - uses: actions/checkout@v4
 
     - name: Setup Python 3.7
-      uses: actions/setup-python@v2
+      uses: actions/setup-python@v5
       with:
         python-version: 3.7
         architecture: ${{ matrix.arch }}
 
     - name: Prepare env
       run: python -m pip install -r tests/requirements.txt
 
     # An action for adding a specific version of CMake:
     #   https://github.com/jwlawson/actions-setup-cmake
     - name: Setup CMake ${{ matrix.cmake }}
-      uses: jwlawson/actions-setup-cmake@v1.12
+      uses: jwlawson/actions-setup-cmake@v2.0
       with:
         cmake-version: ${{ matrix.cmake }}
 
     # These steps use a directory with a space in it intentionally
     - name: Make build directories
       run: mkdir "build dir"
```

### Comparing `python_prtree-0.6.0/third/pybind11/.github/workflows/format.yml` & `python_prtree-0.6.1/third/pybind11/.github/workflows/format.yml`

 * *Files 27% similar despite different names*

```diff
@@ -8,41 +8,53 @@
   pull_request:
   push:
     branches:
     - master
     - stable
     - "v*"
 
+permissions:
+  contents: read
+
+env:
+  FORCE_COLOR: 3
+  # For cmake:
+  VERBOSE: 1
+
 jobs:
   pre-commit:
     name: Format
     runs-on: ubuntu-latest
     steps:
-    - uses: actions/checkout@v2
-    - uses: actions/setup-python@v2
-    - uses: pre-commit/action@v2.0.3
+    - uses: actions/checkout@v4
+    - uses: actions/setup-python@v5
+      with:
+        python-version: "3.x"
+    - name: Add matchers
+      run: echo "::add-matcher::$GITHUB_WORKSPACE/.github/matchers/pylint.json"
+    - uses: pre-commit/action@v3.0.1
       with:
         # Slow hooks are marked with manual - slow is okay here, run them too
         extra_args: --hook-stage manual --all-files
 
   clang-tidy:
     # When making changes here, please also review the "Clang-Tidy" section
     # in .github/CONTRIBUTING.md and update as needed.
     name: Clang-Tidy
     runs-on: ubuntu-latest
-    container: silkeh/clang:12
+    container: silkeh/clang:15-bullseye
     steps:
-    - uses: actions/checkout@v2
+    - uses: actions/checkout@v4
 
     - name: Install requirements
-      run: apt-get update && apt-get install -y python3-dev python3-pytest
+      run: apt-get update && apt-get install -y git python3-dev python3-pytest
 
     - name: Configure
       run: >
         cmake -S . -B build
-        -DCMAKE_CXX_CLANG_TIDY="$(which clang-tidy)"
+        -DCMAKE_CXX_CLANG_TIDY="$(which clang-tidy);--use-color;--warnings-as-errors=*"
         -DDOWNLOAD_EIGEN=ON
         -DDOWNLOAD_CATCH=ON
         -DCMAKE_CXX_STANDARD=17
 
     - name: Build
       run: cmake --build build -j 2 -- --keep-going
```

### Comparing `python_prtree-0.6.0/third/pybind11/.github/workflows/pip.yml` & `python_prtree-0.6.1/third/pybind11/.github/workflows/pip.yml`

 * *Files 8% similar despite different names*

```diff
@@ -8,32 +8,36 @@
     - master
     - stable
     - v*
   release:
     types:
     - published
 
+permissions:
+  contents: read
+
 env:
+  PIP_BREAK_SYSTEM_PACKAGES: 1
   PIP_ONLY_BINARY: numpy
 
 jobs:
   # This builds the sdists and wheels and makes sure the files are exactly as
-  # expected. Using Windows and Python 2.7, since that is often the most
+  # expected. Using Windows and Python 3.6, since that is often the most
   # challenging matrix element.
   test-packaging:
-    name:  2.7   tests  windows-latest
+    name:  3.6   tests  windows-latest
     runs-on: windows-latest
 
     steps:
-    - uses: actions/checkout@v2
+    - uses: actions/checkout@v4
 
-    - name: Setup  2.7
-      uses: actions/setup-python@v2
+    - name: Setup  3.6
+      uses: actions/setup-python@v5
       with:
-        python-version: 2.7
+        python-version: 3.6
 
     - name: Prepare env
       run: |
         python -m pip install -r tests/requirements.txt
 
     - name: Python Packaging tests
       run: pytest tests/extra_python_package/
@@ -42,18 +46,18 @@
   # This runs the packaging tests and also builds and saves the packages as
   # artifacts.
   packaging:
     name:  3.8   &  tests  ubuntu-latest
     runs-on: ubuntu-latest
 
     steps:
-    - uses: actions/checkout@v2
+    - uses: actions/checkout@v4
 
     - name: Setup  3.8
-      uses: actions/setup-python@v2
+      uses: actions/setup-python@v5
       with:
         python-version: 3.8
 
     - name: Prepare env
       run: |
         python -m pip install -r tests/requirements.txt build twine
 
@@ -65,44 +69,46 @@
         python -m build
         PYBIND11_GLOBAL_SDIST=1 python -m build
 
     - name: Check metadata
       run: twine check dist/*
 
     - name: Save standard package
-      uses: actions/upload-artifact@v2
+      uses: actions/upload-artifact@v4
       with:
         name: standard
         path: dist/pybind11-*
 
     - name: Save global package
-      uses: actions/upload-artifact@v2
+      uses: actions/upload-artifact@v4
       with:
         name: global
         path: dist/pybind11_global-*
 
 
 
   # When a GitHub release is made, upload the artifacts to PyPI
   upload:
     name: Upload to PyPI
     runs-on: ubuntu-latest
     if: github.event_name == 'release' && github.event.action == 'published'
     needs: [packaging]
 
     steps:
-    - uses: actions/setup-python@v2
+    - uses: actions/setup-python@v5
+      with:
+        python-version: "3.x"
 
     # Downloads all to directories matching the artifact names
-    - uses: actions/download-artifact@v2
+    - uses: actions/download-artifact@v4
 
     - name: Publish standard package
-      uses: pypa/gh-action-pypi-publish@v1.5.0
+      uses: pypa/gh-action-pypi-publish@release/v1
       with:
         password: ${{ secrets.pypi_password }}
-        packages_dir: standard/
+        packages-dir: standard/
 
     - name: Publish global package
-      uses: pypa/gh-action-pypi-publish@v1.5.0
+      uses: pypa/gh-action-pypi-publish@release/v1
       with:
         password: ${{ secrets.pypi_password_global }}
-        packages_dir: global/
+        packages-dir: global/
```

### Comparing `python_prtree-0.6.0/third/pybind11/.github/workflows/upstream.yml` & `python_prtree-0.6.1/third/pybind11/.github/workflows/upstream.yml`

 * *Files 9% similar despite different names*

```diff
@@ -1,112 +1,116 @@
-
 name: Upstream
 
 on:
   workflow_dispatch:
   pull_request:
 
+permissions:
+  contents: read
+
 concurrency:
   group: upstream-${{ github.ref }}
   cancel-in-progress: true
 
 env:
-  PIP_ONLY_BINARY: numpy
+  PIP_BREAK_SYSTEM_PACKAGES: 1
+  # For cmake:
+  VERBOSE: 1
 
 jobs:
   standard:
-    name: " 3.11 dev  ubuntu-latest  x64"
+    name: " 3.13 latest  ubuntu-latest  x64"
     runs-on: ubuntu-latest
+    # Only runs when the  'python dev' label is selected
     if: "contains(github.event.pull_request.labels.*.name, 'python dev')"
 
     steps:
-    - uses: actions/checkout@v2
+    - uses: actions/checkout@v4
 
-    - name: Setup Python 3.11
-      uses: actions/setup-python@v2
+    - name: Setup Python 3.13
+      uses: actions/setup-python@v5
       with:
-        python-version: "3.11-dev"
+        python-version: "3.13"
+        allow-prereleases: true
 
-    - name: Setup Boost (Linux)
-      if: runner.os == 'Linux'
+    - name: Setup Boost
       run: sudo apt-get install libboost-dev
 
     - name: Update CMake
-      uses: jwlawson/actions-setup-cmake@v1.12
+      uses: jwlawson/actions-setup-cmake@v2.0
 
-    - name: Prepare env
+    - name: Run pip installs
       run: |
+        python -m pip install --upgrade pip
         python -m pip install -r tests/requirements.txt
 
-    - name: Setup annotations on Linux
-      if: runner.os == 'Linux'
-      run: python -m pip install pytest-github-actions-annotate-failures
+    - name: Show platform info
+      run: |
+        python -m platform
+        cmake --version
+        pip list
 
     # First build - C++11 mode and inplace
     - name: Configure C++11
       run: >
-        cmake -S . -B .
+        cmake -S . -B build11
         -DPYBIND11_WERROR=ON
         -DDOWNLOAD_CATCH=ON
         -DDOWNLOAD_EIGEN=ON
         -DCMAKE_CXX_STANDARD=11
+        -DCMAKE_BUILD_TYPE=Debug
 
     - name: Build C++11
-      run: cmake --build . -j 2
+      run: cmake --build build11 -j 2
 
     - name: Python tests C++11
-      run: cmake --build . --target pytest -j 2
+      run: cmake --build build11 --target pytest -j 2
 
     - name: C++11 tests
-      run: cmake --build .  --target cpptest -j 2
+      run: cmake --build build11  --target cpptest -j 2
 
     - name: Interface test C++11
-      run: cmake --build . --target test_cmake_build
-
-    - name: Clean directory
-      run: git clean -fdx
+      run: cmake --build build11 --target test_cmake_build
 
     # Second build - C++17 mode and in a build directory
     - name: Configure C++17
       run: >
-        cmake -S . -B build2
+        cmake -S . -B build17
         -DPYBIND11_WERROR=ON
         -DDOWNLOAD_CATCH=ON
         -DDOWNLOAD_EIGEN=ON
         -DCMAKE_CXX_STANDARD=17
-        ${{ matrix.args }}
-        ${{ matrix.args2 }}
 
-    - name: Build
-      run: cmake --build build2 -j 2
+    - name: Build C++17
+      run: cmake --build build17 -j 2
 
-    - name: Python tests
-      run: cmake --build build2 --target pytest
+    - name: Python tests C++17
+      run: cmake --build build17 --target pytest
 
-    - name: C++ tests
-      run: cmake --build build2 --target cpptest
+    - name: C++17 tests
+      run: cmake --build build17 --target cpptest
 
     # Third build - C++17 mode with unstable ABI
     - name: Configure (unstable ABI)
       run: >
-        cmake -S . -B build3
+        cmake -S . -B build17max
         -DPYBIND11_WERROR=ON
         -DDOWNLOAD_CATCH=ON
         -DDOWNLOAD_EIGEN=ON
         -DCMAKE_CXX_STANDARD=17
         -DPYBIND11_INTERNALS_VERSION=10000000
-        "-DPYBIND11_TEST_OVERRIDE=test_call_policies.cpp;test_gil_scoped.cpp;test_thread.cpp"
-        ${{ matrix.args }}
 
     - name: Build (unstable ABI)
-      run: cmake --build build3 -j 2
+      run: cmake --build build17max -j 2
 
     - name: Python tests (unstable ABI)
-      run: cmake --build build3 --target pytest
+      run: cmake --build build17max --target pytest
 
-    - name: Interface test
-      run: cmake --build build2 --target test_cmake_build
+    - name: Interface test (unstable ABI)
+      run: cmake --build build17max --target test_cmake_build
 
     # This makes sure the setup_helpers module can build packages using
     # setuptools
     - name: Setuptools helpers test
-      run: pytest tests/extra_setuptools
+      run: |
+        pip install setuptools
+        pytest tests/extra_setuptools
```

### Comparing `python_prtree-0.6.0/third/pybind11/CMakeLists.txt` & `python_prtree-0.6.1/third/pybind11/CMakeLists.txt`

 * *Files 13% similar despite different names*

```diff
@@ -1,23 +1,33 @@
 # CMakeLists.txt -- Build system for the pybind11 modules
 #
 # Copyright (c) 2015 Wenzel Jakob <wenzel@inf.ethz.ch>
 #
 # All rights reserved. Use of this source code is governed by a
 # BSD-style license that can be found in the LICENSE file.
 
-cmake_minimum_required(VERSION 3.4)
+# Propagate this policy (FindPythonInterp removal) so it can be detected later
+if(NOT CMAKE_VERSION VERSION_LESS "3.27")
+  cmake_policy(GET CMP0148 _pybind11_cmp0148)
+endif()
+
+cmake_minimum_required(VERSION 3.5)
 
-# The `cmake_minimum_required(VERSION 3.4...3.22)` syntax does not work with
+# The `cmake_minimum_required(VERSION 3.5...3.27)` syntax does not work with
 # some versions of VS that have a patched CMake 3.11. This forces us to emulate
 # the behavior using the following workaround:
-if(${CMAKE_VERSION} VERSION_LESS 3.22)
+if(${CMAKE_VERSION} VERSION_LESS 3.27)
   cmake_policy(VERSION ${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION})
 else()
-  cmake_policy(VERSION 3.22)
+  cmake_policy(VERSION 3.27)
+endif()
+
+if(_pybind11_cmp0148)
+  cmake_policy(SET CMP0148 ${_pybind11_cmp0148})
+  unset(_pybind11_cmp0148)
 endif()
 
 # Avoid infinite recursion if tests include this as a subdirectory
 if(DEFINED PYBIND11_MASTER_PROJECT)
   return()
 endif()
 
@@ -78,35 +88,66 @@
     set(CMAKE_CXX_EXTENSIONS OFF)
     set(CMAKE_CXX_STANDARD_REQUIRED ON)
   endif()
 
   set(pybind11_system "")
 
   set_property(GLOBAL PROPERTY USE_FOLDERS ON)
+  if(CMAKE_VERSION VERSION_LESS "3.18")
+    set(_pybind11_findpython_default OFF)
+  else()
+    set(_pybind11_findpython_default ON)
+  endif()
 else()
   set(PYBIND11_MASTER_PROJECT OFF)
   set(pybind11_system SYSTEM)
+  set(_pybind11_findpython_default OFF)
 endif()
 
 # Options
 option(PYBIND11_INSTALL "Install pybind11 header files?" ${PYBIND11_MASTER_PROJECT})
 option(PYBIND11_TEST "Build pybind11 test suite?" ${PYBIND11_MASTER_PROJECT})
 option(PYBIND11_NOPYTHON "Disable search for Python" OFF)
+option(PYBIND11_DISABLE_HANDLE_TYPE_NAME_DEFAULT_IMPLEMENTATION
+       "To enforce that a handle_type_name<> specialization exists" OFF)
+option(PYBIND11_SIMPLE_GIL_MANAGEMENT
+       "Use simpler GIL management logic that does not support disassociation" OFF)
+option(PYBIND11_NUMPY_1_ONLY
+       "Disable NumPy 2 support to avoid changes to previous pybind11 versions." OFF)
 set(PYBIND11_INTERNALS_VERSION
     ""
     CACHE STRING "Override the ABI version, may be used to enable the unstable ABI.")
 
+if(PYBIND11_DISABLE_HANDLE_TYPE_NAME_DEFAULT_IMPLEMENTATION)
+  add_compile_definitions(PYBIND11_DISABLE_HANDLE_TYPE_NAME_DEFAULT_IMPLEMENTATION)
+endif()
+if(PYBIND11_SIMPLE_GIL_MANAGEMENT)
+  add_compile_definitions(PYBIND11_SIMPLE_GIL_MANAGEMENT)
+endif()
+if(PYBIND11_NUMPY_1_ONLY)
+  add_compile_definitions(PYBIND11_NUMPY_1_ONLY)
+endif()
+
 cmake_dependent_option(
   USE_PYTHON_INCLUDE_DIR
   "Install pybind11 headers in Python include directory instead of default installation prefix"
   OFF "PYBIND11_INSTALL" OFF)
 
-cmake_dependent_option(PYBIND11_FINDPYTHON "Force new FindPython" OFF
+cmake_dependent_option(PYBIND11_FINDPYTHON "Force new FindPython" ${_pybind11_findpython_default}
                        "NOT CMAKE_VERSION VERSION_LESS 3.12" OFF)
 
+# Allow PYTHON_EXECUTABLE if in FINDPYTHON mode and building pybind11's tests
+# (makes transition easier while we support both modes).
+if(PYBIND11_MASTER_PROJECT
+   AND PYBIND11_FINDPYTHON
+   AND DEFINED PYTHON_EXECUTABLE
+   AND NOT DEFINED Python_EXECUTABLE)
+  set(Python_EXECUTABLE "${PYTHON_EXECUTABLE}")
+endif()
+
 # NB: when adding a header don't forget to also add it to setup.py
 set(PYBIND11_HEADERS
     include/pybind11/detail/class.h
     include/pybind11/detail/common.h
     include/pybind11/detail/descr.h
     include/pybind11/detail/init.h
     include/pybind11/detail/internals.h
@@ -116,26 +157,32 @@
     include/pybind11/buffer_info.h
     include/pybind11/cast.h
     include/pybind11/chrono.h
     include/pybind11/common.h
     include/pybind11/complex.h
     include/pybind11/options.h
     include/pybind11/eigen.h
+    include/pybind11/eigen/common.h
+    include/pybind11/eigen/matrix.h
+    include/pybind11/eigen/tensor.h
     include/pybind11/embed.h
     include/pybind11/eval.h
     include/pybind11/gil.h
+    include/pybind11/gil_safe_call_once.h
     include/pybind11/iostream.h
     include/pybind11/functional.h
     include/pybind11/numpy.h
     include/pybind11/operators.h
     include/pybind11/pybind11.h
     include/pybind11/pytypes.h
     include/pybind11/stl.h
     include/pybind11/stl_bind.h
-    include/pybind11/stl/filesystem.h)
+    include/pybind11/stl/filesystem.h
+    include/pybind11/type_caster_pyobject_ptr.h
+    include/pybind11/typing.h)
 
 # Compare with grep and warn if mismatched
 if(PYBIND11_MASTER_PROJECT AND NOT CMAKE_VERSION VERSION_LESS 3.12)
   file(
     GLOB_RECURSE _pybind11_header_check
     LIST_DIRECTORIES false
     RELATIVE "${CMAKE_CURRENT_SOURCE_DIR}"
@@ -194,14 +241,17 @@
   endif()
 else()
   # It is invalid to install a target twice, too.
   set(PYBIND11_INSTALL OFF)
 endif()
 
 include("${CMAKE_CURRENT_SOURCE_DIR}/tools/pybind11Common.cmake")
+# https://github.com/jtojnar/cmake-snips/#concatenating-paths-when-building-pkg-config-files
+# TODO: cmake 3.20 adds the cmake_path() function, which obsoletes this snippet
+include("${CMAKE_CURRENT_SOURCE_DIR}/tools/JoinPaths.cmake")
 
 # Relative directory setting
 if(USE_PYTHON_INCLUDE_DIR AND DEFINED Python_INCLUDE_DIRS)
   file(RELATIVE_PATH CMAKE_INSTALL_INCLUDEDIR ${CMAKE_INSTALL_PREFIX} ${Python_INCLUDE_DIRS})
 elseif(USE_PYTHON_INCLUDE_DIR AND DEFINED PYTHON_INCLUDE_DIR)
   file(RELATIVE_PATH CMAKE_INSTALL_INCLUDEDIR ${CMAKE_INSTALL_PREFIX} ${PYTHON_INCLUDE_DIRS})
 endif()
@@ -258,14 +308,38 @@
   install(TARGETS pybind11_headers EXPORT "${PYBIND11_EXPORT_NAME}")
 
   install(
     EXPORT "${PYBIND11_EXPORT_NAME}"
     NAMESPACE "pybind11::"
     DESTINATION ${PYBIND11_CMAKECONFIG_INSTALL_DIR})
 
+  # pkg-config support
+  if(NOT prefix_for_pc_file)
+    if(IS_ABSOLUTE "${CMAKE_INSTALL_DATAROOTDIR}")
+      set(prefix_for_pc_file "${CMAKE_INSTALL_PREFIX}")
+    else()
+      set(pc_datarootdir "${CMAKE_INSTALL_DATAROOTDIR}")
+      if(CMAKE_VERSION VERSION_LESS 3.20)
+        set(prefix_for_pc_file "\${pcfiledir}/..")
+        while(pc_datarootdir)
+          get_filename_component(pc_datarootdir "${pc_datarootdir}" DIRECTORY)
+          string(APPEND prefix_for_pc_file "/..")
+        endwhile()
+      else()
+        cmake_path(RELATIVE_PATH CMAKE_INSTALL_PREFIX BASE_DIRECTORY CMAKE_INSTALL_DATAROOTDIR
+                   OUTPUT_VARIABLE prefix_for_pc_file)
+      endif()
+    endif()
+  endif()
+  join_paths(includedir_for_pc_file "\${prefix}" "${CMAKE_INSTALL_INCLUDEDIR}")
+  configure_file("${CMAKE_CURRENT_SOURCE_DIR}/tools/pybind11.pc.in"
+                 "${CMAKE_CURRENT_BINARY_DIR}/pybind11.pc" @ONLY)
+  install(FILES "${CMAKE_CURRENT_BINARY_DIR}/pybind11.pc"
+          DESTINATION "${CMAKE_INSTALL_DATAROOTDIR}/pkgconfig/")
+
   # Uninstall target
   if(PYBIND11_MASTER_PROJECT)
     configure_file("${CMAKE_CURRENT_SOURCE_DIR}/tools/cmake_uninstall.cmake.in"
                    "${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake" IMMEDIATE @ONLY)
 
     add_custom_target(uninstall COMMAND ${CMAKE_COMMAND} -P
                                         ${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake)
```

### Comparing `python_prtree-0.6.0/third/pybind11/LICENSE` & `python_prtree-0.6.1/third/pybind11/LICENSE`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/README.rst` & `python_prtree-0.6.1/third/pybind11/README.rst`

 * *Files 6% similar despite different names*

```diff
@@ -28,22 +28,22 @@
 existence. This compatibility has its cost: arcane template tricks and
 workarounds are necessary to support the oldest and buggiest of compiler
 specimens. Now that C++11-compatible compilers are widely available,
 this heavy machinery has become an excessively large and unnecessary
 dependency.
 
 Think of this library as a tiny self-contained version of Boost.Python
-with everything stripped away that isnt relevant for binding
+with everything stripped away that isn't relevant for binding
 generation. Without comments, the core header files only require ~4K
-lines of code and depend on Python (2.7 or 3.5+, or PyPy) and the C++
+lines of code and depend on Python (3.6+, or PyPy) and the C++
 standard library. This compact implementation was possible thanks to
-some of the new C++11 language features (specifically: tuples, lambda
-functions and variadic templates). Since its creation, this library has
-grown beyond Boost.Python in many ways, leading to dramatically simpler
-binding code in many common situations.
+some C++11 language features (specifically: tuples, lambda functions and
+variadic templates). Since its creation, this library has grown beyond
+Boost.Python in many ways, leading to dramatically simpler binding code in many
+common situations.
 
 Tutorial and reference documentation is provided at
 `pybind11.readthedocs.io <https://pybind11.readthedocs.io/en/latest>`_.
 A PDF version of the manual is available
 `here <https://pybind11.readthedocs.io/_/downloads/en/latest/pdf/>`_.
 And the source code is always available at
 `github.com/pybind/pybind11 <https://github.com/pybind/pybind11>`_.
@@ -67,33 +67,34 @@
 - Custom operators
 - Single and multiple inheritance
 - STL data structures
 - Smart pointers with reference counting like ``std::shared_ptr``
 - Internal references with correct reference counting
 - C++ classes with virtual (and pure virtual) methods can be extended
   in Python
+- Integrated NumPy support (NumPy 2 requires pybind11 2.12+)
 
 Goodies
 -------
 
 In addition to the core functionality, pybind11 provides some extra
 goodies:
 
-- Python 2.7, 3.5+, and PyPy/PyPy3 7.3 are supported with an
-  implementation-agnostic interface.
+- Python 3.6+, and PyPy3 7.3 are supported with an implementation-agnostic
+  interface (pybind11 2.9 was the last version to support Python 2 and 3.5).
 
 - It is possible to bind C++11 lambda functions with captured
   variables. The lambda capture data is stored inside the resulting
   Python function object.
 
 - pybind11 uses C++11 move constructors and move assignment operators
   whenever possible to efficiently transfer custom data types.
 
-- Its easy to expose the internal storage of custom data types through
-  Pythons buffer protocols. This is handy e.g.for fast conversion
+- It's easy to expose the internal storage of custom data types through
+  Pythons' buffer protocols. This is handy e.g.for fast conversion
   between C++ matrix classes like Eigen and NumPy without expensive
   copy operations.
 
 - pybind11 can automatically vectorize functions so that they are
   transparently applied to all entries of one or more NumPy array
   arguments.
 
@@ -115,31 +116,31 @@
 
 - With little extra effort, C++ types can be pickled and unpickled
   similar to regular Python objects.
 
 Supported compilers
 -------------------
 
-1. Clang/LLVM 3.3 or newer (for Apple Xcodes clang, this is 5.0.0 or
+1. Clang/LLVM 3.3 or newer (for Apple Xcode's clang, this is 5.0.0 or
    newer)
 2. GCC 4.8 or newer
-3. Microsoft Visual Studio 2015 Update 3 or newer
+3. Microsoft Visual Studio 2017 or newer
 4. Intel classic C++ compiler 18 or newer (ICC 20.2 tested in CI)
 5. Cygwin/GCC (previously tested on 2.5.1)
 6. NVCC (CUDA 11.0 tested in CI)
 7. NVIDIA PGI (20.9 tested in CI)
 
 About
 -----
 
 This project was created by `Wenzel
 Jakob <http://rgl.epfl.ch/people/wjakob>`_. Significant features and/or
 improvements to the code were contributed by Jonas Adler, Lori A. Burns,
 Sylvain Corlay, Eric Cousineau, Aaron Gokaslan, Ralf Grosse-Kunstleve, Trent Houliston, Axel
-Huebl, @hulucc, Yannick Jadoul, Sergey Lyskov Johan Mabille, Tomasz Misko,
+Huebl, @hulucc, Yannick Jadoul, Sergey Lyskov, Johan Mabille, Tomasz Misko,
 Dean Moldovan, Ben Pritchard, Jason Rhinelander, Boris Schling, Pim
 Schellart, Henry Schreiner, Ivan Smirnov, Boris Staletic, and Patrick Stewart.
 
 We thank Google for a generous financial contribution to the continuous
 integration infrastructure used by this project.
```

### Comparing `python_prtree-0.6.0/third/pybind11/docs/Doxyfile` & `python_prtree-0.6.1/third/pybind11/docs/Doxyfile`

 * *Files 16% similar despite different names*

```diff
@@ -14,9 +14,8 @@
 
 ALIASES                = "rst=\verbatim embed:rst"
 ALIASES               += "endrst=\endverbatim"
 
 QUIET                  = YES
 WARNINGS               = YES
 WARN_IF_UNDOCUMENTED   = NO
-PREDEFINED             = PY_MAJOR_VERSION=3 \
-                         PYBIND11_NOINLINE
+PREDEFINED             = PYBIND11_NOINLINE
```

### Comparing `python_prtree-0.6.0/third/pybind11/docs/Makefile` & `python_prtree-0.6.1/third/pybind11/docs/Makefile`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/docs/advanced/cast/chrono.rst` & `python_prtree-0.6.1/third/pybind11/docs/advanced/cast/chrono.rst`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/docs/advanced/cast/custom.rst` & `python_prtree-0.6.1/third/pybind11/docs/advanced/cast/custom.rst`

 * *Files 3% similar despite different names*

```diff
@@ -34,15 +34,15 @@
 To register the necessary conversion routines, it is necessary to add an
 instantiation of the ``pybind11::detail::type_caster<T>`` template.
 Although this is an implementation detail, adding an instantiation of this
 type is explicitly allowed.
 
 .. code-block:: cpp
 
-    namespace pybind11 { namespace detail {
+    namespace PYBIND11_NAMESPACE { namespace detail {
         template <> struct type_caster<inty> {
         public:
             /**
              * This macro establishes the name 'inty' in
              * function signatures and declares a local variable
              * 'value' of type inty
              */
@@ -74,15 +74,15 @@
              * ``return_value_policy::reference_internal``) and are generally
              * ignored by implicit casters.
              */
             static handle cast(inty src, return_value_policy /* policy */, handle /* parent */) {
                 return PyLong_FromLong(src.long_value);
             }
         };
-    }} // namespace pybind11::detail
+    }} // namespace PYBIND11_NAMESPACE::detail
 
 .. note::
 
     A ``type_caster<T>`` defined with ``PYBIND11_TYPE_CASTER(T, ...)`` requires
     that ``T`` is default-constructible (``value`` is first default constructed
     and then ``load()`` assigns to it).
```

### Comparing `python_prtree-0.6.0/third/pybind11/docs/advanced/cast/eigen.rst` & `python_prtree-0.6.1/third/pybind11/docs/advanced/cast/eigen.rst`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/docs/advanced/cast/functional.rst` & `python_prtree-0.6.1/third/pybind11/docs/advanced/cast/functional.rst`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/docs/advanced/cast/index.rst` & `python_prtree-0.6.1/third/pybind11/docs/advanced/cast/index.rst`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/docs/advanced/cast/overview.rst` & `python_prtree-0.6.1/third/pybind11/docs/advanced/cast/overview.rst`

 * *Files 2% similar despite different names*

```diff
@@ -163,9 +163,8 @@
 +------------------------------------+---------------------------+-----------------------------------+
 | ``Eigen::Map<...>``                | Eigen: mapped memory      | :file:`pybind11/eigen.h`          |
 +------------------------------------+---------------------------+-----------------------------------+
 | ``Eigen::SparseMatrix<...>``       | Eigen: sparse matrix      | :file:`pybind11/eigen.h`          |
 +------------------------------------+---------------------------+-----------------------------------+
 
 .. [#] ``std::filesystem::path`` is converted to ``pathlib.Path`` and
-   ``os.PathLike`` is converted to ``std::filesystem::path``, but this requires
-   Python 3.6 (for ``__fspath__`` support).
+   ``os.PathLike`` is converted to ``std::filesystem::path``.
```

### Comparing `python_prtree-0.6.0/third/pybind11/docs/advanced/cast/stl.rst` & `python_prtree-0.6.1/third/pybind11/docs/advanced/cast/stl.rst`

 * *Files 4% similar despite different names*

```diff
@@ -38,39 +38,39 @@
 Various versions of these containers also exist for C++11 (e.g. in Boost).
 pybind11 provides an easy way to specialize the ``type_caster`` for such
 types:
 
 .. code-block:: cpp
 
     // `boost::optional` as an example -- can be any `std::optional`-like container
-    namespace pybind11 { namespace detail {
+    namespace PYBIND11_NAMESPACE { namespace detail {
         template <typename T>
         struct type_caster<boost::optional<T>> : optional_caster<boost::optional<T>> {};
     }}
 
 The above should be placed in a header file and included in all translation units
 where automatic conversion is needed. Similarly, a specialization can be provided
 for custom variant types:
 
 .. code-block:: cpp
 
     // `boost::variant` as an example -- can be any `std::variant`-like container
-    namespace pybind11 { namespace detail {
+    namespace PYBIND11_NAMESPACE { namespace detail {
         template <typename... Ts>
         struct type_caster<boost::variant<Ts...>> : variant_caster<boost::variant<Ts...>> {};
 
         // Specifies the function used to visit the variant -- `apply_visitor` instead of `visit`
         template <>
         struct visit_helper<boost::variant> {
             template <typename... Args>
             static auto call(Args &&...args) -> decltype(boost::apply_visitor(args...)) {
                 return boost::apply_visitor(args...);
             }
         };
-    }} // namespace pybind11::detail
+    }} // namespace PYBIND11_NAMESPACE::detail
 
 The ``visit_helper`` specialization is not required if your ``name::variant`` provides
 a ``name::visit()`` function. For any other function name, the specialization must be
 included to tell pybind11 how to visit the variant.
 
 .. warning::
 
@@ -83,16 +83,14 @@
     an ``int`` and is convertible to a C++ ``int``. Changing the order of alternatives
     (and using ``variant<bool, int>``, in this example) provides a solution.
 
 .. note::
 
     pybind11 only supports the modern implementation of ``boost::variant``
     which makes use of variadic templates. This requires Boost 1.56 or newer.
-    Additionally, on Windows, MSVC 2017 is required because ``boost::variant``
-    falls back to the old non-variadic implementation on MSVC 2015.
 
 .. _opaque:
 
 Making opaque types
 ===================
 
 pybind11 heavily relies on a template matching mechanism to convert parameters
```

### Comparing `python_prtree-0.6.0/third/pybind11/docs/advanced/cast/strings.rst` & `python_prtree-0.6.1/third/pybind11/docs/advanced/cast/strings.rst`

 * *Files 8% similar despite different names*

```diff
@@ -1,18 +1,10 @@
 Strings, bytes and Unicode conversions
 ######################################
 
-.. note::
-
-    This section discusses string handling in terms of Python 3 strings. For
-    Python 2.7, replace all occurrences of ``str`` with ``unicode`` and
-    ``bytes`` with ``str``.  Python 2.7 users may find it best to use ``from
-    __future__ import unicode_literals`` to avoid unintentionally using ``str``
-    instead of ``unicode``.
-
 Passing Python strings to C++
 =============================
 
 When a Python ``str`` is passed from Python to a C++ function that accepts
 ``std::string`` or ``char *`` as arguments, pybind11 will encode the Python
 string to UTF-8. All Python ``str`` can be encoded in UTF-8, so this operation
 does not fail.
@@ -54,17 +46,17 @@
 The results are the same whether the C++ function accepts arguments by value or
 reference, and whether or not ``const`` is used.
 
 Passing bytes to C++
 --------------------
 
 A Python ``bytes`` object will be passed to C++ functions that accept
-``std::string`` or ``char*`` *without* conversion.  On Python 3, in order to
-make a function *only* accept ``bytes`` (and not ``str``), declare it as taking
-a ``py::bytes`` argument.
+``std::string`` or ``char*`` *without* conversion.  In order to make a function
+*only* accept ``bytes`` (and not ``str``), declare it as taking a ``py::bytes``
+argument.
 
 
 Returning C++ strings to Python
 ===============================
 
 When a C++ function returns a ``std::string`` or ``char*`` to a Python caller,
 **pybind11 will assume that the string is valid UTF-8** and will decode it to a
@@ -105,27 +97,31 @@
 
 .. code-block:: c++
 
     // This uses the Python C API to convert Latin-1 to Unicode
     m.def("str_output",
         []() {
             std::string s = "Send your r\xe9sum\xe9 to Alice in HR"; // Latin-1
-            py::str py_s = PyUnicode_DecodeLatin1(s.data(), s.length());
-            return py_s;
+            py::handle py_s = PyUnicode_DecodeLatin1(s.data(), s.length(), nullptr);
+            if (!py_s) {
+                throw py::error_already_set();
+            }
+            return py::reinterpret_steal<py::str>(py_s);
         }
     );
 
 .. code-block:: pycon
 
     >>> str_output()
     'Send your rsum to Alice in HR'
 
 The `Python C API
 <https://docs.python.org/3/c-api/unicode.html#built-in-codecs>`_ provides
-several built-in codecs.
+several built-in codecs. Note that these all return *new* references, so
+use :cpp:func:`reinterpret_steal` when converting them to a :cpp:class:`str`.
 
 
 One could also use a third party encoding library such as libiconv to transcode
 to UTF-8.
 
 Return C++ strings without conversion
 -------------------------------------
@@ -200,19 +196,14 @@
             std::wstring text(buffer.get());
 
             // wstring will be converted to Python str
             return text;
         }
     );
 
-.. warning::
-
-    Wide character strings may not work as described on Python 2.7 or Python
-    3.3 compiled with ``--enable-unicode=ucs2``.
-
 Strings in multibyte encodings such as Shift-JIS must transcoded to a
 UTF-8/16/32 before being returned to Python.
 
 
 Character literals
 ==================
```

### Comparing `python_prtree-0.6.0/third/pybind11/docs/advanced/classes.rst` & `python_prtree-0.6.1/third/pybind11/docs/advanced/classes.rst`

 * *Files 1% similar despite different names*

```diff
@@ -129,22 +129,22 @@
 a virtual method call.
 
 .. code-block:: pycon
 
     >>> from example import *
     >>> d = Dog()
     >>> call_go(d)
-    u'woof! woof! woof! '
+    'woof! woof! woof! '
     >>> class Cat(Animal):
     ...     def go(self, n_times):
     ...         return "meow! " * n_times
     ...
     >>> c = Cat()
     >>> call_go(c)
-    u'meow! meow! meow! '
+    'meow! meow! meow! '
 
 If you are defining a custom constructor in a derived Python class, you *must*
 ensure that you explicitly call the bound C++ constructor using ``__init__``,
 *regardless* of whether it is a default constructor or not. Otherwise, the
 memory for the C++ portion of the instance will be left uninitialized, which
 will generally leave the C++ instance in an invalid state and cause undefined
 behavior if the C++ instance is subsequently used.
@@ -809,34 +809,29 @@
 rules as the single-argument version of ``py::init()``. The return type can be
 a value, pointer or holder type. See :ref:`custom_constructors` for details.
 
 An instance can now be pickled as follows:
 
 .. code-block:: python
 
-    try:
-        import cPickle as pickle  # Use cPickle on Python 2.7
-    except ImportError:
-        import pickle
+    import pickle
 
     p = Pickleable("test_value")
     p.setExtra(15)
-    data = pickle.dumps(p, 2)
+    data = pickle.dumps(p)
 
 
 .. note::
-    Note that only the cPickle module is supported on Python 2.7.
-
-    The second argument to ``dumps`` is also crucial: it selects the pickle
-    protocol version 2, since the older version 1 is not supported. Newer
-    versions are also finefor instance, specify ``-1`` to always use the
-    latest available version. Beware: failure to follow these instructions
-    will cause important pybind11 memory allocation routines to be skipped
-    during unpickling, which will likely lead to memory corruption and/or
-    segmentation faults.
+    If given, the second argument to ``dumps`` must be 2 or larger - 0 and 1 are
+    not supported. Newer versions are also fine; for instance, specify ``-1`` to
+    always use the latest available version. Beware: failure to follow these
+    instructions will cause important pybind11 memory allocation routines to be
+    skipped during unpickling, which will likely lead to memory corruption
+    and/or segmentation faults. Python defaults to version 3 (Python 3-3.7) and
+    version 4 for Python 3.8+.
 
 .. seealso::
 
     The file :file:`tests/test_pickling.cpp` contains a complete example
     that demonstrates how to pickle and unpickle types using pybind11 in more
     detail.
 
@@ -845,19 +840,17 @@
 Deepcopy support
 ================
 
 Python normally uses references in assignments. Sometimes a real copy is needed
 to prevent changing all copies. The ``copy`` module [#f5]_ provides these
 capabilities.
 
-On Python 3, a class with pickle support is automatically also (deep)copy
+A class with pickle support is automatically also (deep)copy
 compatible. However, performance can be improved by adding custom
-``__copy__`` and ``__deepcopy__`` methods. With Python 2.7, these custom methods
-are mandatory for (deep)copy compatibility, because pybind11 only supports
-cPickle.
+``__copy__`` and ``__deepcopy__`` methods.
 
 For simple classes (deep)copy can be enabled by using the copy constructor,
 which should look as follows:
 
 .. code-block:: cpp
 
     py::class_<Copyable>(m, "Copyable")
@@ -1121,21 +1114,14 @@
     public:
         using A::foo;
     };
 
     py::class_<A, Trampoline>(m, "A") // <-- `Trampoline` here
         .def("foo", &Publicist::foo); // <-- `Publicist` here, not `Trampoline`!
 
-.. note::
-
-    MSVC 2015 has a compiler bug (fixed in version 2017) which
-    requires a more explicit function binding in the form of
-    ``.def("foo", static_cast<int (A::*)() const>(&Publicist::foo));``
-    where ``int (A::*)() const`` is the type of ``A::foo``.
-
 Binding final classes
 =====================
 
 Some classes may not be appropriate to inherit from. In C++11, classes can
 use the ``final`` specifier to ensure that a class cannot be inherited from.
 The ``py::is_final`` attribute can be used to ensure that Python classes
 cannot inherit from a specified type. The underlying C++ type does not need
@@ -1238,26 +1224,26 @@
     };
     struct Dog : Pet {
         Dog() : Pet(PetKind::Dog) {}
         std::string sound = "woof!";
         std::string bark() const { return sound; }
     };
 
-    namespace pybind11 {
+    namespace PYBIND11_NAMESPACE {
         template<> struct polymorphic_type_hook<Pet> {
             static const void *get(const Pet *src, const std::type_info*& type) {
                 // note that src may be nullptr
                 if (src && src->kind == PetKind::Dog) {
                     type = &typeid(Dog);
                     return static_cast<const Dog*>(src);
                 }
                 return src;
             }
         };
-    } // namespace pybind11
+    } // namespace PYBIND11_NAMESPACE
 
 When pybind11 wants to convert a C++ pointer of type ``Base*`` to a
 Python object, it calls ``polymorphic_type_hook<Base>::get()`` to
 determine if a downcast is possible. The ``get()`` function should use
 whatever runtime information is available to determine if its ``src``
 parameter is in fact an instance of some class ``Derived`` that
 inherits from ``Base``. If it finds such a ``Derived``, it sets ``type
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `python_prtree-0.6.0/third/pybind11/docs/advanced/embedding.rst` & `python_prtree-0.6.1/third/pybind11/docs/advanced/embedding.rst`

 * *Files 1% similar despite different names*

```diff
@@ -14,15 +14,15 @@
 
 A basic executable with an embedded interpreter can be created with just a few
 lines of CMake and the ``pybind11::embed`` target, as shown below. For more
 information, see :doc:`/compiling`.
 
 .. code-block:: cmake
 
-    cmake_minimum_required(VERSION 3.4)
+    cmake_minimum_required(VERSION 3.5...3.27)
     project(example)
 
     find_package(pybind11 REQUIRED)  # or `add_subdirectory(pybind11)`
 
     add_executable(example main.cpp)
     target_link_libraries(example PRIVATE pybind11::embed)
```

### Comparing `python_prtree-0.6.0/third/pybind11/docs/advanced/exceptions.rst` & `python_prtree-0.6.1/third/pybind11/docs/advanced/exceptions.rst`

 * *Files 2% similar despite different names*

```diff
@@ -123,37 +123,38 @@
 in reverse order of registration (i.e. the last registered translator gets the
 first shot at handling the exception). All local translators will be tried
 before a global translator is tried.
 
 Inside the translator, ``std::rethrow_exception`` should be used within
 a try block to re-throw the exception.  One or more catch clauses to catch
 the appropriate exceptions should then be used with each clause using
-``PyErr_SetString`` to set a Python exception or ``ex(string)`` to set
-the python exception to a custom exception type (see below).
+``py::set_error()`` (see below).
 
 To declare a custom Python exception type, declare a ``py::exception`` variable
 and use this in the associated exception translator (note: it is often useful
 to make this a static declaration when using it inside a lambda expression
 without requiring capturing).
 
 The following example demonstrates this for a hypothetical exception classes
 ``MyCustomException`` and ``OtherException``: the first is translated to a
 custom python exception ``MyCustomError``, while the second is translated to a
 standard python RuntimeError:
 
 .. code-block:: cpp
 
-    static py::exception<MyCustomException> exc(m, "MyCustomError");
+    PYBIND11_CONSTINIT static py::gil_safe_call_once_and_store<py::object> exc_storage;
+    exc_storage.call_once_and_store_result(
+        [&]() { return py::exception<MyCustomException>(m, "MyCustomError"); });
     py::register_exception_translator([](std::exception_ptr p) {
         try {
             if (p) std::rethrow_exception(p);
         } catch (const MyCustomException &e) {
-            exc(e.what());
+            py::set_error(exc_storage.get_stored(), e.what());
         } catch (const OtherException &e) {
-            PyErr_SetString(PyExc_RuntimeError, e.what());
+            py::set_error(PyExc_RuntimeError, e.what());
         }
     });
 
 Multiple exceptions can be handled by a single translator, as shown in the
 example above. If the exception is not caught by the current translator, the
 previously registered one gets a chance.
 
@@ -164,26 +165,28 @@
 .. seealso::
 
     The file :file:`tests/test_exceptions.cpp` contains examples
     of various custom exception translators and custom exception types.
 
 .. note::
 
-    Call either ``PyErr_SetString`` or a custom exception's call
-    operator (``exc(string)``) for every exception caught in a custom exception
+    Call ``py::set_error()`` for every exception caught in a custom exception
     translator.  Failure to do so will cause Python to crash with ``SystemError:
     error return without exception set``.
 
     Exceptions that you do not plan to handle should simply not be caught, or
     may be explicitly (re-)thrown to delegate it to the other,
     previously-declared existing exception translators.
 
-    Note that ``libc++`` and ``libstdc++`` `behave differently <https://stackoverflow.com/questions/19496643/using-clang-fvisibility-hidden-and-typeinfo-and-type-erasure/28827430>`_
-    with ``-fvisibility=hidden``. Therefore exceptions that are used across ABI boundaries need to be explicitly exported, as exercised in ``tests/test_exceptions.h``.
-    See also: "Problems with C++ exceptions" under `GCC Wiki <https://gcc.gnu.org/wiki/Visibility>`_.
+    Note that ``libc++`` and ``libstdc++`` `behave differently under macOS
+    <https://stackoverflow.com/questions/19496643/using-clang-fvisibility-hidden-and-typeinfo-and-type-erasure/28827430>`_
+    with ``-fvisibility=hidden``. Therefore exceptions that are used across ABI
+    boundaries need to be explicitly exported, as exercised in
+    ``tests/test_exceptions.h``. See also:
+    "Problems with C++ exceptions" under `GCC Wiki <https://gcc.gnu.org/wiki/Visibility>`_.
 
 
 Local vs Global Exception Translators
 =====================================
 
 When a global exception translator is registered, it will be applied across all
 modules in the reverse order of registration. This can create behavior where the
@@ -193,27 +196,27 @@
 
 .. code-block:: cpp
 
       py::register_exception_translator([](std::exception_ptr p) {
         try {
             if (p) std::rethrow_exception(p);
         } catch (const std::invalid_argument &e) {
-            PyErr_SetString("module1 handled this")
+            py::set_error(PyExc_ArgumentError, "module1 handled this");
         }
       }
 
 and module2 has the following similar translator:
 
 .. code-block:: cpp
 
       py::register_exception_translator([](std::exception_ptr p) {
         try {
             if (p) std::rethrow_exception(p);
         } catch (const std::invalid_argument &e) {
-            PyErr_SetString("module2 handled this")
+            py::set_error(PyExc_ArgumentError, "module2 handled this");
         }
       }
 
 then which translator handles the invalid_argument will be determined by the
 order that module1 and module2 are imported. Since exception translators are
 applied in the reverse order of registration, which ever module was imported
 last will "win" and that translator will be applied.
@@ -305,46 +308,46 @@
 the Python C API directly. When calling the Python C API directly, in
 addition to manually managing reference counts, one must follow the pybind11
 error protocol, which is outlined here.
 
 After calling the Python C API, if Python returns an error,
 ``throw py::error_already_set();``, which allows pybind11 to deal with the
 exception and pass it back to the Python interpreter. This includes calls to
-the error setting functions such as ``PyErr_SetString``.
+the error setting functions such as ``py::set_error()``.
 
 .. code-block:: cpp
 
-    PyErr_SetString(PyExc_TypeError, "C API type error demo");
+    py::set_error(PyExc_TypeError, "C API type error demo");
     throw py::error_already_set();
 
     // But it would be easier to simply...
     throw py::type_error("pybind11 wrapper type error");
 
 Alternately, to ignore the error, call `PyErr_Clear
 <https://docs.python.org/3/c-api/exceptions.html#c.PyErr_Clear>`_.
 
 Any Python error must be thrown or cleared, or Python/pybind11 will be left in
 an invalid state.
 
 Chaining exceptions ('raise from')
 ==================================
 
-In Python 3.3 a mechanism for indicating that exceptions were caused by other
-exceptions was introduced:
+Python has a mechanism for indicating that exceptions were caused by other
+exceptions:
 
 .. code-block:: py
 
     try:
         print(1 / 0)
     except Exception as exc:
         raise RuntimeError("could not divide by zero") from exc
 
 To do a similar thing in pybind11, you can use the ``py::raise_from`` function. It
 sets the current python error indicator, so to continue propagating the exception
-you should ``throw py::error_already_set()`` (Python 3 only).
+you should ``throw py::error_already_set()``.
 
 .. code-block:: cpp
 
     try {
         py::eval("print(1 / 0"));
     } catch (py::error_already_set &e) {
         py::raise_from(e, PyExc_RuntimeError, "could not divide by zero");
```

### Comparing `python_prtree-0.6.0/third/pybind11/docs/advanced/functions.rst` & `python_prtree-0.6.1/third/pybind11/docs/advanced/functions.rst`

 * *Files 2% similar despite different names*

```diff
@@ -12,15 +12,15 @@
 =====================
 
 Python and C++ use fundamentally different ways of managing the memory and
 lifetime of objects managed by them. This can lead to issues when creating
 bindings for functions that return a non-trivial type. Just by looking at the
 type information, it is not clear whether Python should take charge of the
 returned value and eventually free its resources, or if this is handled on the
-C++ side. For this reason, pybind11 provides a several *return value policy*
+C++ side. For this reason, pybind11 provides several *return value policy*
 annotations that can be passed to the :func:`module_::def` and
 :func:`class_::def` functions. The default policy is
 :enum:`return_value_policy::automatic`.
 
 Return value policies are tricky, and it's very important to get them right.
 Just to illustrate what can go wrong, consider the following simple example:
 
@@ -368,15 +368,15 @@
         .def("myFunction", py::arg("arg") = static_cast<SomeType *>(nullptr));
 
 .. _keyword_only_arguments:
 
 Keyword-only arguments
 ======================
 
-Python 3 introduced keyword-only arguments by specifying an unnamed ``*``
+Python implements keyword-only arguments by specifying an unnamed ``*``
 argument in a function definition:
 
 .. code-block:: python
 
     def f(a, *, b):  # a can be positional or via keyword; b must be via keyword
         pass
 
@@ -391,27 +391,26 @@
 argument annotations when registering the function:
 
 .. code-block:: cpp
 
     m.def("f", [](int a, int b) { /* ... */ },
           py::arg("a"), py::kw_only(), py::arg("b"));
 
-Note that you currently cannot combine this with a ``py::args`` argument.  This
-feature does *not* require Python 3 to work.
-
 .. versionadded:: 2.6
 
-As of pybind11 2.9, a ``py::args`` argument implies that any following arguments
-are keyword-only, as if ``py::kw_only()`` had been specified in the same
-relative location of the argument list as the ``py::args`` argument.  The
-``py::kw_only()`` may be included to be explicit about this, but is not
-required.  (Prior to 2.9 ``py::args`` may only occur at the end of the argument
-list, or immediately before a ``py::kwargs`` argument at the end).
+A ``py::args`` argument implies that any following arguments are keyword-only,
+as if ``py::kw_only()`` had been specified in the same relative location of the
+argument list as the ``py::args`` argument.  The ``py::kw_only()`` may be
+included to be explicit about this, but is not required.
+
+.. versionchanged:: 2.9
+   This can now be combined with ``py::args``. Before, ``py::args`` could only
+   occur at the end of the argument list, or immediately before a ``py::kwargs``
+   argument at the end.
 
-.. versionadded:: 2.9
 
 Positional-only arguments
 =========================
 
 Python 3.8 introduced a new positional-only argument syntax, using ``/`` in the
 function definition (note that this has been a convention for CPython
 positional arguments, such as in ``pow()``, since Python 2). You can
```

### Comparing `python_prtree-0.6.0/third/pybind11/docs/advanced/misc.rst` & `python_prtree-0.6.1/third/pybind11/docs/advanced/misc.rst`

 * *Files 22% similar despite different names*

```diff
@@ -35,34 +35,59 @@
 The ``PYBIND11_MAKE_OPAQUE`` macro does *not* require the above workarounds.
 
 .. _gil:
 
 Global Interpreter Lock (GIL)
 =============================
 
-When calling a C++ function from Python, the GIL is always held.
+The Python C API dictates that the Global Interpreter Lock (GIL) must always
+be held by the current thread to safely access Python objects. As a result,
+when Python calls into C++ via pybind11 the GIL must be held, and pybind11
+will never implicitly release the GIL.
+
+.. code-block:: cpp
+
+    void my_function() {
+        /* GIL is held when this function is called from Python */
+    }
+
+    PYBIND11_MODULE(example, m) {
+        m.def("my_function", &my_function);
+    }
+
+pybind11 will ensure that the GIL is held when it knows that it is calling
+Python code. For example, if a Python callback is passed to C++ code via
+``std::function``, when C++ code calls the function the built-in wrapper
+will acquire the GIL before calling the Python callback. Similarly, the
+``PYBIND11_OVERRIDE`` family of macros will acquire the GIL before calling
+back into Python.
+
+When writing C++ code that is called from other C++ code, if that code accesses
+Python state, it must explicitly acquire and release the GIL.
+
 The classes :class:`gil_scoped_release` and :class:`gil_scoped_acquire` can be
 used to acquire and release the global interpreter lock in the body of a C++
 function call. In this way, long-running C++ code can be parallelized using
-multiple Python threads. Taking :ref:`overriding_virtuals` as an example, this
+multiple Python threads, **but great care must be taken** when any
+:class:`gil_scoped_release` appear: if there is any way that the C++ code
+can access Python objects, :class:`gil_scoped_acquire` should be used to
+reacquire the GIL. Taking :ref:`overriding_virtuals` as an example, this
 could be realized as follows (important changes highlighted):
 
 .. code-block:: cpp
-    :emphasize-lines: 8,9,31,32
+    :emphasize-lines: 8,30,31
 
     class PyAnimal : public Animal {
     public:
         /* Inherit the constructors */
         using Animal::Animal;
 
         /* Trampoline (need one for each virtual function) */
         std::string go(int n_times) {
-            /* Acquire GIL before calling Python code */
-            py::gil_scoped_acquire acquire;
-
+            /* PYBIND11_OVERRIDE_PURE will acquire the GIL before accessing Python state */
             PYBIND11_OVERRIDE_PURE(
                 std::string, /* Return type */
                 Animal,      /* Parent class */
                 go,          /* Name of function */
                 n_times      /* Argument(s) */
             );
         }
@@ -74,28 +99,57 @@
             .def(py::init<>())
             .def("go", &Animal::go);
 
         py::class_<Dog>(m, "Dog", animal)
             .def(py::init<>());
 
         m.def("call_go", [](Animal *animal) -> std::string {
-            /* Release GIL before calling into (potentially long-running) C++ code */
+            // GIL is held when called from Python code. Release GIL before
+            // calling into (potentially long-running) C++ code
             py::gil_scoped_release release;
             return call_go(animal);
         });
     }
 
 The ``call_go`` wrapper can also be simplified using the ``call_guard`` policy
 (see :ref:`call_policies`) which yields the same result:
 
 .. code-block:: cpp
 
     m.def("call_go", &call_go, py::call_guard<py::gil_scoped_release>());
 
 
+Common Sources Of Global Interpreter Lock Errors
+==================================================================
+
+Failing to properly hold the Global Interpreter Lock (GIL) is one of the
+more common sources of bugs within code that uses pybind11. If you are
+running into GIL related errors, we highly recommend you consult the
+following checklist.
+
+- Do you have any global variables that are pybind11 objects or invoke
+  pybind11 functions in either their constructor or destructor? You are generally
+  not allowed to invoke any Python function in a global static context. We recommend
+  using lazy initialization and then intentionally leaking at the end of the program.
+
+- Do you have any pybind11 objects that are members of other C++ structures? One
+  commonly overlooked requirement is that pybind11 objects have to increase their reference count
+  whenever their copy constructor is called. Thus, you need to be holding the GIL to invoke
+  the copy constructor of any C++ class that has a pybind11 member. This can sometimes be very
+  tricky to track for complicated programs Think carefully when you make a pybind11 object
+  a member in another struct.
+
+- C++ destructors that invoke Python functions can be particularly troublesome as
+  destructors can sometimes get invoked in weird and unexpected circumstances as a result
+  of exceptions.
+
+- You should try running your code in a debug build. That will enable additional assertions
+  within pybind11 that will throw exceptions on certain GIL handling errors
+  (reference counting operations).
+
 Binding sequence data types, iterators, the slicing protocol, etc.
 ==================================================================
 
 Please refer to the supplemental example for details.
 
 .. seealso::
 
@@ -294,14 +348,23 @@
     PYBIND11_MODULE(example, m) {
         py::options options;
         options.disable_function_signatures();
 
         m.def("add", [](int a, int b) { return a + b; }, "A function which adds two numbers");
     }
 
+pybind11 also appends all members of an enum to the resulting enum docstring.
+This default behavior can be disabled by using the ``disable_enum_members_docstring()``
+function of the ``options`` class.
+
+With ``disable_user_defined_docstrings()`` all user defined docstrings of
+``module_::def()``, ``class_::def()`` and ``enum_()`` are disabled, but the
+function signatures and enum members are included in the docstring, unless they
+are disabled separately.
+
 Note that changes to the settings affect only function bindings created during the
 lifetime of the ``options`` instance. When it goes out of scope at the end of the module's init function,
 the default settings are restored to prevent unwanted side effects.
 
 .. [#f4] http://www.sphinx-doc.org
 .. [#f5] http://github.com/pybind/python_example
 
@@ -331,7 +394,36 @@
 
         auto pyFoo = py::class_<ns::Foo>(m, "Foo");
         auto pyBar = py::class_<ns::Bar>(m, "Bar");
 
         pyFoo.def(py::init<const ns::Bar&>());
         pyBar.def(py::init<const ns::Foo&>());
     }
+
+Setting inner type hints in docstrings
+======================================
+
+When you use pybind11 wrappers for ``list``, ``dict``, and other generic python
+types, the docstring will just display the generic type. You can convey the
+inner types in the docstring by using a special 'typed' version of the generic
+type.
+
+.. code-block:: cpp
+
+    PYBIND11_MODULE(example, m) {
+        m.def("pass_list_of_str", [](py::typing::List<py::str> arg) {
+            // arg can be used just like py::list
+        ));
+    }
+
+The resulting docstring will be ``pass_list_of_str(arg0: list[str]) -> None``.
+
+The following special types are available in ``pybind11/typing.h``:
+
+* ``py::Tuple<Args...>``
+* ``py::Dict<K, V>``
+* ``py::List<V>``
+* ``py::Set<V>``
+* ``py::Callable<Signature>``
+
+.. warning:: Just like in python, these are merely hints. They don't actually
+             enforce the types of their contents at runtime or compile time.
```

### Comparing `python_prtree-0.6.0/third/pybind11/docs/advanced/pycpp/numpy.rst` & `python_prtree-0.6.1/third/pybind11/docs/advanced/pycpp/numpy.rst`

 * *Files 2% similar despite different names*

```diff
@@ -83,15 +83,15 @@
     py::class_<Matrix>(m, "Matrix", py::buffer_protocol())
         .def(py::init([](py::buffer b) {
             typedef Eigen::Stride<Eigen::Dynamic, Eigen::Dynamic> Strides;
 
             /* Request a buffer descriptor from Python */
             py::buffer_info info = b.request();
 
-            /* Some sanity checks ... */
+            /* Some basic validation checks ... */
             if (info.format != py::format_descriptor<Scalar>::format())
                 throw std::runtime_error("Incompatible format: expected a double array!");
 
             if (info.ndim != 2)
                 throw std::runtime_error("Incompatible buffer dimension!");
 
             auto strides = Strides(
@@ -391,35 +391,31 @@
 
     The file :file:`tests/test_numpy_array.cpp` contains additional examples
     demonstrating the use of this feature.
 
 Ellipsis
 ========
 
-Python 3 provides a convenient ``...`` ellipsis notation that is often used to
+Python provides a convenient ``...`` ellipsis notation that is often used to
 slice multidimensional arrays. For instance, the following snippet extracts the
 middle dimensions of a tensor with the first and last index set to zero.
-In Python 2, the syntactic sugar ``...`` is not available, but the singleton
-``Ellipsis`` (of type ``ellipsis``) can still be used directly.
 
 .. code-block:: python
 
    a = ...  # a NumPy array
    b = a[0, ..., 0]
 
 The function ``py::ellipsis()`` function can be used to perform the same
 operation on the C++ side:
 
 .. code-block:: cpp
 
    py::array a = /* A NumPy array */;
    py::array b = a[py::make_tuple(0, py::ellipsis(), 0)];
 
-.. versionchanged:: 2.6
-   ``py::ellipsis()`` is now also available in Python 2.
 
 Memory view
 ===========
 
 For a case when we simply want to provide a direct accessor to C/C++ buffer
 without a concrete class object, we can return a ``memoryview`` object. Suppose
 we wish to expose a ``memoryview`` for 2x4 uint8_t array, we can do the
@@ -433,15 +429,15 @@
     };
     m.def("get_memoryview2d", []() {
         return py::memoryview::from_buffer(
             buffer,                                    // buffer pointer
             { 2, 4 },                                  // shape (rows, cols)
             { sizeof(uint8_t) * 4, sizeof(uint8_t) }   // strides in bytes
         );
-    })
+    });
 
 This approach is meant for providing a ``memoryview`` for a C/C++ buffer not
 managed by Python. The user is responsible for managing the lifetime of the
 buffer. Using a ``memoryview`` created in this way after deleting the buffer in
 C++ side results in undefined behavior.
 
 We can also use ``memoryview::from_memory`` for a simple 1D contiguous buffer:
@@ -449,15 +445,11 @@
 .. code-block:: cpp
 
     m.def("get_memoryview1d", []() {
         return py::memoryview::from_memory(
             buffer,               // buffer pointer
             sizeof(uint8_t) * 8   // buffer size
         );
-    })
-
-.. note::
-
-    ``memoryview::from_memory`` is not available in Python 2.
+    });
 
 .. versionchanged:: 2.6
     ``memoryview::from_memory`` added.
```

### Comparing `python_prtree-0.6.0/third/pybind11/docs/advanced/pycpp/object.rst` & `python_prtree-0.6.1/third/pybind11/docs/advanced/pycpp/object.rst`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/docs/advanced/pycpp/utilities.rst` & `python_prtree-0.6.1/third/pybind11/docs/advanced/pycpp/utilities.rst`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/docs/advanced/smart_ptrs.rst` & `python_prtree-0.6.1/third/pybind11/docs/advanced/smart_ptrs.rst`

 * *Files 2% similar despite different names*

```diff
@@ -153,15 +153,15 @@
 
 .. code-block:: cpp
 
     // Always needed for custom holder types
     PYBIND11_DECLARE_HOLDER_TYPE(T, SmartPtr<T>);
 
     // Only needed if the type's `.get()` goes by another name
-    namespace pybind11 { namespace detail {
+    namespace PYBIND11_NAMESPACE { namespace detail {
         template <typename T>
         struct holder_helper<SmartPtr<T>> { // <-- specialization
             static const T *get(const SmartPtr<T> &p) { return p.getPointer(); }
         };
     }}
 
 The above specialization informs pybind11 that the custom ``SmartPtr`` class
```

### Comparing `python_prtree-0.6.0/third/pybind11/docs/basics.rst` & `python_prtree-0.6.1/third/pybind11/docs/basics.rst`

 * *Files 5% similar despite different names*

```diff
@@ -28,16 +28,15 @@
    make check -j 4
 
 The last line will both compile and run the tests.
 
 Windows
 -------
 
-On Windows, only **Visual Studio 2015** and newer are supported since pybind11 relies
-on various C++11 language features that break older versions of Visual Studio.
+On Windows, only **Visual Studio 2017** and newer are supported.
 
 .. Note::
 
     To use the C++17 in Visual Studio 2017 (MSVC 14.1), pybind11 requires the flag
     ``/permissive-`` to be passed to the compiler `to enforce standard conformance`_. When
     building with Visual Studio 2019, this is not strictly necessary, but still advised.
 
@@ -162,20 +161,20 @@
 imported to Python. Assuming that the compiled module is located in the
 current directory, the following interactive Python session shows how to
 load and execute the example:
 
 .. code-block:: pycon
 
     $ python
-    Python 2.7.10 (default, Aug 22 2015, 20:33:39)
-    [GCC 4.2.1 Compatible Apple LLVM 7.0.0 (clang-700.0.59.1)] on darwin
+    Python 3.9.10 (main, Jan 15 2022, 11:48:04)
+    [Clang 13.0.0 (clang-1300.0.29.3)] on darwin
     Type "help", "copyright", "credits" or "license" for more information.
     >>> import example
     >>> example.add(1, 2)
-    3L
+    3
     >>>
 
 .. _keyword_args:
 
 Keyword arguments
 =================
```

### Comparing `python_prtree-0.6.0/third/pybind11/docs/benchmark.rst` & `python_prtree-0.6.1/third/pybind11/docs/benchmark.rst`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/docs/changelog.rst` & `python_prtree-0.6.1/third/pybind11/docs/changelog.rst`

 * *Files 8% similar despite different names*

```diff
@@ -5,73 +5,752 @@
 
 Starting with version 1.8.0, pybind11 releases use a `semantic versioning
 <http://semver.org>`_ policy.
 
 Changes will be added here periodically from the "Suggested changelog entry"
 block in pull request descriptions.
 
+
 IN DEVELOPMENT
 --------------
 
+Changes will be summarized here periodically.
+
+Version 2.12.0 (March 27, 2025)
+-------------------------------
+
+New Features:
+
+* ``pybind11`` now supports compiling for
+  `NumPy 2 <https://numpy.org/devdocs/numpy_2_0_migration_guide.html>`_. Most
+  code shouldn't change (see :ref:`upgrade-guide-2.12` for details). However,
+  if you experience issues you can define ``PYBIND11_NUMPY_1_ONLY`` to disable
+  the new support for now, but this will be removed in the future.
+  `#5050 <https://github.com/pybind/pybind11/pull/5050>`_
+
+* ``pybind11/gil_safe_call_once.h`` was added (it needs to be included
+  explicitly). The primary use case is GIL-safe initialization of C++
+  ``static`` variables.
+  `#4877 <https://github.com/pybind/pybind11/pull/4877>`_
+
+* Support move-only iterators in ``py::make_iterator``,
+  ``py::make_key_iterator``, ``py::make_value_iterator``.
+  `#4834 <https://github.com/pybind/pybind11/pull/4834>`_
+
+* Two simple ``py::set_error()`` functions were added and the documentation was
+  updated accordingly. In particular, ``py::exception<>::operator()`` was
+  deprecated (use one of the new functions instead). The documentation for
+  ``py::exception<>`` was further updated to not suggest code that may result
+  in undefined behavior.
+  `#4772 <https://github.com/pybind/pybind11/pull/4772>`_
+
+Bug fixes:
+
+* Removes potential for Undefined Behavior during process teardown.
+  `#4897 <https://github.com/pybind/pybind11/pull/4897>`_
+
+* Improve compatibility with the nvcc compiler (especially CUDA 12.1/12.2).
+  `#4893 <https://github.com/pybind/pybind11/pull/4893>`_
+
+* ``pybind11/numpy.h`` now imports NumPy's ``multiarray`` and ``_internal``
+  submodules with paths depending on the installed version of NumPy (for
+  compatibility with NumPy 2).
+  `#4857 <https://github.com/pybind/pybind11/pull/4857>`_
+
+* Builtins collections names in docstrings are now consistently rendered in
+  lowercase (list, set, dict, tuple), in accordance with PEP 585.
+  `#4833 <https://github.com/pybind/pybind11/pull/4833>`_
+
+* Added ``py::typing::Iterator<T>``, ``py::typing::Iterable<T>``.
+  `#4832 <https://github.com/pybind/pybind11/pull/4832>`_
+
+* Render ``py::function`` as ``Callable`` in docstring.
+  `#4829 <https://github.com/pybind/pybind11/pull/4829>`_
+
+* Also bump ``PYBIND11_INTERNALS_VERSION`` for MSVC, which unlocks two new
+  features without creating additional incompatibilities.
+  `#4819 <https://github.com/pybind/pybind11/pull/4819>`_
+
+* Guard against crashes/corruptions caused by modules built with different MSVC
+  versions.
+  `#4779 <https://github.com/pybind/pybind11/pull/4779>`_
+
+* A long-standing bug in the handling of Python multiple inheritance was fixed.
+  See PR #4762 for the rather complex details.
+  `#4762 <https://github.com/pybind/pybind11/pull/4762>`_
+
+* Fix ``bind_map`` with ``using`` declarations.
+  `#4952 <https://github.com/pybind/pybind11/pull/4952>`_
+
+* Qualify ``py::detail::concat`` usage to avoid ADL selecting one from
+  somewhere else, such as modernjson's concat.
+  `#4955 <https://github.com/pybind/pybind11/pull/4955>`_
+
+* Use new PyCode API on Python 3.12+.
+  `#4916 <https://github.com/pybind/pybind11/pull/4916>`_
+
+* Minor cleanup from warnings reported by Clazy.
+  `#4988 <https://github.com/pybind/pybind11/pull/4988>`_
+
+* Remove typing and duplicate ``class_`` for ``KeysView``/``ValuesView``/``ItemsView``.
+  `#4985 <https://github.com/pybind/pybind11/pull/4985>`_
+
+* Use ``PyObject_VisitManagedDict()`` and ``PyObject_ClearManagedDict()`` on Python 3.13 and newer.
+  `#4973 <https://github.com/pybind/pybind11/pull/4973>`_
+
+* Update ``make_static_property_type()`` to make it compatible with Python 3.13.
+  `#4971 <https://github.com/pybind/pybind11/pull/4971>`_
+
+.. fix(types)
+
+* Render typed iterators for ``make_iterator``, ``make_key_iterator``,
+  ``make_value_iterator``.
+  `#4876 <https://github.com/pybind/pybind11/pull/4876>`_
+
+* Add several missing type name specializations.
+  `#5073 <https://github.com/pybind/pybind11/pull/5073>`_
+
+* Change docstring render for ``py::buffer``, ``py::sequence`` and
+  ``py::handle`` (to ``Buffer``, ``Sequence``, ``Any``).
+  `#4831 <https://github.com/pybind/pybind11/pull/4831>`_
+
+* Fixed ``base_enum.__str__`` docstring.
+  `#4827 <https://github.com/pybind/pybind11/pull/4827>`_
+
+* Enforce single line docstring signatures.
+  `#4735 <https://github.com/pybind/pybind11/pull/4735>`_
+
+* Special 'typed' wrappers now available in ``typing.h`` to annotate tuple, dict,
+  list, set, and function.
+  `#4259 <https://github.com/pybind/pybind11/pull/4259>`_
+
+* Create ``handle_type_name`` specialization to type-hint variable length tuples.
+  `#5051 <https://github.com/pybind/pybind11/pull/5051>`_
+
+.. fix(build)
+
+* Setting ``PYBIND11_FINDPYTHON`` to OFF will force the old FindPythonLibs mechanism to be used.
+  `#5042 <https://github.com/pybind/pybind11/pull/5042>`_
+
+* Skip empty ``PYBIND11_PYTHON_EXECUTABLE_LAST`` for the first cmake run.
+  `#4856 <https://github.com/pybind/pybind11/pull/4856>`_
+
+* Fix FindPython mode exports & avoid ``pkg_resources`` if
+  ``importlib.metadata`` available.
+  `#4941 <https://github.com/pybind/pybind11/pull/4941>`_
+
+*  ``Python_ADDITIONAL_VERSIONS`` (classic search) now includes 3.12.
+  `#4909 <https://github.com/pybind/pybind11/pull/4909>`_
+
+* ``pybind11.pc`` is now relocatable by default as long as install destinations
+  are not absolute paths.
+  `#4830 <https://github.com/pybind/pybind11/pull/4830>`_
+
+* Correctly detect CMake FindPython removal when used as a subdirectory.
+  `#4806 <https://github.com/pybind/pybind11/pull/4806>`_
+
+* Don't require the libs component on CMake 3.18+ when using
+  PYBIND11_FINDPYTHON (fixes manylinux builds).
+  `#4805 <https://github.com/pybind/pybind11/pull/4805>`_
+
+* ``pybind11_strip`` is no longer automatically applied when
+  ``CMAKE_BUILD_TYPE`` is unset.
+  `#4780 <https://github.com/pybind/pybind11/pull/4780>`_
+
+* Support ``DEBUG_POSFIX`` correctly for debug builds.
+  `#4761 <https://github.com/pybind/pybind11/pull/4761>`_
+
+* Hardcode lto/thin lto for Emscripten cross-compiles.
+  `#4642 <https://github.com/pybind/pybind11/pull/4642>`_
+
+* Upgrade maximum supported CMake version to 3.27 to fix CMP0148 warnings.
+  `#4786 <https://github.com/pybind/pybind11/pull/4786>`_
+
+Documentation:
+
+* Small fix to grammar in ``functions.rst``.
+  `#4791 <https://github.com/pybind/pybind11/pull/4791>`_
+
+* Remove upper bound in example pyproject.toml for setuptools.
+  `#4774 <https://github.com/pybind/pybind11/pull/4774>`_
+
+CI:
+
+* CI: Update NVHPC to 23.5 and Ubuntu 20.04.
+  `#4764 <https://github.com/pybind/pybind11/pull/4764>`_
+
+* Test on PyPy 3.10.
+  `#4714 <https://github.com/pybind/pybind11/pull/4714>`_
+
+Other:
+
+* Use Ruff formatter instead of Black.
+  `#4912 <https://github.com/pybind/pybind11/pull/4912>`_
+
+* An ``assert()`` was added to help Coverty avoid generating a false positive.
+  `#4817 <https://github.com/pybind/pybind11/pull/4817>`_
+
+
+Version 2.11.1 (July 17, 2023)
+------------------------------
+
+Changes:
+
+* ``PYBIND11_NO_ASSERT_GIL_HELD_INCREF_DECREF`` is now provided as an option
+  for disabling the default-on ``PyGILState_Check()``'s in
+  ``pybind11::handle``'s ``inc_ref()`` & ``dec_ref()``.
+  `#4753 <https://github.com/pybind/pybind11/pull/4753>`_
+
+* ``PYBIND11_ASSERT_GIL_HELD_INCREF_DECREF`` was disabled for PyPy in general
+  (not just PyPy Windows).
+  `#4751 <https://github.com/pybind/pybind11/pull/4751>`_
+
+
+Version 2.11.0 (July 14, 2023)
+------------------------------
+
+New features:
+
+* The newly added ``pybind11::detail::is_move_constructible`` trait can be
+  specialized for cases in which ``std::is_move_constructible`` does not work
+  as needed. This is very similar to the long-established
+  ``pybind11::detail::is_copy_constructible``.
+  `#4631 <https://github.com/pybind/pybind11/pull/4631>`_
+
+* Introduce ``recursive_container_traits``.
+  `#4623 <https://github.com/pybind/pybind11/pull/4623>`_
+
+* ``pybind11/type_caster_pyobject_ptr.h`` was added to support automatic
+  wrapping of APIs that make use of ``PyObject *``. This header needs to
+  included explicitly (i.e. it is not included implicitly
+  with ``pybind/pybind11.h``).
+  `#4601 <https://github.com/pybind/pybind11/pull/4601>`_
+
+* ``format_descriptor<>`` & ``npy_format_descriptor<>`` ``PyObject *``
+  specializations were added. The latter enables ``py::array_t<PyObject *>``
+  to/from-python conversions.
+  `#4674 <https://github.com/pybind/pybind11/pull/4674>`_
+
+* ``buffer_info`` gained an ``item_type_is_equivalent_to<T>()`` member
+  function.
+  `#4674 <https://github.com/pybind/pybind11/pull/4674>`_
+
+* The ``capsule`` API gained a user-friendly constructor
+  (``py::capsule(ptr, "name", dtor)``).
+  `#4720 <https://github.com/pybind/pybind11/pull/4720>`_
+
+Changes:
+
+* ``PyGILState_Check()``'s in ``pybind11::handle``'s ``inc_ref()`` &
+  ``dec_ref()`` are now enabled by default again.
+  `#4246 <https://github.com/pybind/pybind11/pull/4246>`_
+
+* ``py::initialize_interpreter()`` using ``PyConfig_InitPythonConfig()``
+  instead of ``PyConfig_InitIsolatedConfig()``, to obtain complete
+  ``sys.path``.
+  `#4473 <https://github.com/pybind/pybind11/pull/4473>`_
+
+* Cast errors now always include Python type information, even if
+  ``PYBIND11_DETAILED_ERROR_MESSAGES`` is not defined. This increases binary
+  sizes slightly (~1.5%) but the error messages are much more informative.
+  `#4463 <https://github.com/pybind/pybind11/pull/4463>`_
+
+* The docstring generation for the ``std::array``-list caster was fixed.
+  Previously, signatures included the size of the list in a non-standard,
+  non-spec compliant way. The new format conforms to PEP 593.
+  **Tooling for processing the docstrings may need to be updated accordingly.**
+  `#4679 <https://github.com/pybind/pybind11/pull/4679>`_
+
+* Setter return values (which are inaccessible for all practical purposes) are
+  no longer converted to Python (only to be discarded).
+  `#4621 <https://github.com/pybind/pybind11/pull/4621>`_
+
+* Allow lambda specified to function definition to be ``noexcept(true)``
+  in C++17.
+  `#4593 <https://github.com/pybind/pybind11/pull/4593>`_
+
+* Get rid of recursive template instantiations for concatenating type
+  signatures on C++17 and higher.
+  `#4587 <https://github.com/pybind/pybind11/pull/4587>`_
+
+* Compatibility with Python 3.12 (beta). Note that the minimum pybind11
+  ABI version for Python 3.12 is version 5. (The default ABI version
+  for Python versions up to and including 3.11 is still version 4.).
+  `#4570 <https://github.com/pybind/pybind11/pull/4570>`_
+
+* With ``PYBIND11_INTERNALS_VERSION 5`` (default for Python 3.12+), MSVC builds
+  use ``std::hash<std::type_index>`` and ``std::equal_to<std::type_index>``
+  instead of string-based type comparisons. This resolves issues when binding
+  types defined in the unnamed namespace.
+  `#4319 <https://github.com/pybind/pybind11/pull/4319>`_
+
+* Python exception ``__notes__`` (introduced with Python 3.11) are now added to
+  the ``error_already_set::what()`` output.
+  `#4678 <https://github.com/pybind/pybind11/pull/4678>`_
+
+Build system improvements:
+
+* CMake 3.27 support was added, CMake 3.4 support was dropped.
+  FindPython will be used if ``FindPythonInterp`` is not present.
+  `#4719 <https://github.com/pybind/pybind11/pull/4719>`_
+
+* Update clang-tidy to 15 in CI.
+  `#4387 <https://github.com/pybind/pybind11/pull/4387>`_
+
+* Moved the linting framework over to Ruff.
+  `#4483 <https://github.com/pybind/pybind11/pull/4483>`_
+
+* Skip ``lto`` checks and target generation when
+  ``CMAKE_INTERPROCEDURAL_OPTIMIZATION`` is defined.
+  `#4643 <https://github.com/pybind/pybind11/pull/4643>`_
+
+* No longer inject ``-stdlib=libc++``, not needed for modern Pythons
+  (macOS 10.9+).
+  `#4639 <https://github.com/pybind/pybind11/pull/4639>`_
+
+* PyPy 3.10 support was added, PyPy 3.7 support was dropped.
+  `#4728 <https://github.com/pybind/pybind11/pull/4728>`_
+
+* Testing with Python 3.12 beta releases was added.
+  `#4713 <https://github.com/pybind/pybind11/pull/4713>`_
+
+
+Version 2.10.4 (Mar 16, 2023)
+-----------------------------
+
+Changes:
+
+* ``python3 -m pybind11`` gained a ``--version`` option (prints the version and
+  exits).
+  `#4526 <https://github.com/pybind/pybind11/pull/4526>`_
+
+Bug Fixes:
+
+* Fix a warning when pydebug is enabled on Python 3.11.
+  `#4461 <https://github.com/pybind/pybind11/pull/4461>`_
+
+* Ensure ``gil_scoped_release`` RAII is non-copyable.
+  `#4490 <https://github.com/pybind/pybind11/pull/4490>`_
+
+* Ensure the tests dir does not show up with new versions of setuptools.
+  `#4510 <https://github.com/pybind/pybind11/pull/4510>`_
+
+* Better stacklevel for a warning in setuptools helpers.
+  `#4516 <https://github.com/pybind/pybind11/pull/4516>`_
+
+Version 2.10.3 (Jan 3, 2023)
+----------------------------
+
+Changes:
+
+* Temporarily made our GIL status assertions (added in 2.10.2) disabled by
+  default (re-enable manually by defining
+  ``PYBIND11_ASSERT_GIL_HELD_INCREF_DECREF``, will be enabled in 2.11).
+  `#4432 <https://github.com/pybind/pybind11/pull/4432>`_
+
+* Improved error messages when ``inc_ref``/``dec_ref`` are called with an
+  invalid GIL state.
+  `#4427 <https://github.com/pybind/pybind11/pull/4427>`_
+  `#4436 <https://github.com/pybind/pybind11/pull/4436>`_
+
+Bug Fixes:
+
+* Some minor touchups found by static analyzers.
+  `#4440 <https://github.com/pybind/pybind11/pull/4440>`_
+
+
+Version 2.10.2 (Dec 20, 2022)
+-----------------------------
+
+Changes:
+
+* ``scoped_interpreter`` constructor taking ``PyConfig``.
+  `#4330 <https://github.com/pybind/pybind11/pull/4330>`_
+
+* ``pybind11/eigen/tensor.h`` adds converters to and from ``Eigen::Tensor`` and
+  ``Eigen::TensorMap``.
+  `#4201 <https://github.com/pybind/pybind11/pull/4201>`_
+
+* ``PyGILState_Check()``'s  were integrated to ``pybind11::handle``
+  ``inc_ref()`` & ``dec_ref()``. The added GIL checks are guarded by
+  ``PYBIND11_ASSERT_GIL_HELD_INCREF_DECREF``, which is the default only if
+  ``NDEBUG`` is not defined. (Made non-default in 2.10.3, will be active in 2.11)
+  `#4246 <https://github.com/pybind/pybind11/pull/4246>`_
+
+* Add option for enable/disable enum members in docstring.
+  `#2768 <https://github.com/pybind/pybind11/pull/2768>`_
+
+* Fixed typing of ``KeysView``, ``ValuesView`` and ``ItemsView`` in ``bind_map``.
+  `#4353 <https://github.com/pybind/pybind11/pull/4353>`_
+
+Bug fixes:
+
+* Bug fix affecting only Python 3.6 under very specific, uncommon conditions:
+  move ``PyEval_InitThreads()`` call to the correct location.
+  `#4350 <https://github.com/pybind/pybind11/pull/4350>`_
+
+* Fix segfault bug when passing foreign native functions to functional.h.
+  `#4254 <https://github.com/pybind/pybind11/pull/4254>`_
+
+Build system improvements:
+
+* Support setting PYTHON_LIBRARIES manually for Windows ARM cross-compilation
+  (classic mode).
+  `#4406 <https://github.com/pybind/pybind11/pull/4406>`_
+
+* Extend IPO/LTO detection for ICX (a.k.a IntelLLVM) compiler.
+  `#4402 <https://github.com/pybind/pybind11/pull/4402>`_
+
+* Allow calling ``find_package(pybind11 CONFIG)`` multiple times from separate
+  directories in the same CMake project and properly link Python (new mode).
+  `#4401 <https://github.com/pybind/pybind11/pull/4401>`_
+
+* ``multiprocessing_set_spawn`` in pytest fixture for added safety.
+  `#4377 <https://github.com/pybind/pybind11/pull/4377>`_
+
+* Fixed a bug in two pybind11/tools cmake scripts causing "Unknown arguments specified" errors.
+  `#4327 <https://github.com/pybind/pybind11/pull/4327>`_
+
+
+
+Version 2.10.1 (Oct 31, 2022)
+-----------------------------
+
+This is the first version to fully support embedding the newly released Python 3.11.
+
+Changes:
+
+* Allow ``pybind11::capsule`` constructor to take null destructor pointers.
+  `#4221 <https://github.com/pybind/pybind11/pull/4221>`_
+
+* ``embed.h`` was changed so that ``PYTHONPATH`` is used also with Python 3.11
+  (established behavior).
+  `#4119 <https://github.com/pybind/pybind11/pull/4119>`_
+
+* A ``PYBIND11_SIMPLE_GIL_MANAGEMENT`` option was added (cmake, C++ define),
+  along with many additional tests in ``test_gil_scoped.py``. The option may be
+  useful to try when debugging GIL-related issues, to determine if the more
+  complex default implementation is or is not to blame. See #4216 for
+  background. WARNING: Please be careful to not create ODR violations when
+  using the option: everything that is linked together with mutual symbol
+  visibility needs to be rebuilt.
+  `#4216 <https://github.com/pybind/pybind11/pull/4216>`_
+
+* ``PYBIND11_EXPORT_EXCEPTION`` was made non-empty only under macOS. This makes
+  Linux builds safer, and enables the removal of warning suppression pragmas for
+  Windows.
+  `#4298 <https://github.com/pybind/pybind11/pull/4298>`_
+
+Bug fixes:
+
+* Fixed a bug where ``UnicodeDecodeError`` was not propagated from various
+  ``py::str`` ctors when decoding surrogate utf characters.
+  `#4294 <https://github.com/pybind/pybind11/pull/4294>`_
+
+* Revert perfect forwarding for ``make_iterator``. This broke at least one
+  valid use case. May revisit later.
+  `#4234 <https://github.com/pybind/pybind11/pull/4234>`_
+
+* Fix support for safe casts to ``void*`` (regression in 2.10.0).
+  `#4275 <https://github.com/pybind/pybind11/pull/4275>`_
+
+* Fix ``char8_t`` support (regression in 2.9).
+  `#4278 <https://github.com/pybind/pybind11/pull/4278>`_
+
+* Unicode surrogate character in Python exception message leads to process
+  termination in ``error_already_set::what()``.
+  `#4297 <https://github.com/pybind/pybind11/pull/4297>`_
+
+* Fix MSVC 2019 v.1924 & C++14 mode error for ``overload_cast``.
+  `#4188 <https://github.com/pybind/pybind11/pull/4188>`_
+
+* Make augmented assignment operators non-const for the object-api. Behavior
+  was previously broken for augmented assignment operators.
+  `#4065 <https://github.com/pybind/pybind11/pull/4065>`_
+
+* Add proper error checking to C++ bindings for Python list append and insert.
+  `#4208 <https://github.com/pybind/pybind11/pull/4208>`_
+
+* Work-around for Nvidia's CUDA nvcc compiler in versions 11.4.0 - 11.8.0.
+  `#4220 <https://github.com/pybind/pybind11/pull/4220>`_
+
+* A workaround for PyPy was added in the ``py::error_already_set``
+  implementation, related to PR `#1895 <https://github.com/pybind/pybind11/pull/1895>`_
+  released with v2.10.0.
+  `#4079 <https://github.com/pybind/pybind11/pull/4079>`_
+
+* Fixed compiler errors when C++23 ``std::forward_like`` is available.
+  `#4136 <https://github.com/pybind/pybind11/pull/4136>`_
+
+* Properly raise exceptions in contains methods (like when an object in unhashable).
+  `#4209 <https://github.com/pybind/pybind11/pull/4209>`_
+
+* Further improve another error in exception handling.
+  `#4232 <https://github.com/pybind/pybind11/pull/4232>`_
+
+* ``get_local_internals()`` was made compatible with
+  ``finalize_interpreter()``, fixing potential freezes during interpreter
+  finalization.
+  `#4192 <https://github.com/pybind/pybind11/pull/4192>`_
+
+Performance and style:
+
+* Reserve space in set and STL map casters if possible. This will prevent
+  unnecessary rehashing / resizing by knowing the number of keys ahead of time
+  for Python to C++ casting. This improvement will greatly speed up the casting
+  of large unordered maps and sets.
+  `#4194 <https://github.com/pybind/pybind11/pull/4194>`_
+
+* GIL RAII scopes are non-copyable to avoid potential bugs.
+  `#4183 <https://github.com/pybind/pybind11/pull/4183>`_
+
+* Explicitly default all relevant ctors for pytypes in the ``PYBIND11_OBJECT``
+  macros and enforce the clang-tidy checks ``modernize-use-equals-default`` in
+  macros as well.
+  `#4017 <https://github.com/pybind/pybind11/pull/4017>`_
+
+* Optimize iterator advancement in C++ bindings.
+  `#4237 <https://github.com/pybind/pybind11/pull/4237>`_
+
+* Use the modern ``PyObject_GenericGetDict`` and ``PyObject_GenericSetDict``
+  for handling dynamic attribute dictionaries.
+  `#4106 <https://github.com/pybind/pybind11/pull/4106>`_
+
+* Document that users should use ``PYBIND11_NAMESPACE`` instead of using ``pybind11`` when
+  opening namespaces. Using namespace declarations and namespace qualification
+  remain the same as ``pybind11``. This is done to ensure consistent symbol
+  visibility.
+  `#4098 <https://github.com/pybind/pybind11/pull/4098>`_
+
+* Mark ``detail::forward_like`` as constexpr.
+  `#4147 <https://github.com/pybind/pybind11/pull/4147>`_
+
+* Optimize unpacking_collector when processing ``arg_v`` arguments.
+  `#4219 <https://github.com/pybind/pybind11/pull/4219>`_
+
+* Optimize casting C++ object to ``None``.
+  `#4269 <https://github.com/pybind/pybind11/pull/4269>`_
+
+
+Build system improvements:
+
+* CMake: revert overwrite behavior, now opt-in with ``PYBIND11_PYTHONLIBS_OVERRWRITE OFF``.
+  `#4195 <https://github.com/pybind/pybind11/pull/4195>`_
+
+* Include a pkg-config file when installing pybind11, such as in the Python
+  package.
+  `#4077 <https://github.com/pybind/pybind11/pull/4077>`_
+
+* Avoid stripping debug symbols when ``CMAKE_BUILD_TYPE`` is set to ``DEBUG``
+  instead of ``Debug``.
+  `#4078 <https://github.com/pybind/pybind11/pull/4078>`_
+
+* Followup to `#3948 <https://github.com/pybind/pybind11/pull/3948>`_, fixing vcpkg again.
+  `#4123 <https://github.com/pybind/pybind11/pull/4123>`_
+
+Version 2.10.0 (Jul 15, 2022)
+-----------------------------
+
 Removed support for Python 2.7, Python 3.5, and MSVC 2015. Support for MSVC
 2017 is limited due to availability of CI runners; we highly recommend MSVC
-2019 or 2022 be used.
+2019 or 2022 be used. Initial support added for Python 3.11.
 
 New features:
 
+* ``py::anyset`` & ``py::frozenset`` were added, with copying (cast) to
+  ``std::set`` (similar to ``set``).
+  `#3901 <https://github.com/pybind/pybind11/pull/3901>`_
+
+* Support bytearray casting to string.
+  `#3707 <https://github.com/pybind/pybind11/pull/3707>`_
+
 * ``type_caster<std::monostate>`` was added. ``std::monostate`` is a tag type
   that allows ``std::variant`` to act as an optional, or allows default
   construction of a ``std::variant`` holding a non-default constructible type.
   `#3818 <https://github.com/pybind/pybind11/pull/3818>`_
 
-* Support bytearray casting to string.
-  `#3707 <https://github.com/pybind/pybind11/pull/3707>`_
+* ``pybind11::capsule::set_name`` added to mutate the name of the capsule instance.
+  `#3866 <https://github.com/pybind/pybind11/pull/3866>`_
+
+* NumPy: dtype constructor from type number added, accessors corresponding to
+  Python API ``dtype.num``, ``dtype.byteorder``, ``dtype.flags`` and
+  ``dtype.alignment`` added.
+  `#3868 <https://github.com/pybind/pybind11/pull/3868>`_
+
 
 Changes:
 
-* Python 2 support was removed completely.
+* Python 3.6 is now the minimum supported version.
   `#3688 <https://github.com/pybind/pybind11/pull/3688>`_
+  `#3719 <https://github.com/pybind/pybind11/pull/3719>`_
 
 * The minimum version for MSVC is now 2017.
   `#3722 <https://github.com/pybind/pybind11/pull/3722>`_
 
+* Fix issues with CPython 3.11 betas and add to supported test matrix.
+  `#3923 <https://github.com/pybind/pybind11/pull/3923>`_
+
+* ``error_already_set`` is now safer and more performant, especially for
+  exceptions with long tracebacks, by delaying computation.
+  `#1895 <https://github.com/pybind/pybind11/pull/1895>`_
+
 * Improve exception handling in python ``str`` bindings.
   `#3826 <https://github.com/pybind/pybind11/pull/3826>`_
 
 * The bindings for capsules now have more consistent exception handling.
   `#3825 <https://github.com/pybind/pybind11/pull/3825>`_
 
+* ``PYBIND11_OBJECT_CVT`` and ``PYBIND11_OBJECT_CVT_DEFAULT`` macro can now be
+  used to define classes in namespaces other than pybind11.
+  `#3797 <https://github.com/pybind/pybind11/pull/3797>`_
+
+* Error printing code now uses ``PYBIND11_DETAILED_ERROR_MESSAGES`` instead of
+  requiring ``NDEBUG``, allowing use with release builds if desired.
+  `#3913 <https://github.com/pybind/pybind11/pull/3913>`_
+
+* Implicit conversion of the literal ``0`` to ``pybind11::handle`` is now disabled.
+  `#4008 <https://github.com/pybind/pybind11/pull/4008>`_
+
+
+Bug fixes:
+
 * Fix exception handling when ``pybind11::weakref()`` fails.
   `#3739 <https://github.com/pybind/pybind11/pull/3739>`_
 
+* ``module_::def_submodule`` was missing proper error handling. This is fixed now.
+  `#3973 <https://github.com/pybind/pybind11/pull/3973>`_
 
-Bug fixes:
+* The behavior or ``error_already_set`` was made safer and the highly opaque
+  "Unknown internal error occurred" message was replaced with a more helpful
+  message.
+  `#3982 <https://github.com/pybind/pybind11/pull/3982>`_
+
+* ``error_already_set::what()`` now handles non-normalized exceptions correctly.
+  `#3971 <https://github.com/pybind/pybind11/pull/3971>`_
+
+* Support older C++ compilers where filesystem is not yet part of the standard
+  library and is instead included in ``std::experimental::filesystem``.
+  `#3840 <https://github.com/pybind/pybind11/pull/3840>`_
+
+* Fix ``-Wfree-nonheap-object`` warnings produced by GCC by avoiding returning
+  pointers to static objects with ``return_value_policy::take_ownership``.
+  `#3946 <https://github.com/pybind/pybind11/pull/3946>`_
+
+* Fix cast from pytype rvalue to another pytype.
+  `#3949 <https://github.com/pybind/pybind11/pull/3949>`_
+
+* Ensure proper behavior when garbage collecting classes with dynamic attributes in Python >=3.9.
+  `#4051 <https://github.com/pybind/pybind11/pull/4051>`_
+
+* A couple long-standing ``PYBIND11_NAMESPACE``
+  ``__attribute__((visibility("hidden")))`` inconsistencies are now fixed
+  (affects only unusual environments).
+  `#4043 <https://github.com/pybind/pybind11/pull/4043>`_
+
+* ``pybind11::detail::get_internals()`` is now resilient to in-flight Python
+  exceptions.
+  `#3981 <https://github.com/pybind/pybind11/pull/3981>`_
+
+* Arrays with a dimension of size 0 are now properly converted to dynamic Eigen
+  matrices (more common in NumPy 1.23).
+  `#4038 <https://github.com/pybind/pybind11/pull/4038>`_
+
+* Avoid catching unrelated errors when importing NumPy.
+  `#3974 <https://github.com/pybind/pybind11/pull/3974>`_
+
+Performance and style:
+
+* Added an accessor overload of ``(object &&key)`` to reference steal the
+  object when using python types as keys. This prevents unnecessary reference
+  count overhead for attr, dictionary, tuple, and sequence look ups. Added
+  additional regression tests. Fixed a performance bug the caused accessor
+  assignments to potentially perform unnecessary copies.
+  `#3970 <https://github.com/pybind/pybind11/pull/3970>`_
+
+* Perfect forward all args of ``make_iterator``.
+  `#3980 <https://github.com/pybind/pybind11/pull/3980>`_
+
+* Avoid potential bug in pycapsule destructor by adding an ``error_guard`` to
+  one of the dtors.
+  `#3958 <https://github.com/pybind/pybind11/pull/3958>`_
+
+* Optimize dictionary access in ``strip_padding`` for numpy.
+  `#3994 <https://github.com/pybind/pybind11/pull/3994>`_
+
+* ``stl_bind.h`` bindings now take slice args as a const-ref.
+  `#3852 <https://github.com/pybind/pybind11/pull/3852>`_
+
+* Made slice constructor more consistent, and improve performance of some
+  casters by allowing reference stealing.
+  `#3845 <https://github.com/pybind/pybind11/pull/3845>`_
+
+* Change numpy dtype from_args method to use const ref.
+  `#3878 <https://github.com/pybind/pybind11/pull/3878>`_
+
+* Follow rule of three to ensure ``PyErr_Restore`` is called only once.
+  `#3872 <https://github.com/pybind/pybind11/pull/3872>`_
+
+* Added missing perfect forwarding for ``make_iterator`` functions.
+  `#3860 <https://github.com/pybind/pybind11/pull/3860>`_
+
+* Optimize c++ to python function casting by using the rvalue caster.
+  `#3966 <https://github.com/pybind/pybind11/pull/3966>`_
+
+* Optimize Eigen sparse matrix casting by removing unnecessary temporary.
+  `#4064 <https://github.com/pybind/pybind11/pull/4064>`_
+
+* Avoid potential implicit copy/assignment constructors causing double free in
+  ``strdup_gaurd``.
+  `#3905 <https://github.com/pybind/pybind11/pull/3905>`_
+
+* Enable clang-tidy checks ``misc-definitions-in-headers``,
+  ``modernize-loop-convert``, and ``modernize-use-nullptr``.
+  `#3881 <https://github.com/pybind/pybind11/pull/3881>`_
+  `#3988 <https://github.com/pybind/pybind11/pull/3988>`_
 
-* ``PYBIND11_OBJECT_CVT`` and ``PYBIND11_OBJECT_CVT_DEFAULT`` macro can be used
-  to define classes in namespaces other than pybind11.
-  `#3797 <https://github.com/pybind/pybind11/pull/3797>`_
 
 Build system improvements:
 
+* CMake: Fix file extension on Windows with cp36 and cp37 using FindPython.
+  `#3919 <https://github.com/pybind/pybind11/pull/3919>`_
+
+* CMake: Support multiple Python targets (such as on vcpkg).
+  `#3948 <https://github.com/pybind/pybind11/pull/3948>`_
+
+* CMake: Fix issue with NVCC on Windows.
+  `#3947 <https://github.com/pybind/pybind11/pull/3947>`_
+
+* CMake: Drop the bitness check on cross compiles (like targeting WebAssembly
+  via Emscripten).
+  `#3959 <https://github.com/pybind/pybind11/pull/3959>`_
+
 * Add MSVC builds in debug mode to CI.
   `#3784 <https://github.com/pybind/pybind11/pull/3784>`_
 
 * MSVC 2022 C++20 coverage was added to GitHub Actions, including Eigen.
   `#3732 <https://github.com/pybind/pybind11/pull/3732>`_,
   `#3741 <https://github.com/pybind/pybind11/pull/3741>`_
 
-* Avoid ``setup.py <command>`` usage in internal tests.
-  `#3734 <https://github.com/pybind/pybind11/pull/3734>`_
-
 
 Backend and tidying up:
 
-* Remove idioms in code comments.  Use inclusive language.
+* New theme for the documentation.
+  `#3109 <https://github.com/pybind/pybind11/pull/3109>`_
+
+* Remove idioms in code comments.  Use more inclusive language.
   `#3809 <https://github.com/pybind/pybind11/pull/3809>`_
 
+* ``#include <iostream>`` was removed from the ``pybind11/stl.h`` header. Your
+  project may break if it has a transitive dependency on this include. The fix
+  is to "Include What You Use".
+  `#3928 <https://github.com/pybind/pybind11/pull/3928>`_
+
+* Avoid ``setup.py <command>`` usage in internal tests.
+  `#3734 <https://github.com/pybind/pybind11/pull/3734>`_
+
 
 Version 2.9.2 (Mar 29, 2022)
 ----------------------------
 
 Changes:
 
 * Enum now has an ``__index__`` method on Python <3.8 too.
@@ -915,15 +1594,15 @@
     ``import pybind11`` can now be type checked.
     `#2588 <https://github.com/pybind/pybind11/pull/2588>`_
 
 * Minimum CMake required increased to 3.4.
   `#2338 <https://github.com/pybind/pybind11/pull/2338>`_ and
   `#2370 <https://github.com/pybind/pybind11/pull/2370>`_
 
-  * Full integration with CMakes C++ standard system and compile features
+  * Full integration with CMake's C++ standard system and compile features
     replaces ``PYBIND11_CPP_STANDARD``.
 
   * Generated config file is now portable to different Python/compiler/CMake
     versions.
 
   * Virtual environments prioritized if ``PYTHON_EXECUTABLE`` is not set
     (``venv``, ``virtualenv``, and ``conda``) (similar to the new FindPython
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `python_prtree-0.6.0/third/pybind11/docs/classes.rst` & `python_prtree-0.6.1/third/pybind11/docs/classes.rst`

 * *Files 3% similar despite different names*

```diff
@@ -44,24 +44,34 @@
 
     % python
     >>> import example
     >>> p = example.Pet("Molly")
     >>> print(p)
     <example.Pet object at 0x10cd98060>
     >>> p.getName()
-    u'Molly'
+    'Molly'
     >>> p.setName("Charly")
     >>> p.getName()
-    u'Charly'
+    'Charly'
 
 .. seealso::
 
     Static member functions can be bound in the same way using
     :func:`class_::def_static`.
 
+.. note::
+
+    Binding C++ types in unnamed namespaces (also known as anonymous namespaces)
+    works reliably on many platforms, but not all. The `XFAIL_CONDITION` in
+    tests/test_unnamed_namespace_a.py encodes the currently known conditions.
+    For background see `#4319 <https://github.com/pybind/pybind11/pull/4319>`_.
+    If portability is a concern, it is therefore not recommended to bind C++
+    types in unnamed namespaces. It will be safest to manually pick unique
+    namespace names.
+
 Keyword and default arguments
 =============================
 It is possible to specify keyword and default arguments using the syntax
 discussed in the previous chapter. Refer to the sections :ref:`keyword_args`
 and :ref:`default_args` for details.
 
 Binding lambda functions
@@ -120,18 +130,18 @@
 
 This makes it possible to write
 
 .. code-block:: pycon
 
     >>> p = example.Pet("Molly")
     >>> p.name
-    u'Molly'
+    'Molly'
     >>> p.name = "Charly"
     >>> p.name
-    u'Charly'
+    'Charly'
 
 Now suppose that ``Pet::name`` was a private internal variable
 that can only be accessed via setters and getters.
 
 .. code-block:: cpp
 
     class Pet {
@@ -278,17 +288,17 @@
 Functionality-wise, both approaches are equivalent. Afterwards, instances will
 expose fields and methods of both types:
 
 .. code-block:: pycon
 
     >>> p = example.Dog("Molly")
     >>> p.name
-    u'Molly'
+    'Molly'
     >>> p.bark()
-    u'woof!'
+    'woof!'
 
 The C++ classes defined above are regular non-polymorphic types with an
 inheritance relationship. This is reflected in Python:
 
 .. code-block:: cpp
 
     // Return a base pointer to a derived instance
@@ -328,15 +338,15 @@
 
 .. code-block:: pycon
 
     >>> p = example.pet_store2()
     >>> type(p)
     PolymorphicDog  # automatically downcast
     >>> p.bark()
-    u'woof!'
+    'woof!'
 
 Given a pointer to a polymorphic base, pybind11 performs automatic downcasting
 to the actual derived type. Note that this goes beyond the usual situation in
 C++: we don't just get access to the virtual functions of the base, we get the
 concrete derived type including functions and attributes that the base type may
 not even be aware of.
 
@@ -430,16 +440,15 @@
     template <typename... Args>
     using overload_cast_ = pybind11::detail::overload_cast_impl<Args...>;
 
     py::class_<Pet>(m, "Pet")
         .def("set", overload_cast_<int>()(&Pet::set), "Set the pet's age")
         .def("set", overload_cast_<const std::string &>()(&Pet::set), "Set the pet's name");
 
-.. [#cpp14] A compiler which supports the ``-std=c++14`` flag
-            or Visual Studio 2015 Update 2 and newer.
+.. [#cpp14] A compiler which supports the ``-std=c++14`` flag.
 
 .. note::
 
     To define multiple overloaded constructors, simply declare one after the
     other using the ``.def(py::init<...>())`` syntax. The existing machinery
     for specifying keyword and default arguments also works.
 
@@ -479,15 +488,15 @@
         .def_readwrite("attr", &Pet::attr);
 
     py::enum_<Pet::Kind>(pet, "Kind")
         .value("Dog", Pet::Kind::Dog)
         .value("Cat", Pet::Kind::Cat)
         .export_values();
 
-    py::class_<Pet::Attributes> attributes(pet, "Attributes")
+    py::class_<Pet::Attributes>(pet, "Attributes")
         .def(py::init<>())
         .def_readwrite("age", &Pet::Attributes::age);
 
 
 To ensure that the nested types ``Kind`` and ``Attributes`` are created within the scope of ``Pet``, the
 ``pet`` :class:`class_` instance must be supplied to the :class:`enum_` and :class:`class_`
 constructor. The :func:`enum_::export_values` function exports the enum entries
@@ -536,7 +545,11 @@
 
     .. code-block:: cpp
 
         py::enum_<Pet::Kind>(pet, "Kind", py::arithmetic())
            ...
 
     By default, these are omitted to conserve space.
+
+.. warning::
+
+    Contrary to Python customs, enum values from the wrappers should not be compared using ``is``, but with ``==`` (see `#1177 <https://github.com/pybind/pybind11/issues/1177>`_ for background).
```

### Comparing `python_prtree-0.6.0/third/pybind11/docs/compiling.rst` & `python_prtree-0.6.1/third/pybind11/docs/compiling.rst`

 * *Files 2% similar despite different names*

```diff
@@ -139,15 +139,15 @@
 environment, and install your wheel.
 
 Your ``pyproject.toml`` file will likely look something like this:
 
 .. code-block:: toml
 
     [build-system]
-    requires = ["setuptools>=42", "wheel", "pybind11~=2.6.1"]
+    requires = ["setuptools>=42", "pybind11>=2.6.1"]
     build-backend = "setuptools.build_meta"
 
 .. note::
 
     The main drawback to this method is that a `PEP 517`_ compliant build tool,
     such as Pip 10+, is required for this approach to work; older versions of
     Pip completely ignore this file. If you distribute binaries (called wheels
@@ -237,15 +237,15 @@
 ===================
 
 For C++ codebases that have an existing CMake-based build system, a Python
 extension module can be created with just a few lines of code:
 
 .. code-block:: cmake
 
-    cmake_minimum_required(VERSION 3.4...3.18)
+    cmake_minimum_required(VERSION 3.5...3.27)
     project(example LANGUAGES CXX)
 
     add_subdirectory(pybind11)
     pybind11_add_module(example example.cpp)
 
 This assumes that the pybind11 repository is located in a subdirectory named
 :file:`pybind11` and that the code is located in a file named :file:`example.cpp`.
@@ -257,14 +257,17 @@
 PyPI integration, can be found in the [cmake_example]_  repository.
 
 .. [cmake_example] https://github.com/pybind/cmake_example
 
 .. versionchanged:: 2.6
    CMake 3.4+ is required.
 
+.. versionchanged:: 2.11
+   CMake 3.5+ is required.
+
 Further information can be found at :doc:`cmake/index`.
 
 pybind11_add_module
 -------------------
 
 To ease the creation of Python extension modules, pybind11 provides a CMake
 function with the following signature:
@@ -413,33 +416,32 @@
 CMake 3.12+ (3.15+ recommended, 3.18.2+ ideal) added a new module called
 FindPython that had a highly improved search algorithm and modern targets
 and tools. If you use FindPython, pybind11 will detect this and use the
 existing targets instead:
 
 .. code-block:: cmake
 
-    cmake_minimum_required(VERSION 3.15...3.19)
+    cmake_minimum_required(VERSION 3.15...3.22)
     project(example LANGUAGES CXX)
 
-    find_package(Python COMPONENTS Interpreter Development REQUIRED)
+    find_package(Python 3.6 COMPONENTS Interpreter Development REQUIRED)
     find_package(pybind11 CONFIG REQUIRED)
     # or add_subdirectory(pybind11)
 
     pybind11_add_module(example example.cpp)
 
 You can also use the targets (as listed below) with FindPython. If you define
 ``PYBIND11_FINDPYTHON``, pybind11 will perform the FindPython step for you
 (mostly useful when building pybind11's own tests, or as a way to change search
 algorithms from the CMake invocation, with ``-DPYBIND11_FINDPYTHON=ON``.
 
 .. warning::
 
-    If you use FindPython2 and FindPython3 to dual-target Python, use the
-    individual targets listed below, and avoid targets that directly include
-    Python parts.
+    If you use FindPython to multi-target Python versions, use the individual
+    targets listed below, and avoid targets that directly include Python parts.
 
 There are `many ways to hint or force a discovery of a specific Python
 installation <https://cmake.org/cmake/help/latest/module/FindPython.html>`_),
 setting ``Python_ROOT_DIR`` may be the most common one (though with
 virtualenv/venv support, and Conda support, this tends to find the correct
 Python version more often than the old system did).
 
@@ -458,19 +460,16 @@
 
 Pybind11 supports modern CMake usage patterns with a set of interface targets,
 available in all modes. The targets provided are:
 
    ``pybind11::headers``
      Just the pybind11 headers and minimum compile requirements
 
-   ``pybind11::python2_no_register``
-     Quiets the warning/error when mixing C++14 or higher and Python 2
-
    ``pybind11::pybind11``
-     Python headers + ``pybind11::headers`` + ``pybind11::python2_no_register`` (Python 2 only)
+     Python headers + ``pybind11::headers``
 
    ``pybind11::python_link_helper``
      Just the "linking" part of pybind11:module
 
    ``pybind11::module``
      Everything for extension modules - ``pybind11::pybind11`` + ``Python::Module`` (FindPython CMake 3.15+) or ``pybind11::python_link_helper``
 
@@ -495,25 +494,28 @@
       Sets the correct extension (with SOABI) for a target.
 
 You can use these targets to build complex applications. For example, the
 ``add_python_module`` function is identical to:
 
 .. code-block:: cmake
 
-    cmake_minimum_required(VERSION 3.4)
+    cmake_minimum_required(VERSION 3.5...3.27)
     project(example LANGUAGES CXX)
 
     find_package(pybind11 REQUIRED)  # or add_subdirectory(pybind11)
 
     add_library(example MODULE main.cpp)
 
     target_link_libraries(example PRIVATE pybind11::module pybind11::lto pybind11::windows_extras)
 
     pybind11_extension(example)
-    pybind11_strip(example)
+    if(NOT MSVC AND NOT ${CMAKE_BUILD_TYPE} MATCHES Debug|RelWithDebInfo)
+        # Strip unnecessary sections of the binary on Linux/macOS
+        pybind11_strip(example)
+    endif()
 
     set_target_properties(example PROPERTIES CXX_VISIBILITY_PRESET "hidden"
                                              CUDA_VISIBILITY_PRESET "hidden")
 
 Instead of setting properties, you can set ``CMAKE_*`` variables to initialize these correctly.
 
 .. warning::
@@ -550,15 +552,15 @@
 target. It provides everything needed to get the interpreter running. The Python
 headers and libraries are attached to the target. Unlike ``pybind11::module``,
 there is no need to manually set any additional properties here. For more
 information about usage in C++, see :doc:`/advanced/embedding`.
 
 .. code-block:: cmake
 
-    cmake_minimum_required(VERSION 3.4...3.18)
+    cmake_minimum_required(VERSION 3.5...3.27)
     project(example LANGUAGES CXX)
 
     find_package(pybind11 REQUIRED)  # or add_subdirectory(pybind11)
 
     add_executable(example main.cpp)
     target_link_libraries(example PRIVATE pybind11::embed)
 
@@ -573,29 +575,20 @@
 On Linux, you can compile an example such as the one given in
 :ref:`simple_example` using the following command:
 
 .. code-block:: bash
 
     $ c++ -O3 -Wall -shared -std=c++11 -fPIC $(python3 -m pybind11 --includes) example.cpp -o example$(python3-config --extension-suffix)
 
-The flags given here assume that you're using Python 3. For Python 2, just
-change the executable appropriately (to ``python`` or ``python2``).
-
 The ``python3 -m pybind11 --includes`` command fetches the include paths for
 both pybind11 and Python headers. This assumes that pybind11 has been installed
 using ``pip`` or ``conda``. If it hasn't, you can also manually specify
 ``-I <path-to-pybind11>/include`` together with the Python includes path
 ``python3-config --includes``.
 
-Note that Python 2.7 modules don't use a special suffix, so you should simply
-use ``example.so`` instead of ``example$(python3-config --extension-suffix)``.
-Besides, the ``--extension-suffix`` option may or may not be available, depending
-on the distribution; in the latter case, the module extension can be manually
-set to ``.so``.
-
 On macOS: the build command is almost the same but it also requires passing
 the ``-undefined dynamic_lookup`` flag so as to ignore missing symbols when
 building the module:
 
 .. code-block:: bash
 
     $ c++ -O3 -Wall -shared -std=c++11 -undefined dynamic_lookup $(python3 -m pybind11 --includes) example.cpp -o example$(python3-config --extension-suffix)
@@ -642,7 +635,15 @@
 
 [robotpy-build]_ is a is a pure python, cross platform build tool that aims to
 simplify creation of python wheels for pybind11 projects, and provide
 cross-project dependency management. Additionally, it is able to autogenerate
 customizable pybind11-based wrappers by parsing C++ header files.
 
 .. [robotpy-build] https://robotpy-build.readthedocs.io
+
+[litgen]_ is an automatic python bindings generator with a focus on generating
+documented and discoverable bindings: bindings will nicely reproduce the documentation
+found in headers. It is is based on srcML (srcml.org), a highly scalable, multi-language
+parsing tool with a developer centric approach. The API that you want to expose to python
+must be C++14 compatible (but your implementation can use more modern constructs).
+
+.. [litgen] https://pthom.github.io/litgen
```

### Comparing `python_prtree-0.6.0/third/pybind11/docs/conf.py` & `python_prtree-0.6.1/third/pybind11/docs/conf.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,9 +1,8 @@
 #!/usr/bin/env python3
-# -*- coding: utf-8 -*-
 #
 # pybind11 documentation build configuration file, created by
 # sphinx-quickstart on Sun Oct 11 19:23:48 2015.
 #
 # This file is execfile()d with the current directory set to its
 # containing dir.
 #
@@ -32,14 +31,15 @@
 # needs_sphinx = '1.0'
 
 # Add any Sphinx extension module names here, as strings. They can be
 # extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
 # ones.
 extensions = [
     "breathe",
+    "sphinx_copybutton",
     "sphinxcontrib.rsvgconverter",
     "sphinxcontrib.moderncmakedomain",
 ]
 
 breathe_projects = {"pybind11": ".build/doxygenxml/"}
 breathe_default_project = "pybind11"
 breathe_domain_by_extension = {"h": "cpp"}
@@ -122,31 +122,15 @@
 
 
 # -- Options for HTML output ----------------------------------------------
 
 # The theme to use for HTML and HTML Help pages.  See the documentation for
 # a list of builtin themes.
 
-on_rtd = os.environ.get("READTHEDOCS", None) == "True"
-
-if not on_rtd:  # only import and set the theme if we're building docs locally
-    import sphinx_rtd_theme
-
-    html_theme = "sphinx_rtd_theme"
-    html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]
-
-    html_context = {"css_files": ["_static/theme_overrides.css"]}
-else:
-    html_context = {
-        "css_files": [
-            "//media.readthedocs.org/css/sphinx_rtd_theme.css",
-            "//media.readthedocs.org/css/readthedocs-doc-embed.css",
-            "_static/theme_overrides.css",
-        ]
-    }
+html_theme = "furo"
 
 # Theme options are theme-specific and customize the look and feel of a theme
 # further.  For a list of options available for each theme, see the
 # documentation.
 # html_theme_options = {}
 
 # Add any paths that contain custom themes here, relative to this directory.
@@ -169,14 +153,18 @@
 # html_favicon = None
 
 # Add any paths that contain custom static files (such as style sheets) here,
 # relative to this directory. They are copied after the builtin static files,
 # so a file named "default.css" will overwrite the builtin "default.css".
 html_static_path = ["_static"]
 
+html_css_files = [
+    "css/custom.css",
+]
+
 # Add any extra paths that contain custom files (such as robots.txt or
 # .htaccess) here, relative to this directory. These files are copied
 # directly to the root of the documentation.
 # html_extra_path = []
 
 # If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
 # using the given strftime format.
@@ -341,17 +329,17 @@
     if not os.path.exists(build_dir):
         os.mkdir(build_dir)
 
     try:
         subprocess.call(["doxygen", "--version"])
         retcode = subprocess.call(["doxygen"], cwd=app.confdir)
         if retcode < 0:
-            sys.stderr.write("doxygen error code: {}\n".format(-retcode))
+            sys.stderr.write(f"doxygen error code: {-retcode}\n")
     except OSError as e:
-        sys.stderr.write("doxygen execution failed: {}\n".format(e))
+        sys.stderr.write(f"doxygen execution failed: {e}\n")
 
 
 def prepare(app):
     with open(DIR.parent / "README.rst") as f:
         contents = f.read()
 
     if app.builder.name == "latex":
@@ -361,20 +349,19 @@
         # Filter out section titles for index.rst for LaTeX
         contents = re.sub(r"^(.*)\n[-~]{3,}$", r"**\1**", contents, flags=re.MULTILINE)
 
     with open(DIR / "readme.rst", "w") as f:
         f.write(contents)
 
 
-def clean_up(app, exception):
+def clean_up(app, exception):  # noqa: ARG001
     (DIR / "readme.rst").unlink()
 
 
 def setup(app):
-
     # Add hook for building doxygen xml when needed
     app.connect("builder-inited", generate_doxygen_xml)
 
     # Copy the readme in
     app.connect("builder-inited", prepare)
 
     # Clean up the generated readme
```

### Comparing `python_prtree-0.6.0/third/pybind11/docs/faq.rst` & `python_prtree-0.6.1/third/pybind11/docs/faq.rst`

 * *Files 5% similar despite different names*

```diff
@@ -4,17 +4,15 @@
 "ImportError: dynamic module does not define init function"
 ===========================================================
 
 1. Make sure that the name specified in PYBIND11_MODULE is identical to the
 filename of the extension library (without suffixes such as ``.so``).
 
 2. If the above did not fix the issue, you are likely using an incompatible
-version of Python (for instance, the extension library was compiled against
-Python 2, while the interpreter is running on top of some version of Python
-3, or vice versa).
+version of Python that does not match what you compiled with.
 
 "Symbol not found: ``__Py_ZeroStruct`` / ``_PyInstanceMethod_Type``"
 ========================================================================
 
 See the first answer.
 
 "SystemError: dynamic module not initialized properly"
@@ -143,15 +141,15 @@
 If you receive an error about excessive recursive template evaluation, try
 specifying a larger value, e.g. ``-ftemplate-depth=1024`` on GCC/Clang. The
 culprit is generally the generation of function signatures at compile time
 using C++14 template metaprogramming.
 
 .. _`faq:hidden_visibility`:
 
-"SomeClass declared with greater visibility than the type of its field SomeClass::member [-Wattributes]"
+"'SomeClass' declared with greater visibility than the type of its field 'SomeClass::member' [-Wattributes]"
 ============================================================================================================
 
 This error typically indicates that you are compiling without the required
 ``-fvisibility`` flag.  pybind11 code internally forces hidden visibility on
 all internal code, but if non-hidden (and thus *exported*) code attempts to
 include a pybind type (for example, ``py::object`` or ``py::list``) you can run
 into this warning.
@@ -218,28 +216,14 @@
 (On Visual Studio, symbols are already hidden by default, so nothing needs to
 be done there.)
 
 In addition to decreasing binary size, ``-fvisibility=hidden`` also avoids
 potential serious issues when loading multiple modules and is required for
 proper pybind operation.  See the previous FAQ entry for more details.
 
-Working with ancient Visual Studio 2008 builds on Windows
-=========================================================
-
-The official Windows distributions of Python are compiled using truly
-ancient versions of Visual Studio that lack good C++11 support. Some users
-implicitly assume that it would be impossible to load a plugin built with
-Visual Studio 2015 into a Python distribution that was compiled using Visual
-Studio 2008. However, no such issue exists: it's perfectly legitimate to
-interface DLLs that are built with different compilers and/or C libraries.
-Common gotchas to watch out for involve not ``free()``-ing memory region
-that that were ``malloc()``-ed in another shared library, using data
-structures with incompatible ABIs, and so on. pybind11 is very careful not
-to make these types of mistakes.
-
 How can I properly handle Ctrl-C in long-running functions?
 ===========================================================
 
 Ctrl-C is received by the Python interpreter, and holds it until the GIL
 is released, so a long-running function won't be interrupted.
 
 To interrupt from inside your function, you can use the ``PyErr_CheckSignals()``
@@ -285,46 +269,27 @@
 provided by CMake for Python version detection are modified by pybind11 due to
 unreliability and limitations that make them unsuitable for pybind11's needs.
 Instead pybind11 provides its own, more reliable Python detection CMake code.
 Conflicts can arise, however, when using pybind11 in a project that *also* uses
 the CMake Python detection in a system with several Python versions installed.
 
 This difference may cause inconsistencies and errors if *both* mechanisms are
-used in the same project. Consider the following CMake code executed in a
-system with Python 2.7 and 3.x installed:
-
-.. code-block:: cmake
-
-    find_package(PythonInterp)
-    find_package(PythonLibs)
-    find_package(pybind11)
-
-It will detect Python 2.7 and pybind11 will pick it as well.
-
-In contrast this code:
-
-.. code-block:: cmake
-
-    find_package(pybind11)
-    find_package(PythonInterp)
-    find_package(PythonLibs)
-
-will detect Python 3.x for pybind11 and may crash on
-``find_package(PythonLibs)`` afterwards.
+used in the same project.
 
 There are three possible solutions:
 
 1. Avoid using ``find_package(PythonInterp)`` and ``find_package(PythonLibs)``
    from CMake and rely on pybind11 in detecting Python version. If this is not
    possible, the CMake machinery should be called *before* including pybind11.
 2. Set ``PYBIND11_FINDPYTHON`` to ``True`` or use ``find_package(Python
    COMPONENTS Interpreter Development)`` on modern CMake (3.12+, 3.15+ better,
    3.18.2+ best). Pybind11 in these cases uses the new CMake FindPython instead
    of the old, deprecated search tools, and these modules are much better at
-   finding the correct Python.
+   finding the correct Python. If FindPythonLibs/Interp are not available
+   (CMake 3.27+), then this will be ignored and FindPython will be used.
 3. Set ``PYBIND11_NOPYTHON`` to ``TRUE``. Pybind11 will not search for Python.
    However, you will have to use the target-based system, and do more setup
    yourself, because it does not know about or include things that depend on
    Python, like ``pybind11_add_module``. This might be ideal for integrating
    into an existing system, like scikit-build's Python helpers.
 
 How to cite this project?
```

### Comparing `python_prtree-0.6.0/third/pybind11/docs/index.rst` & `python_prtree-0.6.1/third/pybind11/docs/index.rst`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/docs/installing.rst` & `python_prtree-0.6.1/third/pybind11/docs/installing.rst`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/docs/limitations.rst` & `python_prtree-0.6.1/third/pybind11/docs/limitations.rst`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/docs/pybind11_vs_boost_python1.png` & `python_prtree-0.6.1/third/pybind11/docs/pybind11_vs_boost_python1.png`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/docs/pybind11_vs_boost_python1.svg` & `python_prtree-0.6.1/third/pybind11/docs/pybind11_vs_boost_python1.svg`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/docs/pybind11_vs_boost_python2.png` & `python_prtree-0.6.1/third/pybind11/docs/pybind11_vs_boost_python2.png`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/docs/pybind11_vs_boost_python2.svg` & `python_prtree-0.6.1/third/pybind11/docs/pybind11_vs_boost_python2.svg`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/docs/reference.rst` & `python_prtree-0.6.1/third/pybind11/docs/reference.rst`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/docs/upgrade.rst` & `python_prtree-0.6.1/third/pybind11/docs/upgrade.rst`

 * *Files 4% similar despite different names*

```diff
@@ -4,14 +4,56 @@
 This is a companion guide to the :doc:`changelog`. While the changelog briefly
 lists all of the new features, improvements and bug fixes, this upgrade guide
 focuses only the subset which directly impacts your experience when upgrading
 to a new version. But it goes into more detail. This includes things like
 deprecated APIs and their replacements, build system changes, general code
 modernization and other useful information.
 
+.. _upgrade-guide-2.12:
+
+v2.12
+=====
+
+NumPy support has been upgraded to support the 2.x series too. The two relevant
+changes are that:
+
+* ``dtype.flags()`` is now a ``uint64`` and ``dtype.alignment()`` an
+  ``ssize_t`` (and NumPy may return an larger than integer value for
+  ``itemsize()`` in NumPy 2.x).
+
+* The long deprecated NumPy function ``PyArray_GetArrayParamsFromObject``
+  function is not available anymore.
+
+Due to NumPy changes, you may experience difficulties updating to NumPy 2.
+Please see the [NumPy 2 migration guide](https://numpy.org/devdocs/numpy_2_0_migration_guide.html) for details.
+For example, a more direct change could be that the default integer ``"int_"``
+(and ``"uint"``) is now ``ssize_t`` and not ``long`` (affects 64bit windows).
+
+If you want to only support NumPy 1.x for now and are having problems due to
+the two internal changes listed above, you can define
+``PYBIND11_NUMPY_1_ONLY`` to disable the new support for now. Make sure you
+define this on all pybind11 compile units, since it could be a source of ODR
+violations if used inconsistently. This option will be removed in the future,
+so adapting your code is highly recommended.
+
+
+.. _upgrade-guide-2.11:
+
+v2.11
+=====
+
+* The minimum version of CMake is now 3.5. A future version will likely move to
+  requiring something like CMake 3.15. Note that CMake 3.27 is removing the
+  long-deprecated support for ``FindPythonInterp`` if you set 3.27 as the
+  minimum or maximum supported version. To prepare for that future, CMake 3.15+
+  using ``FindPython`` or setting ``PYBIND11_FINDPYTHON`` is highly recommended,
+  otherwise pybind11 will automatically switch to using ``FindPython`` if
+  ``FindPythonInterp`` is not available.
+
+
 .. _upgrade-guide-2.9:
 
 v2.9
 ====
 
 * Any usage of the recently added ``py::make_simple_namespace`` should be
   converted to using ``py::module_::import("types").attr("SimpleNamespace")``
@@ -520,15 +562,15 @@
 The relevant type caster is now built in, so it's no longer necessary to
 include a declaration of the form:
 
 .. code-block:: cpp
 
     PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
 
-Continuing to do so wont cause an error or even a deprecation warning,
+Continuing to do so won't cause an error or even a deprecation warning,
 but it's completely redundant.
 
 
 Deprecation of a few ``py::object`` APIs
 ----------------------------------------
 
 All of the old-style calls emit deprecation warnings.
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `python_prtree-0.6.0/third/pybind11/include/pybind11/attr.h` & `python_prtree-0.6.1/third/pybind11/include/pybind11/attr.h`

 * *Files 2% similar despite different names*

```diff
@@ -6,14 +6,15 @@
 
     All rights reserved. Use of this source code is governed by a
     BSD-style license that can be found in the LICENSE file.
 */
 
 #pragma once
 
+#include "detail/common.h"
 #include "cast.h"
 
 #include <functional>
 
 PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 
 /// \addtogroup annotations
@@ -21,14 +22,17 @@
 
 /// Annotation for methods
 struct is_method {
     handle class_;
     explicit is_method(const handle &c) : class_(c) {}
 };
 
+/// Annotation for setters
+struct is_setter {};
+
 /// Annotation for operators
 struct is_operator {};
 
 /// Annotation for classes that cannot be subclassed
 struct is_final {};
 
 /// Annotation for parent scope
@@ -57,15 +61,15 @@
 
 /// Annotation indicating that a class derives from another given type
 template <typename T>
 struct base {
 
     PYBIND11_DEPRECATED(
         "base<T>() was deprecated in favor of specifying 'T' as a template argument to class_")
-    base() {} // NOLINT(modernize-use-equals-default): breaks MSVC 2015 when adding an attribute
+    base() = default;
 };
 
 /// Keep patient alive while nurse lives
 template <size_t Nurse, size_t Patient>
 struct keep_alive {};
 
 /// Annotation indicating that a class is involved in a multiple inheritance relationship
@@ -78,16 +82,15 @@
 struct buffer_protocol {};
 
 /// Annotation which requests that a special metaclass is created for a type
 struct metaclass {
     handle value;
 
     PYBIND11_DEPRECATED("py::metaclass() is no longer required. It's turned on by default now.")
-    // NOLINTNEXTLINE(modernize-use-equals-default): breaks MSVC 2015 when adding an attribute
-    metaclass() {}
+    metaclass() = default;
 
     /// Override pybind11's default metaclass
     explicit metaclass(handle value) : value(value) {}
 };
 
 /// Specifies a custom callback with signature `void (PyHeapTypeObject*)` that
 /// may be used to customize the Python type.
@@ -184,16 +187,16 @@
 };
 
 /// Internal data structure which holds metadata about a bound function (signature, overloads,
 /// etc.)
 struct function_record {
     function_record()
         : is_constructor(false), is_new_style_constructor(false), is_stateless(false),
-          is_operator(false), is_method(false), has_args(false), has_kwargs(false),
-          prepend(false) {}
+          is_operator(false), is_method(false), is_setter(false), has_args(false),
+          has_kwargs(false), prepend(false) {}
 
     /// Function name
     char *name = nullptr; /* why no C++ strings? They generate heavier code.. */
 
     // User-specified documentation string
     char *doc = nullptr;
 
@@ -226,14 +229,17 @@
 
     /// True if this is an operator (__add__), etc.
     bool is_operator : 1;
 
     /// True if this is a method
     bool is_method : 1;
 
+    /// True if this is a setter
+    bool is_setter : 1;
+
     /// True if the function has a '*args' argument
     bool has_args : 1;
 
     /// True if the function has a '**kwargs' argument
     bool has_kwargs : 1;
 
     /// True if this function is to be inserted at the beginning of the overload resolution chain
@@ -341,17 +347,19 @@
                           + (default_holder ? "does not have" : "has")
                           + " a non-default holder type while its base \"" + tname + "\" "
                           + (base_info->default_holder ? "does not" : "does"));
         }
 
         bases.append((PyObject *) base_info->type);
 
-        if (base_info->type->tp_dictoffset != 0) {
-            dynamic_attr = true;
-        }
+#if PY_VERSION_HEX < 0x030B0000
+        dynamic_attr |= base_info->type->tp_dictoffset != 0;
+#else
+        dynamic_attr |= (base_info->type->tp_flags & Py_TPFLAGS_MANAGED_DICT) != 0;
+#endif
 
         if (caster) {
             base_info->implicit_casts.emplace_back(type, caster);
         }
     }
 };
 
@@ -393,15 +401,15 @@
     static void init(const doc &n, function_record *r) { r->doc = const_cast<char *>(n.value); }
 };
 
 /// Process an attribute specifying the function's docstring (provided as a C-style string)
 template <>
 struct process_attribute<const char *> : process_attribute_default<const char *> {
     static void init(const char *d, function_record *r) { r->doc = const_cast<char *>(d); }
-    static void init(const char *d, type_record *r) { r->doc = const_cast<char *>(d); }
+    static void init(const char *d, type_record *r) { r->doc = d; }
 };
 template <>
 struct process_attribute<char *> : process_attribute<const char *> {};
 
 /// Process an attribute indicating the function's return value policy
 template <>
 struct process_attribute<return_value_policy> : process_attribute_default<return_value_policy> {
@@ -420,14 +428,20 @@
 struct process_attribute<is_method> : process_attribute_default<is_method> {
     static void init(const is_method &s, function_record *r) {
         r->is_method = true;
         r->scope = s.class_;
     }
 };
 
+/// Process an attribute which indicates that this function is a setter
+template <>
+struct process_attribute<is_setter> : process_attribute_default<is_setter> {
+    static void init(const is_setter &, function_record *r) { r->is_setter = true; }
+};
+
 /// Process an attribute which indicates the parent scope of a method
 template <>
 struct process_attribute<scope> : process_attribute_default<scope> {
     static void init(const scope &s, function_record *r) { r->scope = s.value; }
 };
 
 /// Process an attribute which indicates that this function is an operator
@@ -474,15 +488,15 @@
     static void init(const arg_v &a, function_record *r) {
         if (r->is_method && r->args.empty()) {
             r->args.emplace_back(
                 "self", /*descr=*/nullptr, /*parent=*/handle(), /*convert=*/true, /*none=*/false);
         }
 
         if (!a.value) {
-#if !defined(NDEBUG)
+#if defined(PYBIND11_DETAILED_ERROR_MESSAGES)
             std::string descr("'");
             if (a.name) {
                 descr += std::string(a.name) + ": ";
             }
             descr += a.type + "'";
             if (r->is_method) {
                 if (r->name) {
@@ -495,15 +509,16 @@
                 descr += " in function '" + (std::string) r->name + "'";
             }
             pybind11_fail("arg(): could not convert default argument " + descr
                           + " into a Python object (type not registered yet?)");
 #else
             pybind11_fail("arg(): could not convert default argument "
                           "into a Python object (type not registered yet?). "
-                          "Compile in debug mode for more information.");
+                          "#define PYBIND11_DETAILED_ERROR_MESSAGES or compile in debug mode for "
+                          "more information.");
 #endif
         }
         r->args.emplace_back(a.name, a.descr, a.value.inc_ref(), !a.flag_noconvert, a.flag_none);
 
         check_kw_only_arg(a, r);
     }
 };
```

### Comparing `python_prtree-0.6.0/third/pybind11/include/pybind11/buffer_info.h` & `python_prtree-0.6.1/third/pybind11/include/pybind11/buffer_info.h`

 * *Files 12% similar despite different names*

```diff
@@ -33,14 +33,17 @@
     std::vector<ssize_t> strides(ndim, itemsize);
     for (size_t i = 1; i < ndim; ++i) {
         strides[i] = strides[i - 1] * shape[i - 1];
     }
     return strides;
 }
 
+template <typename T, typename SFINAE = void>
+struct compare_buffer_info;
+
 PYBIND11_NAMESPACE_END(detail)
 
 /// Information record describing a Python buffer object
 struct buffer_info {
     void *ptr = nullptr;          // Pointer to the underlying storage
     ssize_t itemsize = 0;         // Size of individual items in bytes
     ssize_t size = 0;             // Total number of entries
@@ -146,14 +149,25 @@
             delete m_view;
         }
     }
 
     Py_buffer *view() const { return m_view; }
     Py_buffer *&view() { return m_view; }
 
+    /* True if the buffer item type is equivalent to `T`. */
+    // To define "equivalent" by example:
+    // `buffer_info::item_type_is_equivalent_to<int>(b)` and
+    // `buffer_info::item_type_is_equivalent_to<long>(b)` may both be true
+    // on some platforms, but `int` and `unsigned` will never be equivalent.
+    // For the ground truth, please inspect `detail::compare_buffer_info<>`.
+    template <typename T>
+    bool item_type_is_equivalent_to() const {
+        return detail::compare_buffer_info<T>::compare(*this);
+    }
+
 private:
     struct private_ctr_tag {};
 
     buffer_info(private_ctr_tag,
                 void *ptr,
                 ssize_t itemsize,
                 const std::string &format,
@@ -166,17 +180,18 @@
 
     Py_buffer *m_view = nullptr;
     bool ownview = false;
 };
 
 PYBIND11_NAMESPACE_BEGIN(detail)
 
-template <typename T, typename SFINAE = void>
+template <typename T, typename SFINAE>
 struct compare_buffer_info {
     static bool compare(const buffer_info &b) {
+        // NOLINTNEXTLINE(bugprone-sizeof-expression) Needed for `PyObject *`
         return b.format == format_descriptor<T>::format() && b.itemsize == (ssize_t) sizeof(T);
     }
 };
 
 template <typename T>
 struct compare_buffer_info<T, detail::enable_if_t<std::is_integral<T>::value>> {
     static bool compare(const buffer_info &b) {
```

### Comparing `python_prtree-0.6.0/third/pybind11/include/pybind11/cast.h` & `python_prtree-0.6.1/third/pybind11/include/pybind11/cast.h`

 * *Files 6% similar despite different names*

```diff
@@ -25,31 +25,36 @@
 #include <string>
 #include <tuple>
 #include <type_traits>
 #include <utility>
 #include <vector>
 
 PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
+
+PYBIND11_WARNING_DISABLE_MSVC(4127)
+
 PYBIND11_NAMESPACE_BEGIN(detail)
 
 template <typename type, typename SFINAE = void>
 class type_caster : public type_caster_base<type> {};
 template <typename type>
 using make_caster = type_caster<intrinsic_t<type>>;
 
 // Shortcut for calling a caster's `cast_op_type` cast operator for casting a type_caster to a T
 template <typename T>
 typename make_caster<T>::template cast_op_type<T> cast_op(make_caster<T> &caster) {
-    return caster.operator typename make_caster<T>::template cast_op_type<T>();
+    using result_t = typename make_caster<T>::template cast_op_type<T>; // See PR #4893
+    return caster.operator result_t();
 }
 template <typename T>
 typename make_caster<T>::template cast_op_type<typename std::add_rvalue_reference<T>::type>
 cast_op(make_caster<T> &&caster) {
-    return std::move(caster).operator typename make_caster<T>::
-        template cast_op_type<typename std::add_rvalue_reference<T>::type>();
+    using result_t = typename make_caster<T>::template cast_op_type<
+        typename std::add_rvalue_reference<T>::type>; // See PR #4893
+    return std::move(caster).operator result_t();
 }
 
 template <typename type>
 class type_caster<std::reference_wrapper<type>> {
 private:
     using caster_t = make_caster<type>;
     caster_t subcaster;
@@ -84,15 +89,16 @@
     type value;                                                                                   \
                                                                                                   \
 public:                                                                                           \
     static constexpr auto name = py_name;                                                         \
     template <typename T_,                                                                        \
               ::pybind11::detail::enable_if_t<                                                    \
                   std::is_same<type, ::pybind11::detail::remove_cv_t<T_>>::value,                 \
-                  int> = 0>                                                                       \
+                  int>                                                                            \
+              = 0>                                                                                \
     static ::pybind11::handle cast(                                                               \
         T_ *src, ::pybind11::return_value_policy policy, ::pybind11::handle parent) {             \
         if (!src)                                                                                 \
             return ::pybind11::none().release();                                                  \
         if (policy == ::pybind11::return_value_policy::take_ownership) {                          \
             auto h = cast(std::move(*src), policy, parent);                                       \
             delete src;                                                                           \
@@ -244,15 +250,15 @@
     bool load(handle src, bool) {
         if (src && src.is_none()) {
             return true;
         }
         return false;
     }
     static handle cast(T, return_value_policy /* policy */, handle /* parent */) {
-        return none().inc_ref();
+        return none().release();
     }
     PYBIND11_TYPE_CASTER(T, const_name("None"));
 };
 
 template <>
 class type_caster<void_type> : public void_caster<void_type> {};
 
@@ -287,15 +293,15 @@
         return false;
     }
 
     static handle cast(const void *ptr, return_value_policy /* policy */, handle /* parent */) {
         if (ptr) {
             return capsule(ptr).release();
         }
-        return none().inc_ref();
+        return none().release();
     }
 
     template <typename T>
     using cast_op_type = void *&;
     explicit operator void *&() { return value; }
     static constexpr auto name = const_name("capsule");
 
@@ -317,23 +323,24 @@
             value = true;
             return true;
         }
         if (src.ptr() == Py_False) {
             value = false;
             return true;
         }
-        if (convert || (std::strcmp("numpy.bool_", Py_TYPE(src.ptr())->tp_name) == 0)) {
-            // (allow non-implicit conversion for numpy booleans)
+        if (convert || is_numpy_bool(src)) {
+            // (allow non-implicit conversion for numpy booleans), use strncmp
+            // since NumPy 1.x had an additional trailing underscore.
 
             Py_ssize_t res = -1;
             if (src.is_none()) {
                 res = 0; // None is implicitly converted to False
             }
 #if defined(PYPY_VERSION)
-            // On PyPy, check that "__bool__" (or "__nonzero__" on Python 2.7) attr exists
+            // On PyPy, check that "__bool__" attr exists
             else if (hasattr(src, PYBIND11_BOOL_ATTR)) {
                 res = PyObject_IsTrue(src.ptr());
             }
 #else
             // Alternate approach for CPython: this does the same as the above, but optimized
             // using the CPython API so as to avoid an unneeded attribute lookup.
             else if (auto *tp_as_number = src.ptr()->ob_type->tp_as_number) {
@@ -350,14 +357,23 @@
         }
         return false;
     }
     static handle cast(bool src, return_value_policy /* policy */, handle /* parent */) {
         return handle(src ? Py_True : Py_False).inc_ref();
     }
     PYBIND11_TYPE_CASTER(bool, const_name("bool"));
+
+private:
+    // Test if an object is a NumPy boolean (without fetching the type).
+    static inline bool is_numpy_bool(handle object) {
+        const char *type_name = Py_TYPE(object.ptr())->tp_name;
+        // Name changed to `numpy.bool` in NumPy 2, `numpy.bool_` is needed for 1.x support
+        return std::strcmp("numpy.bool", type_name) == 0
+               || std::strcmp("numpy.bool_", type_name) == 0;
+    }
 };
 
 // Helper class for UTF-{8,16,32} C++ stl strings:
 template <typename StringType, bool IsView = false>
 struct string_caster {
     using CharT = typename StringType::value_type;
 
@@ -375,57 +391,35 @@
                   "Unsupported char32_t size != 4");
     // wchar_t can be either 16 bits (Windows) or 32 (everywhere else)
     static_assert(!std::is_same<CharT, wchar_t>::value || sizeof(CharT) == 2 || sizeof(CharT) == 4,
                   "Unsupported wchar_t size != 2/4");
     static constexpr size_t UTF_N = 8 * sizeof(CharT);
 
     bool load(handle src, bool) {
-#if PY_MAJOR_VERSION < 3
-        object temp;
-#endif
         handle load_src = src;
         if (!src) {
             return false;
         }
         if (!PyUnicode_Check(load_src.ptr())) {
-#if PY_MAJOR_VERSION >= 3
-            return load_bytes(load_src);
-#else
-            if (std::is_same<CharT, char>::value) {
-                return load_bytes(load_src);
-            }
-
-            // The below is a guaranteed failure in Python 3 when PyUnicode_Check returns false
-            if (!PYBIND11_BYTES_CHECK(load_src.ptr()))
-                return false;
-
-            temp = reinterpret_steal<object>(PyUnicode_FromObject(load_src.ptr()));
-            if (!temp) {
-                PyErr_Clear();
-                return false;
-            }
-            load_src = temp;
-#endif
+            return load_raw(load_src);
         }
 
-#if PY_VERSION_HEX >= 0x03030000
-        // On Python >= 3.3, for UTF-8 we avoid the need for a temporary `bytes`
-        // object by using `PyUnicode_AsUTF8AndSize`.
-        if (PYBIND11_SILENCE_MSVC_C4127(UTF_N == 8)) {
+        // For UTF-8 we avoid the need for a temporary `bytes` object by using
+        // `PyUnicode_AsUTF8AndSize`.
+        if (UTF_N == 8) {
             Py_ssize_t size = -1;
             const auto *buffer
                 = reinterpret_cast<const CharT *>(PyUnicode_AsUTF8AndSize(load_src.ptr(), &size));
             if (!buffer) {
                 PyErr_Clear();
                 return false;
             }
             value = StringType(buffer, static_cast<size_t>(size));
             return true;
         }
-#endif
 
         auto utfNbytes
             = reinterpret_steal<object>(PyUnicode_AsEncodedString(load_src.ptr(),
                                                                   UTF_N == 8    ? "utf-8"
                                                                   : UTF_N == 16 ? "utf-16"
                                                                                 : "utf-32",
                                                                   nullptr));
@@ -434,15 +428,15 @@
             return false;
         }
 
         const auto *buffer
             = reinterpret_cast<const CharT *>(PYBIND11_BYTES_AS_STRING(utfNbytes.ptr()));
         size_t length = (size_t) PYBIND11_BYTES_SIZE(utfNbytes.ptr()) / sizeof(CharT);
         // Skip BOM for UTF-16/32
-        if (PYBIND11_SILENCE_MSVC_C4127(UTF_N > 8)) {
+        if (UTF_N > 8) {
             buffer++;
             length--;
         }
         value = StringType(buffer, length);
 
         // If we're loading a string_view we need to keep the encoded Python object alive:
         if (IsView) {
@@ -480,34 +474,45 @@
                                 UTF_N == 8    ? "utf-8"
                                 : UTF_N == 16 ? "utf-16"
                                               : "utf-32",
                                 nullptr);
 #endif
     }
 
-    // When loading into a std::string or char*, accept a bytes object as-is (i.e.
+    // When loading into a std::string or char*, accept a bytes/bytearray object as-is (i.e.
     // without any encoding/decoding attempt).  For other C++ char sizes this is a no-op.
     // which supports loading a unicode from a str, doesn't take this path.
     template <typename C = CharT>
-    bool load_bytes(enable_if_t<std::is_same<C, char>::value, handle> src) {
+    bool load_raw(enable_if_t<std::is_same<C, char>::value, handle> src) {
         if (PYBIND11_BYTES_CHECK(src.ptr())) {
-            // We were passed a Python 3 raw bytes; accept it into a std::string or char*
+            // We were passed raw bytes; accept it into a std::string or char*
             // without any encoding attempt.
             const char *bytes = PYBIND11_BYTES_AS_STRING(src.ptr());
-            if (bytes) {
-                value = StringType(bytes, (size_t) PYBIND11_BYTES_SIZE(src.ptr()));
-                return true;
+            if (!bytes) {
+                pybind11_fail("Unexpected PYBIND11_BYTES_AS_STRING() failure.");
             }
+            value = StringType(bytes, (size_t) PYBIND11_BYTES_SIZE(src.ptr()));
+            return true;
+        }
+        if (PyByteArray_Check(src.ptr())) {
+            // We were passed a bytearray; accept it into a std::string or char*
+            // without any encoding attempt.
+            const char *bytearray = PyByteArray_AsString(src.ptr());
+            if (!bytearray) {
+                pybind11_fail("Unexpected PyByteArray_AsString() failure.");
+            }
+            value = StringType(bytearray, (size_t) PyByteArray_Size(src.ptr()));
+            return true;
         }
 
         return false;
     }
 
     template <typename C = CharT>
-    bool load_bytes(enable_if_t<!std::is_same<C, char>::value, handle>) {
+    bool load_raw(enable_if_t<!std::is_same<C, char>::value, handle>) {
         return false;
     }
 };
 
 template <typename CharT, class Traits, class Allocator>
 struct type_caster<std::basic_string<CharT, Traits, Allocator>,
                    enable_if_t<is_std_char_type<CharT>::value>>
@@ -521,15 +526,15 @@
 #endif
 
 // Type caster for C-style strings.  We basically use a std::string type caster, but also add the
 // ability to use None as a nullptr char* (which the string caster doesn't allow).
 template <typename CharT>
 struct type_caster<CharT, enable_if_t<is_std_char_type<CharT>::value>> {
     using StringType = std::basic_string<CharT>;
-    using StringCaster = type_caster<StringType>;
+    using StringCaster = make_caster<StringType>;
     StringCaster str_caster;
     bool none = false;
     CharT one_char = 0;
 
 public:
     bool load(handle src, bool convert) {
         if (!src) {
@@ -544,15 +549,15 @@
             return true;
         }
         return str_caster.load(src, convert);
     }
 
     static handle cast(const CharT *src, return_value_policy policy, handle parent) {
         if (src == nullptr) {
-            return pybind11::none().inc_ref();
+            return pybind11::none().release();
         }
         return StringCaster::cast(StringType(src), policy, parent);
     }
 
     static handle cast(CharT src, return_value_policy policy, handle parent) {
         if (std::is_same<char, CharT>::value) {
             handle s = PyUnicode_DecodeLatin1((const char *) &src, 1, nullptr);
@@ -579,15 +584,15 @@
         }
 
         // If we're in UTF-8 mode, we have two possible failures: one for a unicode character that
         // is too high, and one for multiple unicode characters (caught later), so we need to
         // figure out how long the first encoded character is in bytes to distinguish between these
         // two errors.  We also allow want to allow unicode characters U+0080 through U+00FF, as
         // those can fit into a single char value.
-        if (PYBIND11_SILENCE_MSVC_C4127(StringCaster::UTF_N == 8) && str_len > 1 && str_len <= 4) {
+        if (StringCaster::UTF_N == 8 && str_len > 1 && str_len <= 4) {
             auto v0 = static_cast<unsigned char>(value[0]);
             // low bits only: 0-127
             // 0b110xxxxx - start of 2-byte sequence
             // 0b1110xxxx - start of 3-byte sequence
             // 0b11110xxx - start of 4-byte sequence
             size_t char0_bytes = (v0 & 0x80) == 0      ? 1
                                  : (v0 & 0xE0) == 0xC0 ? 2
@@ -605,15 +610,15 @@
                 throw value_error("Character code point not in range(0x100)");
             }
         }
 
         // UTF-16 is much easier: we can only have a surrogate pair for values above U+FFFF, thus a
         // surrogate pair with total length 2 instantly indicates a range error (but not a "your
         // string was too long" error).
-        else if (PYBIND11_SILENCE_MSVC_C4127(StringCaster::UTF_N == 16) && str_len == 2) {
+        else if (StringCaster::UTF_N == 16 && str_len == 2) {
             one_char = static_cast<CharT>(value[0]);
             if (one_char >= 0xD800 && one_char < 0xE000) {
                 throw value_error("Character code point not in range(0x10000)");
             }
         }
 
         if (str_len != 1) {
@@ -663,16 +668,17 @@
             auto h = cast(std::move(*src), policy, parent);
             delete src;
             return h;
         }
         return cast(*src, policy, parent);
     }
 
-    static constexpr auto name
-        = const_name("Tuple[") + concat(make_caster<Ts>::name...) + const_name("]");
+    static constexpr auto name = const_name("tuple[")
+                                 + ::pybind11::detail::concat(make_caster<Ts>::name...)
+                                 + const_name("]");
 
     template <typename T>
     using cast_op_type = type;
 
     explicit operator type() & { return implicit_cast(indices{}); }
     explicit operator type() && { return std::move(*this).implicit_cast(indices{}); }
 
@@ -784,16 +790,17 @@
     bool load_value(value_and_holder &&v_h) {
         if (v_h.holder_constructed()) {
             value = v_h.value_ptr();
             holder = v_h.template holder<holder_type>();
             return true;
         }
         throw cast_error("Unable to cast from non-held to held instance (T& to Holder<T>) "
-#if defined(NDEBUG)
-                         "(compile in debug mode for type information)");
+#if !defined(PYBIND11_DETAILED_ERROR_MESSAGES)
+                         "(#define PYBIND11_DETAILED_ERROR_MESSAGES or compile in debug mode for "
+                         "type information)");
 #else
                          "of type '"
                          + type_id<holder_type>() + "''");
 #endif
     }
 
     template <typename T = holder_type,
@@ -852,46 +859,93 @@
 template <typename T, bool Value = false>
 struct always_construct_holder {
     static constexpr bool value = Value;
 };
 
 /// Create a specialization for custom holder types (silently ignores std::shared_ptr)
 #define PYBIND11_DECLARE_HOLDER_TYPE(type, holder_type, ...)                                      \
-    namespace pybind11 {                                                                          \
+    PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)                                                  \
     namespace detail {                                                                            \
     template <typename type>                                                                      \
     struct always_construct_holder<holder_type> : always_construct_holder<void, ##__VA_ARGS__> {  \
     };                                                                                            \
     template <typename type>                                                                      \
     class type_caster<holder_type, enable_if_t<!is_shared_ptr<holder_type>::value>>               \
         : public type_caster_holder<type, holder_type> {};                                        \
     }                                                                                             \
-    }
+    PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
 
 // PYBIND11_DECLARE_HOLDER_TYPE holder types:
 template <typename base, typename holder>
 struct is_holder_type
     : std::is_base_of<detail::type_caster_holder<base, holder>, detail::type_caster<holder>> {};
 // Specialization for always-supported unique_ptr holders:
 template <typename base, typename deleter>
 struct is_holder_type<base, std::unique_ptr<base, deleter>> : std::true_type {};
 
+#ifdef PYBIND11_DISABLE_HANDLE_TYPE_NAME_DEFAULT_IMPLEMENTATION // See PR #4888
+
+// This leads to compilation errors if a specialization is missing.
+template <typename T>
+struct handle_type_name;
+
+#else
+
 template <typename T>
 struct handle_type_name {
     static constexpr auto name = const_name<T>();
 };
+
+#endif
+
+template <>
+struct handle_type_name<object> {
+    static constexpr auto name = const_name("object");
+};
+template <>
+struct handle_type_name<list> {
+    static constexpr auto name = const_name("list");
+};
+template <>
+struct handle_type_name<dict> {
+    static constexpr auto name = const_name("dict");
+};
+template <>
+struct handle_type_name<anyset> {
+    static constexpr auto name = const_name("Union[set, frozenset]");
+};
+template <>
+struct handle_type_name<set> {
+    static constexpr auto name = const_name("set");
+};
+template <>
+struct handle_type_name<frozenset> {
+    static constexpr auto name = const_name("frozenset");
+};
+template <>
+struct handle_type_name<str> {
+    static constexpr auto name = const_name("str");
+};
+template <>
+struct handle_type_name<tuple> {
+    static constexpr auto name = const_name("tuple");
+};
 template <>
 struct handle_type_name<bool_> {
     static constexpr auto name = const_name("bool");
 };
 template <>
 struct handle_type_name<bytes> {
     static constexpr auto name = const_name(PYBIND11_BYTES_NAME);
 };
 template <>
+struct handle_type_name<buffer> {
+    static constexpr auto name = const_name("Buffer");
+};
+template <>
 struct handle_type_name<int_> {
     static constexpr auto name = const_name("int");
 };
 template <>
 struct handle_type_name<iterable> {
     static constexpr auto name = const_name("Iterable");
 };
@@ -900,48 +954,108 @@
     static constexpr auto name = const_name("Iterator");
 };
 template <>
 struct handle_type_name<float_> {
     static constexpr auto name = const_name("float");
 };
 template <>
+struct handle_type_name<function> {
+    static constexpr auto name = const_name("Callable");
+};
+template <>
+struct handle_type_name<handle> {
+    static constexpr auto name = handle_type_name<object>::name;
+};
+template <>
 struct handle_type_name<none> {
     static constexpr auto name = const_name("None");
 };
 template <>
+struct handle_type_name<sequence> {
+    static constexpr auto name = const_name("Sequence");
+};
+template <>
+struct handle_type_name<bytearray> {
+    static constexpr auto name = const_name("bytearray");
+};
+template <>
+struct handle_type_name<memoryview> {
+    static constexpr auto name = const_name("memoryview");
+};
+template <>
+struct handle_type_name<slice> {
+    static constexpr auto name = const_name("slice");
+};
+template <>
+struct handle_type_name<type> {
+    static constexpr auto name = const_name("type");
+};
+template <>
+struct handle_type_name<capsule> {
+    static constexpr auto name = const_name("capsule");
+};
+template <>
+struct handle_type_name<ellipsis> {
+    static constexpr auto name = const_name("ellipsis");
+};
+template <>
+struct handle_type_name<weakref> {
+    static constexpr auto name = const_name("weakref");
+};
+template <>
 struct handle_type_name<args> {
     static constexpr auto name = const_name("*args");
 };
 template <>
 struct handle_type_name<kwargs> {
     static constexpr auto name = const_name("**kwargs");
 };
+template <>
+struct handle_type_name<obj_attr_accessor> {
+    static constexpr auto name = const_name<obj_attr_accessor>();
+};
+template <>
+struct handle_type_name<str_attr_accessor> {
+    static constexpr auto name = const_name<str_attr_accessor>();
+};
+template <>
+struct handle_type_name<item_accessor> {
+    static constexpr auto name = const_name<item_accessor>();
+};
+template <>
+struct handle_type_name<sequence_accessor> {
+    static constexpr auto name = const_name<sequence_accessor>();
+};
+template <>
+struct handle_type_name<list_accessor> {
+    static constexpr auto name = const_name<list_accessor>();
+};
+template <>
+struct handle_type_name<tuple_accessor> {
+    static constexpr auto name = const_name<tuple_accessor>();
+};
 
 template <typename type>
 struct pyobject_caster {
     template <typename T = type, enable_if_t<std::is_same<T, handle>::value, int> = 0>
+    pyobject_caster() : value() {}
+
+    // `type` may not be default constructible (e.g. frozenset, anyset).  Initializing `value`
+    // to a nil handle is safe since it will only be accessed if `load` succeeds.
+    template <typename T = type, enable_if_t<std::is_base_of<object, T>::value, int> = 0>
+    pyobject_caster() : value(reinterpret_steal<type>(handle())) {}
+
+    template <typename T = type, enable_if_t<std::is_same<T, handle>::value, int> = 0>
     bool load(handle src, bool /* convert */) {
         value = src;
         return static_cast<bool>(value);
     }
 
     template <typename T = type, enable_if_t<std::is_base_of<object, T>::value, int> = 0>
     bool load(handle src, bool /* convert */) {
-#if PY_MAJOR_VERSION < 3 && !defined(PYBIND11_STR_LEGACY_PERMISSIVE)
-        // For Python 2, without this implicit conversion, Python code would
-        // need to be cluttered with six.ensure_text() or similar, only to be
-        // un-cluttered later after Python 2 support is dropped.
-        if (PYBIND11_SILENCE_MSVC_C4127(std::is_same<T, str>::value) && isinstance<bytes>(src)) {
-            PyObject *str_from_bytes = PyUnicode_FromEncodedObject(src.ptr(), "utf-8", nullptr);
-            if (!str_from_bytes)
-                throw error_already_set();
-            value = reinterpret_steal<type>(str_from_bytes);
-            return true;
-        }
-#endif
         if (!isinstance<type>(src)) {
             return false;
         }
         value = reinterpret_borrow<type>(src);
         return true;
     }
 
@@ -970,26 +1084,26 @@
 struct move_always : std::false_type {};
 template <typename T>
 struct move_always<
     T,
     enable_if_t<
         all_of<move_is_plain_type<T>,
                negation<is_copy_constructible<T>>,
-               std::is_move_constructible<T>,
+               is_move_constructible<T>,
                std::is_same<decltype(std::declval<make_caster<T>>().operator T &()), T &>>::value>>
     : std::true_type {};
 template <typename T, typename SFINAE = void>
 struct move_if_unreferenced : std::false_type {};
 template <typename T>
 struct move_if_unreferenced<
     T,
     enable_if_t<
         all_of<move_is_plain_type<T>,
                negation<move_always<T>>,
-               std::is_move_constructible<T>,
+               is_move_constructible<T>,
                std::is_same<decltype(std::declval<make_caster<T>>().operator T &()), T &>>::value>>
     : std::true_type {};
 template <typename T>
 using move_never = none_of<move_always<T>, move_if_unreferenced<T>>;
 
 // Detect whether returning a `type` from a cast on type's type_caster is going to result in a
 // reference or pointer to a local variable of the type_caster.  Basically, only
@@ -1019,21 +1133,26 @@
                    : p;
     }
 };
 
 // Basic python -> C++ casting; throws if casting fails
 template <typename T, typename SFINAE>
 type_caster<T, SFINAE> &load_type(type_caster<T, SFINAE> &conv, const handle &handle) {
+    static_assert(!detail::is_pyobject<T>::value,
+                  "Internal error: type_caster should only be used for C++ types");
     if (!conv.load(handle, true)) {
-#if defined(NDEBUG)
+#if !defined(PYBIND11_DETAILED_ERROR_MESSAGES)
         throw cast_error(
-            "Unable to cast Python instance to C++ type (compile in debug mode for details)");
+            "Unable to cast Python instance of type "
+            + str(type::handle_of(handle)).cast<std::string>()
+            + " to C++ type '?' (#define "
+              "PYBIND11_DETAILED_ERROR_MESSAGES or compile in debug mode for details)");
 #else
         throw cast_error("Unable to cast Python instance of type "
-                         + (std::string) str(type::handle_of(handle)) + " to C++ type '"
+                         + str(type::handle_of(handle)).cast<std::string>() + " to C++ type '"
                          + type_id<T>() + "'");
 #endif
     }
     return conv;
 }
 // Wrapper around the above that also constructs and returns a type_caster
 template <typename T>
@@ -1042,28 +1161,60 @@
     load_type(conv, handle);
     return conv;
 }
 
 PYBIND11_NAMESPACE_END(detail)
 
 // pytype -> C++ type
-template <typename T, detail::enable_if_t<!detail::is_pyobject<T>::value, int> = 0>
+template <typename T,
+          detail::enable_if_t<!detail::is_pyobject<T>::value
+                                  && !detail::is_same_ignoring_cvref<T, PyObject *>::value,
+                              int>
+          = 0>
 T cast(const handle &handle) {
     using namespace detail;
     static_assert(!cast_is_temporary_value_reference<T>::value,
                   "Unable to cast type to reference: value is local to type caster");
     return cast_op<T>(load_type<T>(handle));
 }
 
 // pytype -> pytype (calls converting constructor)
 template <typename T, detail::enable_if_t<detail::is_pyobject<T>::value, int> = 0>
 T cast(const handle &handle) {
     return T(reinterpret_borrow<object>(handle));
 }
 
+// Note that `cast<PyObject *>(obj)` increments the reference count of `obj`.
+// This is necessary for the case that `obj` is a temporary, and could
+// not possibly be different, given
+// 1. the established convention that the passed `handle` is borrowed, and
+// 2. we don't want to force all generic code using `cast<T>()` to special-case
+//    handling of `T` = `PyObject *` (to increment the reference count there).
+// It is the responsibility of the caller to ensure that the reference count
+// is decremented.
+template <typename T,
+          typename Handle,
+          detail::enable_if_t<detail::is_same_ignoring_cvref<T, PyObject *>::value
+                                  && detail::is_same_ignoring_cvref<Handle, handle>::value,
+                              int>
+          = 0>
+T cast(Handle &&handle) {
+    return handle.inc_ref().ptr();
+}
+// To optimize way an inc_ref/dec_ref cycle:
+template <typename T,
+          typename Object,
+          detail::enable_if_t<detail::is_same_ignoring_cvref<T, PyObject *>::value
+                                  && detail::is_same_ignoring_cvref<Object, object>::value,
+                              int>
+          = 0>
+T cast(Object &&obj) {
+    return obj.release().ptr();
+}
+
 // C++ type -> py::object
 template <typename T, detail::enable_if_t<!detail::is_pyobject<T>::value, int> = 0>
 object cast(T &&value,
             return_value_policy policy = return_value_policy::automatic_reference,
             handle parent = handle()) {
     using no_ref_T = typename std::remove_reference<T>::type;
     if (policy == return_value_policy::automatic) {
@@ -1087,51 +1238,61 @@
 inline void handle::cast() const {
     return;
 }
 
 template <typename T>
 detail::enable_if_t<!detail::move_never<T>::value, T> move(object &&obj) {
     if (obj.ref_count() > 1) {
-#if defined(NDEBUG)
+#if !defined(PYBIND11_DETAILED_ERROR_MESSAGES)
         throw cast_error(
-            "Unable to cast Python instance to C++ rvalue: instance has multiple references"
-            " (compile in debug mode for details)");
+            "Unable to cast Python " + str(type::handle_of(obj)).cast<std::string>()
+            + " instance to C++ rvalue: instance has multiple references"
+              " (#define PYBIND11_DETAILED_ERROR_MESSAGES or compile in debug mode for details)");
 #else
-        throw cast_error("Unable to move from Python " + (std::string) str(type::handle_of(obj))
-                         + " instance to C++ " + type_id<T>()
-                         + " instance: instance has multiple references");
+        throw cast_error("Unable to move from Python "
+                         + str(type::handle_of(obj)).cast<std::string>() + " instance to C++ "
+                         + type_id<T>() + " instance: instance has multiple references");
 #endif
     }
 
     // Move into a temporary and return that, because the reference may be a local value of `conv`
     T ret = std::move(detail::load_type<T>(obj).operator T &());
     return ret;
 }
 
 // Calling cast() on an rvalue calls pybind11::cast with the object rvalue, which does:
 // - If we have to move (because T has no copy constructor), do it.  This will fail if the moved
 //   object has multiple references, but trying to copy will fail to compile.
 // - If both movable and copyable, check ref count: if 1, move; otherwise copy
 // - Otherwise (not movable), copy.
 template <typename T>
-detail::enable_if_t<detail::move_always<T>::value, T> cast(object &&object) {
+detail::enable_if_t<!detail::is_pyobject<T>::value && detail::move_always<T>::value, T>
+cast(object &&object) {
     return move<T>(std::move(object));
 }
 template <typename T>
-detail::enable_if_t<detail::move_if_unreferenced<T>::value, T> cast(object &&object) {
+detail::enable_if_t<!detail::is_pyobject<T>::value && detail::move_if_unreferenced<T>::value, T>
+cast(object &&object) {
     if (object.ref_count() > 1) {
         return cast<T>(object);
     }
     return move<T>(std::move(object));
 }
 template <typename T>
-detail::enable_if_t<detail::move_never<T>::value, T> cast(object &&object) {
+detail::enable_if_t<!detail::is_pyobject<T>::value && detail::move_never<T>::value, T>
+cast(object &&object) {
     return cast<T>(object);
 }
 
+// pytype rvalue -> pytype (calls converting constructor)
+template <typename T>
+detail::enable_if_t<detail::is_pyobject<T>::value, T> cast(object &&object) {
+    return T(std::move(object));
+}
+
 template <typename T>
 T object::cast() const & {
     return pybind11::cast<T>(*this);
 }
 template <typename T>
 T object::cast() && {
     return pybind11::cast<T>(std::move(*this));
@@ -1174,32 +1335,34 @@
     pybind11_fail("Internal error: cast_ref fallback invoked");
 }
 
 // Trampoline use: Having a pybind11::cast with an invalid reference type is going to
 // static_assert, even though if it's in dead code, so we provide a "trampoline" to pybind11::cast
 // that only does anything in cases where pybind11::cast is valid.
 template <typename T>
-enable_if_t<!cast_is_temporary_value_reference<T>::value, T> cast_safe(object &&o) {
-    return pybind11::cast<T>(std::move(o));
-}
-template <typename T>
 enable_if_t<cast_is_temporary_value_reference<T>::value, T> cast_safe(object &&) {
     pybind11_fail("Internal error: cast_safe fallback invoked");
 }
-template <>
-inline void cast_safe<void>(object &&) {}
+template <typename T>
+enable_if_t<std::is_void<T>::value, void> cast_safe(object &&) {}
+template <typename T>
+enable_if_t<detail::none_of<cast_is_temporary_value_reference<T>, std::is_void<T>>::value, T>
+cast_safe(object &&o) {
+    return pybind11::cast<T>(std::move(o));
+}
 
 PYBIND11_NAMESPACE_END(detail)
 
 // The overloads could coexist, i.e. the #if is not strictly speaking needed,
 // but it is an easy minor optimization.
-#if defined(NDEBUG)
-inline cast_error cast_error_unable_to_convert_call_arg() {
-    return cast_error(
-        "Unable to convert call argument to Python object (compile in debug mode for details)");
+#if !defined(PYBIND11_DETAILED_ERROR_MESSAGES)
+inline cast_error cast_error_unable_to_convert_call_arg(const std::string &name) {
+    return cast_error("Unable to convert call argument '" + name
+                      + "' to Python object (#define "
+                        "PYBIND11_DETAILED_ERROR_MESSAGES or compile in debug mode for details)");
 }
 #else
 inline cast_error cast_error_unable_to_convert_call_arg(const std::string &name,
                                                         const std::string &type) {
     return cast_error("Unable to convert call argument '" + name + "' of type '" + type
                       + "' to Python object");
 }
@@ -1213,16 +1376,16 @@
 template <return_value_policy policy = return_value_policy::automatic_reference, typename... Args>
 tuple make_tuple(Args &&...args_) {
     constexpr size_t size = sizeof...(Args);
     std::array<object, size> args{{reinterpret_steal<object>(
         detail::make_caster<Args>::cast(std::forward<Args>(args_), policy, nullptr))...}};
     for (size_t i = 0; i < args.size(); i++) {
         if (!args[i]) {
-#if defined(NDEBUG)
-            throw cast_error_unable_to_convert_call_arg();
+#if !defined(PYBIND11_DETAILED_ERROR_MESSAGES)
+            throw cast_error_unable_to_convert_call_arg(std::to_string(i));
 #else
             std::array<std::string, size> argtypes{{type_id<Args>()...}};
             throw cast_error_unable_to_convert_call_arg(std::to_string(i), argtypes[i]);
 #endif
         }
     }
     tuple result(size);
@@ -1262,18 +1425,18 @@
 
 /// \ingroup annotations
 /// Annotation for arguments with values
 struct arg_v : arg {
 private:
     template <typename T>
     arg_v(arg &&base, T &&x, const char *descr = nullptr)
-        : arg(base), value(reinterpret_steal<object>(
-                         detail::make_caster<T>::cast(x, return_value_policy::automatic, {}))),
+        : arg(base), value(reinterpret_steal<object>(detail::make_caster<T>::cast(
+                         std::forward<T>(x), return_value_policy::automatic, {}))),
           descr(descr)
-#if !defined(NDEBUG)
+#if defined(PYBIND11_DETAILED_ERROR_MESSAGES)
           ,
           type(type_id<T>())
 #endif
     {
         // Workaround! See:
         // https://github.com/pybind/pybind11/issues/2336
         // https://github.com/pybind/pybind11/pull/2685#issuecomment-731286700
@@ -1305,23 +1468,23 @@
         return *this;
     }
 
     /// The default value
     object value;
     /// The (optional) description of the default value
     const char *descr;
-#if !defined(NDEBUG)
+#if defined(PYBIND11_DETAILED_ERROR_MESSAGES)
     /// The C++ type name of the default value (only available when compiled in debug mode)
     std::string type;
 #endif
 };
 
 /// \ingroup annotations
 /// Annotation indicating that all following arguments are keyword-only; the is the equivalent of
-/// an unnamed '*' argument (in Python 3)
+/// an unnamed '*' argument
 struct kw_only {};
 
 /// \ingroup annotations
 /// Annotation indicating that all previous arguments are positional-only; the is the equivalent of
 /// an unnamed '/' argument (in Python 3.8)
 struct pos_only {};
 
@@ -1334,15 +1497,23 @@
 template <typename /*unused*/>
 using arg_t = arg_v;
 
 inline namespace literals {
 /** \rst
     String literal version of `arg`
  \endrst */
-constexpr arg operator"" _a(const char *name, size_t) { return arg(name); }
+constexpr arg
+#if !defined(__clang__) && defined(__GNUC__) && __GNUC__ < 5
+operator"" _a // gcc 4.8.5 insists on having a space (hard error).
+#else
+operator""_a // clang 17 generates a deprecation warning if there is a space.
+#endif
+    (const char *name, size_t) {
+    return arg(name);
+}
 } // namespace literals
 
 PYBIND11_NAMESPACE_BEGIN(detail)
 
 template <typename T>
 using is_kw_only = std::is_same<intrinsic_t<T>, kw_only>;
 template <typename T>
@@ -1395,15 +1566,16 @@
 
     // py::args argument position; -1 if not present.
     static constexpr int args_pos = constexpr_last<argument_is_args, Args...>();
 
     static_assert(args_pos == -1 || args_pos == constexpr_first<argument_is_args, Args...>(),
                   "py::args cannot be specified more than once");
 
-    static constexpr auto arg_names = concat(type_descr(make_caster<Args>::name)...);
+    static constexpr auto arg_names
+        = ::pybind11::detail::concat(type_descr(make_caster<Args>::name)...);
 
     bool load_args(function_call &call) { return load_impl_sequence(call, indices{}); }
 
     template <typename Return, typename Guard, typename Func>
     // NOLINTNEXTLINE(readability-const-return-type)
     enable_if_t<!std::is_void<Return>::value, Return> call(Func &&f) && {
         return std::move(*this).template call_impl<remove_cv_t<Return>>(
@@ -1503,84 +1675,86 @@
 
 private:
     template <typename T>
     void process(list &args_list, T &&x) {
         auto o = reinterpret_steal<object>(
             detail::make_caster<T>::cast(std::forward<T>(x), policy, {}));
         if (!o) {
-#if defined(NDEBUG)
-            throw cast_error_unable_to_convert_call_arg();
+#if !defined(PYBIND11_DETAILED_ERROR_MESSAGES)
+            throw cast_error_unable_to_convert_call_arg(std::to_string(args_list.size()));
 #else
             throw cast_error_unable_to_convert_call_arg(std::to_string(args_list.size()),
                                                         type_id<T>());
 #endif
         }
-        args_list.append(o);
+        args_list.append(std::move(o));
     }
 
     void process(list &args_list, detail::args_proxy ap) {
         for (auto a : ap) {
             args_list.append(a);
         }
     }
 
     void process(list & /*args_list*/, arg_v a) {
         if (!a.name) {
-#if defined(NDEBUG)
+#if !defined(PYBIND11_DETAILED_ERROR_MESSAGES)
             nameless_argument_error();
 #else
             nameless_argument_error(a.type);
 #endif
         }
         if (m_kwargs.contains(a.name)) {
-#if defined(NDEBUG)
+#if !defined(PYBIND11_DETAILED_ERROR_MESSAGES)
             multiple_values_error();
 #else
             multiple_values_error(a.name);
 #endif
         }
         if (!a.value) {
-#if defined(NDEBUG)
-            throw cast_error_unable_to_convert_call_arg();
+#if !defined(PYBIND11_DETAILED_ERROR_MESSAGES)
+            throw cast_error_unable_to_convert_call_arg(a.name);
 #else
             throw cast_error_unable_to_convert_call_arg(a.name, a.type);
 #endif
         }
-        m_kwargs[a.name] = a.value;
+        m_kwargs[a.name] = std::move(a.value);
     }
 
     void process(list & /*args_list*/, detail::kwargs_proxy kp) {
         if (!kp) {
             return;
         }
         for (auto k : reinterpret_borrow<dict>(kp)) {
             if (m_kwargs.contains(k.first)) {
-#if defined(NDEBUG)
+#if !defined(PYBIND11_DETAILED_ERROR_MESSAGES)
                 multiple_values_error();
 #else
                 multiple_values_error(str(k.first));
 #endif
             }
             m_kwargs[k.first] = k.second;
         }
     }
 
     [[noreturn]] static void nameless_argument_error() {
-        throw type_error("Got kwargs without a name; only named arguments "
-                         "may be passed via py::arg() to a python function call. "
-                         "(compile in debug mode for details)");
+        throw type_error(
+            "Got kwargs without a name; only named arguments "
+            "may be passed via py::arg() to a python function call. "
+            "(#define PYBIND11_DETAILED_ERROR_MESSAGES or compile in debug mode for details)");
     }
     [[noreturn]] static void nameless_argument_error(const std::string &type) {
         throw type_error("Got kwargs without a name of type '" + type
                          + "'; only named "
                            "arguments may be passed via py::arg() to a python function call. ");
     }
     [[noreturn]] static void multiple_values_error() {
-        throw type_error("Got multiple values for keyword argument "
-                         "(compile in debug mode for details)");
+        throw type_error(
+            "Got multiple values for keyword argument "
+            "(#define PYBIND11_DETAILED_ERROR_MESSAGES or compile in debug mode for details)");
     }
 
     [[noreturn]] static void multiple_values_error(const std::string &name) {
         throw type_error("Got multiple values for keyword argument '" + name + "'");
     }
 
 private:
@@ -1619,15 +1793,15 @@
                   "* unpacking must precede ** unpacking");
     return unpacking_collector<policy>(std::forward<Args>(args)...);
 }
 
 template <typename Derived>
 template <return_value_policy policy, typename... Args>
 object object_api<Derived>::operator()(Args &&...args) const {
-#if !defined(NDEBUG) && PY_VERSION_HEX >= 0x03060000
+#ifndef NDEBUG
     if (!PyGILState_Check()) {
         pybind11_fail("pybind11::object_api<>::operator() PyGILState_Check() failure.");
     }
 #endif
     return detail::collect_arguments<policy>(std::forward<Args>(args)...).call(derived().ptr());
 }
 
@@ -1644,20 +1818,20 @@
     static_assert(std::is_base_of<detail::type_caster_generic, detail::make_caster<T>>::value,
                   "py::type::of<T> only supports the case where T is a registered C++ types.");
 
     return detail::get_type_handle(typeid(T), true);
 }
 
 #define PYBIND11_MAKE_OPAQUE(...)                                                                 \
-    namespace pybind11 {                                                                          \
+    PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)                                                  \
     namespace detail {                                                                            \
     template <>                                                                                   \
     class type_caster<__VA_ARGS__> : public type_caster_base<__VA_ARGS__> {};                     \
     }                                                                                             \
-    }
+    PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
 
 /// Lets you pass a type containing a `,` through a macro parameter without needing a separate
 /// typedef, e.g.:
 /// `PYBIND11_OVERRIDE(PYBIND11_TYPE(ReturnType<A, B>), PYBIND11_TYPE(Parent<C, D>), f, arg)`
 #define PYBIND11_TYPE(...) __VA_ARGS__
 
 PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
```

### Comparing `python_prtree-0.6.0/third/pybind11/include/pybind11/chrono.h` & `python_prtree-0.6.1/third/pybind11/include/pybind11/chrono.h`

 * *Files 6% similar despite different names*

```diff
@@ -14,25 +14,14 @@
 
 #include <chrono>
 #include <cmath>
 #include <ctime>
 #include <datetime.h>
 #include <mutex>
 
-// Backport the PyDateTime_DELTA functions from Python3.3 if required
-#ifndef PyDateTime_DELTA_GET_DAYS
-#    define PyDateTime_DELTA_GET_DAYS(o) (((PyDateTime_Delta *) o)->days)
-#endif
-#ifndef PyDateTime_DELTA_GET_SECONDS
-#    define PyDateTime_DELTA_GET_SECONDS(o) (((PyDateTime_Delta *) o)->seconds)
-#endif
-#ifndef PyDateTime_DELTA_GET_MICROSECONDS
-#    define PyDateTime_DELTA_GET_MICROSECONDS(o) (((PyDateTime_Delta *) o)->microseconds)
-#endif
-
 PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 PYBIND11_NAMESPACE_BEGIN(detail)
 
 template <typename type>
 class duration_caster {
 public:
     using rep = typename type::rep;
```

### Comparing `python_prtree-0.6.0/third/pybind11/include/pybind11/complex.h` & `python_prtree-0.6.1/third/pybind11/include/pybind11/complex.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/include/pybind11/detail/class.h` & `python_prtree-0.6.1/third/pybind11/include/pybind11/detail/class.h`

 * *Files 2% similar despite different names*

```diff
@@ -11,20 +11,20 @@
 
 #include "../attr.h"
 #include "../options.h"
 
 PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 PYBIND11_NAMESPACE_BEGIN(detail)
 
-#if PY_VERSION_HEX >= 0x03030000 && !defined(PYPY_VERSION)
+#if !defined(PYPY_VERSION)
 #    define PYBIND11_BUILTIN_QUALNAME
 #    define PYBIND11_SET_OLDPY_QUALNAME(obj, nameobj)
 #else
-// In pre-3.3 Python, we still set __qualname__ so that we can produce reliable function type
-// signatures; in 3.3+ this macro expands to nothing:
+// In PyPy, we still set __qualname__ so that we can produce reliable function type
+// signatures; in CPython this macro expands to nothing:
 #    define PYBIND11_SET_OLDPY_QUALNAME(obj, nameobj)                                             \
         setattr((PyObject *) obj, "__qualname__", nameobj)
 #endif
 
 inline std::string get_fully_qualified_tp_name(PyTypeObject *type) {
 #if !defined(PYPY_VERSION)
     return type->tp_name;
@@ -51,14 +51,17 @@
 
 /// `pybind11_static_property.__set__()`: Just like the above `__get__()`.
 extern "C" inline int pybind11_static_set(PyObject *self, PyObject *obj, PyObject *value) {
     PyObject *cls = PyType_Check(obj) ? obj : (PyObject *) Py_TYPE(obj);
     return PyProperty_Type.tp_descr_set(self, cls, value);
 }
 
+// Forward declaration to use in `make_static_property_type()`
+inline void enable_dynamic_attributes(PyHeapTypeObject *heap_type);
+
 /** A `static_property` is the same as a `property` but the `__get__()` and `__set__()`
     methods are modified to always use the object type instead of a concrete instance.
     Return value: New reference. */
 inline PyTypeObject *make_static_property_type() {
     constexpr auto *name = "pybind11_static_property";
     auto name_obj = reinterpret_steal<object>(PYBIND11_FROM_STRING(name));
 
@@ -79,14 +82,20 @@
     auto *type = &heap_type->ht_type;
     type->tp_name = name;
     type->tp_base = type_incref(&PyProperty_Type);
     type->tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HEAPTYPE;
     type->tp_descr_get = pybind11_static_get;
     type->tp_descr_set = pybind11_static_set;
 
+#    if PY_VERSION_HEX >= 0x030C0000
+    // Since Python-3.12 property-derived types are required to
+    // have dynamic attributes (to set `__doc__`)
+    enable_dynamic_attributes(heap_type);
+#    endif
+
     if (PyType_Ready(type) < 0) {
         pybind11_fail("make_static_property_type(): failure in PyType_Ready()!");
     }
 
     setattr((PyObject *) type, "__module__", str("pybind11_builtins"));
     PYBIND11_SET_OLDPY_QUALNAME(type, name_obj);
 
@@ -151,46 +160,42 @@
 #endif
     } else {
         // Replace existing attribute.
         return PyType_Type.tp_setattro(obj, name, value);
     }
 }
 
-#if PY_MAJOR_VERSION >= 3
 /**
  * Python 3's PyInstanceMethod_Type hides itself via its tp_descr_get, which prevents aliasing
  * methods via cls.attr("m2") = cls.attr("m1"): instead the tp_descr_get returns a plain function,
  * when called on a class, or a PyMethod, when called on an instance.  Override that behaviour here
  * to do a special case bypass for PyInstanceMethod_Types.
  */
 extern "C" inline PyObject *pybind11_meta_getattro(PyObject *obj, PyObject *name) {
     PyObject *descr = _PyType_Lookup((PyTypeObject *) obj, name);
     if (descr && PyInstanceMethod_Check(descr)) {
         Py_INCREF(descr);
         return descr;
     }
     return PyType_Type.tp_getattro(obj, name);
 }
-#endif
 
 /// metaclass `__call__` function that is used to create all pybind11 objects.
 extern "C" inline PyObject *pybind11_meta_call(PyObject *type, PyObject *args, PyObject *kwargs) {
 
     // use the default metaclass call to create/initialize the object
     PyObject *self = PyType_Type.tp_call(type, args, kwargs);
     if (self == nullptr) {
         return nullptr;
     }
 
-    // This must be a pybind11 instance
-    auto *instance = reinterpret_cast<detail::instance *>(self);
-
     // Ensure that the base __init__ function(s) were called
-    for (const auto &vh : values_and_holders(instance)) {
-        if (!vh.holder_constructed()) {
+    values_and_holders vhs(self);
+    for (const auto &vh : vhs) {
+        if (!vh.holder_constructed() && !vhs.is_redundant_value_and_holder(vh)) {
             PyErr_Format(PyExc_TypeError,
                          "%.200s.__init__() must be called when overriding __init__",
                          get_fully_qualified_tp_name(vh.type->type).c_str());
             Py_DECREF(self);
             return nullptr;
         }
     }
@@ -262,17 +267,15 @@
     type->tp_name = name;
     type->tp_base = type_incref(&PyType_Type);
     type->tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HEAPTYPE;
 
     type->tp_call = pybind11_meta_call;
 
     type->tp_setattro = pybind11_meta_setattro;
-#if PY_MAJOR_VERSION >= 3
     type->tp_getattro = pybind11_meta_getattro;
-#endif
 
     type->tp_dealloc = pybind11_meta_dealloc;
 
     if (PyType_Ready(type) < 0) {
         pybind11_fail("make_default_metaclass(): failure in PyType_Ready()!");
     }
 
@@ -365,15 +368,15 @@
 
 /// An `__init__` function constructs the C++ object. Users should provide at least one
 /// of these using `py::init` or directly with `.def(__init__, ...)`. Otherwise, the
 /// following default function will be used which simply throws an exception.
 extern "C" inline int pybind11_object_init(PyObject *self, PyObject *, PyObject *) {
     PyTypeObject *type = Py_TYPE(self);
     std::string msg = get_fully_qualified_tp_name(type) + ": No constructor defined!";
-    PyErr_SetString(PyExc_TypeError, msg.c_str());
+    set_error(PyExc_TypeError, msg.c_str());
     return -1;
 }
 
 inline void add_patient(PyObject *nurse, PyObject *patient) {
     auto &internals = get_internals();
     auto *instance = reinterpret_cast<detail::instance *>(nurse);
     instance->has_patients = true;
@@ -435,17 +438,25 @@
         clear_patients(self);
     }
 }
 
 /// Instance destructor function for all pybind11 types. It calls `type_info.dealloc`
 /// to destroy the C++ object itself, while the rest is Python bookkeeping.
 extern "C" inline void pybind11_object_dealloc(PyObject *self) {
+    auto *type = Py_TYPE(self);
+
+    // If this is a GC tracked object, untrack it first
+    // Note that the track call is implicitly done by the
+    // default tp_alloc, which we never override.
+    if (PyType_HasFeature(type, Py_TPFLAGS_HAVE_GC) != 0) {
+        PyObject_GC_UnTrack(self);
+    }
+
     clear_instance(self);
 
-    auto *type = Py_TYPE(self);
     type->tp_free(self);
 
 #if PY_VERSION_HEX < 0x03080000
     // `type->tp_dealloc != pybind11_object_dealloc` means that we're being called
     // as part of a derived type's dealloc, in which case we're not allowed to decref
     // the type here. For cross-module compatibility, we shouldn't compare directly
     // with `pybind11_object_dealloc`, but with the common one stashed in internals.
@@ -455,14 +466,16 @@
 #else
     // This was not needed before Python 3.8 (Python issue 35810)
     // https://github.com/pybind/pybind11/issues/1946
     Py_DECREF(type);
 #endif
 }
 
+std::string error_string();
+
 /** Create the type which can be used as a common base for all classes.  This is
     needed in order to satisfy Python's requirements for multiple inheritance.
     Return value: New reference. */
 inline PyObject *make_object_base_type(PyTypeObject *metaclass) {
     constexpr auto *name = "pybind11_object";
     auto name_obj = reinterpret_steal<object>(PYBIND11_FROM_STRING(name));
 
@@ -490,75 +503,74 @@
     type->tp_init = pybind11_object_init;
     type->tp_dealloc = pybind11_object_dealloc;
 
     /* Support weak references (needed for the keep_alive feature) */
     type->tp_weaklistoffset = offsetof(instance, weakrefs);
 
     if (PyType_Ready(type) < 0) {
-        pybind11_fail("PyType_Ready failed in make_object_base_type():" + error_string());
+        pybind11_fail("PyType_Ready failed in make_object_base_type(): " + error_string());
     }
 
     setattr((PyObject *) type, "__module__", str("pybind11_builtins"));
     PYBIND11_SET_OLDPY_QUALNAME(type, name_obj);
 
     assert(!PyType_HasFeature(type, Py_TPFLAGS_HAVE_GC));
     return (PyObject *) heap_type;
 }
 
-/// dynamic_attr: Support for `d = instance.__dict__`.
-extern "C" inline PyObject *pybind11_get_dict(PyObject *self, void *) {
-    PyObject *&dict = *_PyObject_GetDictPtr(self);
-    if (!dict) {
-        dict = PyDict_New();
-    }
-    Py_XINCREF(dict);
-    return dict;
-}
-
-/// dynamic_attr: Support for `instance.__dict__ = dict()`.
-extern "C" inline int pybind11_set_dict(PyObject *self, PyObject *new_dict, void *) {
-    if (!PyDict_Check(new_dict)) {
-        PyErr_Format(PyExc_TypeError,
-                     "__dict__ must be set to a dictionary, not a '%.200s'",
-                     get_fully_qualified_tp_name(Py_TYPE(new_dict)).c_str());
-        return -1;
-    }
-    PyObject *&dict = *_PyObject_GetDictPtr(self);
-    Py_INCREF(new_dict);
-    Py_CLEAR(dict);
-    dict = new_dict;
-    return 0;
-}
-
 /// dynamic_attr: Allow the garbage collector to traverse the internal instance `__dict__`.
 extern "C" inline int pybind11_traverse(PyObject *self, visitproc visit, void *arg) {
+#if PY_VERSION_HEX >= 0x030D0000
+    PyObject_VisitManagedDict(self, visit, arg);
+#else
     PyObject *&dict = *_PyObject_GetDictPtr(self);
     Py_VISIT(dict);
+#endif
+// https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_traverse
+#if PY_VERSION_HEX >= 0x03090000
+    Py_VISIT(Py_TYPE(self));
+#endif
     return 0;
 }
 
 /// dynamic_attr: Allow the GC to clear the dictionary.
 extern "C" inline int pybind11_clear(PyObject *self) {
+#if PY_VERSION_HEX >= 0x030D0000
+    PyObject_ClearManagedDict(self);
+#else
     PyObject *&dict = *_PyObject_GetDictPtr(self);
     Py_CLEAR(dict);
+#endif
     return 0;
 }
 
 /// Give instances of this type a `__dict__` and opt into garbage collection.
 inline void enable_dynamic_attributes(PyHeapTypeObject *heap_type) {
     auto *type = &heap_type->ht_type;
     type->tp_flags |= Py_TPFLAGS_HAVE_GC;
+#if PY_VERSION_HEX < 0x030B0000
     type->tp_dictoffset = type->tp_basicsize;           // place dict at the end
     type->tp_basicsize += (ssize_t) sizeof(PyObject *); // and allocate enough space for it
+#else
+    type->tp_flags |= Py_TPFLAGS_MANAGED_DICT;
+#endif
     type->tp_traverse = pybind11_traverse;
     type->tp_clear = pybind11_clear;
 
-    static PyGetSetDef getset[] = {
-        {const_cast<char *>("__dict__"), pybind11_get_dict, pybind11_set_dict, nullptr, nullptr},
-        {nullptr, nullptr, nullptr, nullptr, nullptr}};
+    static PyGetSetDef getset[] = {{
+#if PY_VERSION_HEX < 0x03070000
+                                       const_cast<char *>("__dict__"),
+#else
+                                       "__dict__",
+#endif
+                                       PyObject_GenericGetDict,
+                                       PyObject_GenericSetDict,
+                                       nullptr,
+                                       nullptr},
+                                   {nullptr, nullptr, nullptr, nullptr, nullptr}};
     type->tp_getset = getset;
 }
 
 /// buffer_protocol: Fill in the view as specified by flags.
 extern "C" inline int pybind11_getbuffer(PyObject *obj, Py_buffer *view, int flags) {
     // Look for a `get_buffer` implementation in this type's info or any bases (following MRO).
     type_info *tinfo = nullptr;
@@ -568,23 +580,23 @@
             break;
         }
     }
     if (view == nullptr || !tinfo || !tinfo->get_buffer) {
         if (view) {
             view->obj = nullptr;
         }
-        PyErr_SetString(PyExc_BufferError, "pybind11_getbuffer(): Internal error");
+        set_error(PyExc_BufferError, "pybind11_getbuffer(): Internal error");
         return -1;
     }
     std::memset(view, 0, sizeof(Py_buffer));
     buffer_info *info = tinfo->get_buffer(obj, tinfo->get_buffer_data);
     if ((flags & PyBUF_WRITABLE) == PyBUF_WRITABLE && info->readonly) {
         delete info;
         // view->obj = nullptr;  // Was just memset to 0, so not necessary
-        PyErr_SetString(PyExc_BufferError, "Writable buffer requested for readonly storage");
+        set_error(PyExc_BufferError, "Writable buffer requested for readonly storage");
         return -1;
     }
     view->obj = obj;
     view->ndim = 1;
     view->internal = info;
     view->buf = info->ptr;
     view->itemsize = info->itemsize;
@@ -609,35 +621,28 @@
 extern "C" inline void pybind11_releasebuffer(PyObject *, Py_buffer *view) {
     delete (buffer_info *) view->internal;
 }
 
 /// Give this type a buffer interface.
 inline void enable_buffer_protocol(PyHeapTypeObject *heap_type) {
     heap_type->ht_type.tp_as_buffer = &heap_type->as_buffer;
-#if PY_MAJOR_VERSION < 3
-    heap_type->ht_type.tp_flags |= Py_TPFLAGS_HAVE_NEWBUFFER;
-#endif
 
     heap_type->as_buffer.bf_getbuffer = pybind11_getbuffer;
     heap_type->as_buffer.bf_releasebuffer = pybind11_releasebuffer;
 }
 
 /** Create a brand new Python type according to the `type_record` specification.
     Return value: New reference. */
 inline PyObject *make_new_python_type(const type_record &rec) {
     auto name = reinterpret_steal<object>(PYBIND11_FROM_STRING(rec.name));
 
     auto qualname = name;
     if (rec.scope && !PyModule_Check(rec.scope.ptr()) && hasattr(rec.scope, "__qualname__")) {
-#if PY_MAJOR_VERSION >= 3
         qualname = reinterpret_steal<object>(
             PyUnicode_FromFormat("%U.%U", rec.scope.attr("__qualname__").ptr(), name.ptr()));
-#else
-        qualname = str(rec.scope.attr("__qualname__").cast<std::string>() + "." + rec.name);
-#endif
     }
 
     object module_;
     if (rec.scope) {
         if (hasattr(rec.scope, "__module__")) {
             module_ = rec.scope.attr("__module__");
         } else if (hasattr(rec.scope, "__name__")) {
@@ -693,23 +698,18 @@
     /* Don't inherit base __init__ */
     type->tp_init = pybind11_object_init;
 
     /* Supported protocols */
     type->tp_as_number = &heap_type->as_number;
     type->tp_as_sequence = &heap_type->as_sequence;
     type->tp_as_mapping = &heap_type->as_mapping;
-#if PY_VERSION_HEX >= 0x03050000
     type->tp_as_async = &heap_type->as_async;
-#endif
 
     /* Flags */
     type->tp_flags |= Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HEAPTYPE;
-#if PY_MAJOR_VERSION < 3
-    type->tp_flags |= Py_TPFLAGS_CHECKTYPES;
-#endif
     if (!rec.is_final) {
         type->tp_flags |= Py_TPFLAGS_BASETYPE;
     }
 
     if (rec.dynamic_attr) {
         enable_dynamic_attributes(heap_type);
     }
@@ -719,15 +719,15 @@
     }
 
     if (rec.custom_type_setup_callback) {
         rec.custom_type_setup_callback(heap_type);
     }
 
     if (PyType_Ready(type) < 0) {
-        pybind11_fail(std::string(rec.name) + ": PyType_Ready failed (" + error_string() + ")!");
+        pybind11_fail(std::string(rec.name) + ": PyType_Ready failed: " + error_string());
     }
 
     assert(!rec.dynamic_attr || PyType_HasFeature(type, Py_TPFLAGS_HAVE_GC));
 
     /* Register type with the parent scope */
     if (rec.scope) {
         setattr(rec.scope, rec.name, (PyObject *) type);
```

### Comparing `python_prtree-0.6.0/third/pybind11/include/pybind11/detail/common.h` & `python_prtree-0.6.1/third/pybind11/include/pybind11/detail/common.h`

 * *Files 5% similar despite different names*

```diff
@@ -6,23 +6,84 @@
     All rights reserved. Use of this source code is governed by a
     BSD-style license that can be found in the LICENSE file.
 */
 
 #pragma once
 
 #define PYBIND11_VERSION_MAJOR 2
-#define PYBIND11_VERSION_MINOR 9
-#define PYBIND11_VERSION_PATCH 2
+#define PYBIND11_VERSION_MINOR 12
+#define PYBIND11_VERSION_PATCH 0
 
 // Similar to Python's convention: https://docs.python.org/3/c-api/apiabiversion.html
 // Additional convention: 0xD = dev
-#define PYBIND11_VERSION_HEX 0x02090200
+#define PYBIND11_VERSION_HEX 0x020C0000
 
-#define PYBIND11_NAMESPACE_BEGIN(name) namespace name {
-#define PYBIND11_NAMESPACE_END(name) }
+// Define some generic pybind11 helper macros for warning management.
+//
+// Note that compiler-specific push/pop pairs are baked into the
+// PYBIND11_NAMESPACE_BEGIN/PYBIND11_NAMESPACE_END pair of macros. Therefore manual
+// PYBIND11_WARNING_PUSH/PYBIND11_WARNING_POP are usually only needed in `#include` sections.
+//
+// If you find you need to suppress a warning, please try to make the suppression as local as
+// possible using these macros. Please also be sure to push/pop with the pybind11 macros. Please
+// only use compiler specifics if you need to check specific versions, e.g. Apple Clang vs. vanilla
+// Clang.
+#if defined(_MSC_VER)
+#    define PYBIND11_COMPILER_MSVC
+#    define PYBIND11_PRAGMA(...) __pragma(__VA_ARGS__)
+#    define PYBIND11_WARNING_PUSH PYBIND11_PRAGMA(warning(push))
+#    define PYBIND11_WARNING_POP PYBIND11_PRAGMA(warning(pop))
+#elif defined(__INTEL_COMPILER)
+#    define PYBIND11_COMPILER_INTEL
+#    define PYBIND11_PRAGMA(...) _Pragma(#__VA_ARGS__)
+#    define PYBIND11_WARNING_PUSH PYBIND11_PRAGMA(warning push)
+#    define PYBIND11_WARNING_POP PYBIND11_PRAGMA(warning pop)
+#elif defined(__clang__)
+#    define PYBIND11_COMPILER_CLANG
+#    define PYBIND11_PRAGMA(...) _Pragma(#__VA_ARGS__)
+#    define PYBIND11_WARNING_PUSH PYBIND11_PRAGMA(clang diagnostic push)
+#    define PYBIND11_WARNING_POP PYBIND11_PRAGMA(clang diagnostic push)
+#elif defined(__GNUC__)
+#    define PYBIND11_COMPILER_GCC
+#    define PYBIND11_PRAGMA(...) _Pragma(#__VA_ARGS__)
+#    define PYBIND11_WARNING_PUSH PYBIND11_PRAGMA(GCC diagnostic push)
+#    define PYBIND11_WARNING_POP PYBIND11_PRAGMA(GCC diagnostic pop)
+#endif
+
+#ifdef PYBIND11_COMPILER_MSVC
+#    define PYBIND11_WARNING_DISABLE_MSVC(name) PYBIND11_PRAGMA(warning(disable : name))
+#else
+#    define PYBIND11_WARNING_DISABLE_MSVC(name)
+#endif
+
+#ifdef PYBIND11_COMPILER_CLANG
+#    define PYBIND11_WARNING_DISABLE_CLANG(name) PYBIND11_PRAGMA(clang diagnostic ignored name)
+#else
+#    define PYBIND11_WARNING_DISABLE_CLANG(name)
+#endif
+
+#ifdef PYBIND11_COMPILER_GCC
+#    define PYBIND11_WARNING_DISABLE_GCC(name) PYBIND11_PRAGMA(GCC diagnostic ignored name)
+#else
+#    define PYBIND11_WARNING_DISABLE_GCC(name)
+#endif
+
+#ifdef PYBIND11_COMPILER_INTEL
+#    define PYBIND11_WARNING_DISABLE_INTEL(name) PYBIND11_PRAGMA(warning disable name)
+#else
+#    define PYBIND11_WARNING_DISABLE_INTEL(name)
+#endif
+
+#define PYBIND11_NAMESPACE_BEGIN(name)                                                            \
+    namespace name {                                                                              \
+    PYBIND11_WARNING_PUSH
+
+#define PYBIND11_NAMESPACE_END(name)                                                              \
+    PYBIND11_WARNING_POP                                                                          \
+    }
 
 // Robust support for some features and loading modules compiled against different pybind versions
 // requires forcing hidden visibility on pybind code, so we enforce this by setting the attribute
 // on the main `pybind11` namespace.
 #if !defined(PYBIND11_NAMESPACE)
 #    ifdef __GNUG__
 #        define PYBIND11_NAMESPACE pybind11 __attribute__((visibility("hidden")))
@@ -34,32 +95,41 @@
 #if !(defined(_MSC_VER) && __cplusplus == 199711L)
 #    if __cplusplus >= 201402L
 #        define PYBIND11_CPP14
 #        if __cplusplus >= 201703L
 #            define PYBIND11_CPP17
 #            if __cplusplus >= 202002L
 #                define PYBIND11_CPP20
+// Please update tests/pybind11_tests.cpp `cpp_std()` when adding a macro here.
 #            endif
 #        endif
 #    endif
 #elif defined(_MSC_VER) && __cplusplus == 199711L
 // MSVC sets _MSVC_LANG rather than __cplusplus (supposedly until the standard is fully
 // implemented). Unless you use the /Zc:__cplusplus flag on Visual Studio 2017 15.7 Preview 3
 // or newer.
 #    if _MSVC_LANG >= 201402L
 #        define PYBIND11_CPP14
-#        if _MSVC_LANG > 201402L && _MSC_VER >= 1910
+#        if _MSVC_LANG > 201402L
 #            define PYBIND11_CPP17
 #            if _MSVC_LANG >= 202002L
 #                define PYBIND11_CPP20
 #            endif
 #        endif
 #    endif
 #endif
 
+#if defined(PYBIND11_CPP20)
+#    define PYBIND11_CONSTINIT constinit
+#    define PYBIND11_DTOR_CONSTEXPR constexpr
+#else
+#    define PYBIND11_CONSTINIT
+#    define PYBIND11_DTOR_CONSTEXPR
+#endif
+
 // Compiler version assertions
 #if defined(__INTEL_COMPILER)
 #    if __INTEL_COMPILER < 1800
 #        error pybind11 requires Intel C++ compiler v18 or newer
 #    elif __INTEL_COMPILER < 1900 && defined(PYBIND11_CPP14)
 #        error pybind11 supports only C++11 with Intel C++ compiler v18. Use v19 or newer for C++14.
 #    endif
@@ -77,37 +147,32 @@
 #        error pybind11 requires Xcode/clang 5.0 or newer
 #    endif
 #elif defined(__GNUG__)
 #    if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 8)
 #        error pybind11 requires gcc 4.8 or newer
 #    endif
 #elif defined(_MSC_VER)
-// Pybind hits various compiler bugs in 2015u2 and earlier, and also makes use of some stl features
-// (e.g. std::negation) added in 2015u3:
-#    if _MSC_FULL_VER < 190024210
-#        error pybind11 requires MSVC 2015 update 3 or newer
+#    if _MSC_VER < 1910
+#        error pybind11 2.10+ requires MSVC 2017 or newer
 #    endif
 #endif
 
 #if !defined(PYBIND11_EXPORT)
 #    if defined(WIN32) || defined(_WIN32)
 #        define PYBIND11_EXPORT __declspec(dllexport)
 #    else
 #        define PYBIND11_EXPORT __attribute__((visibility("default")))
 #    endif
 #endif
 
 #if !defined(PYBIND11_EXPORT_EXCEPTION)
-#    ifdef __MINGW32__
-// workaround for:
-// error: 'dllexport' implies default visibility, but xxx has already been declared with a
-// different visibility
-#        define PYBIND11_EXPORT_EXCEPTION
-#    else
+#    if defined(__apple_build_version__)
 #        define PYBIND11_EXPORT_EXCEPTION PYBIND11_EXPORT
+#    else
+#        define PYBIND11_EXPORT_EXCEPTION
 #    endif
 #endif
 
 // For CUDA, GCC7, GCC8:
 // PYBIND11_NOINLINE_FORCED is incompatible with `-Wattributes -Werror`.
 // When defining PYBIND11_NOINLINE_FORCED, it is best to also use `-Wno-attributes`.
 // However, the measured shared-library size saving when using noinline are only
@@ -145,23 +210,23 @@
 #    define PYBIND11_MAYBE_UNUSED
 #else
 #    define PYBIND11_MAYBE_UNUSED __attribute__((__unused__))
 #endif
 
 /* Don't let Python.h #define (v)snprintf as macro because they are implemented
    properly in Visual Studio since 2015. */
-#if defined(_MSC_VER) && _MSC_VER >= 1900
+#if defined(_MSC_VER)
 #    define HAVE_SNPRINTF 1
 #endif
 
 /// Include Python header, disable linking to pythonX_d.lib on Windows in debug mode
 #if defined(_MSC_VER)
-#    pragma warning(push)
+PYBIND11_WARNING_PUSH
+PYBIND11_WARNING_DISABLE_MSVC(4505)
 // C4505: 'PySlice_GetIndicesEx': unreferenced local function has been removed (PyPy only)
-#    pragma warning(disable : 4505)
 #    if defined(_DEBUG) && !defined(Py_DEBUG)
 // Workaround for a VS 2022 issue.
 // NOTE: This workaround knowingly violates the Python.h include order requirement:
 // https://docs.python.org/3/c-api/intro.html#include-files
 // See https://github.com/pybind/pybind11/pull/3497 for full context.
 #        include <yvals.h>
 #        if _MSVC_STL_VERSION >= 143
@@ -202,19 +267,19 @@
 #            define PYBIND11_HAS_STRING_VIEW
 #        endif
 #    elif defined(_MSC_VER)
 #        define PYBIND11_HAS_STRING_VIEW
 #    endif
 #endif
 
-#if defined(__cpp_lib_char8_t) && __cpp_lib_char8_t >= 201811L
-#    define PYBIND11_HAS_U8STRING
-#endif
-
 #include <Python.h>
+// Reminder: WITH_THREAD is always defined if PY_VERSION_HEX >= 0x03070000
+#if PY_VERSION_HEX < 0x03060000
+#    error "PYTHON < 3.6 IS UNSUPPORTED. pybind11 v2.9 was the last to support Python 2 and 3.5."
+#endif
 #include <frameobject.h>
 #include <pythread.h>
 
 /* Python #defines overrides on all sorts of core functions, which
    tends to weak havok in C++ codebases that expect these to work
    like regular functions (potentially with several overloads) */
 #if defined(isalnum)
@@ -227,20 +292,28 @@
 #    undef toupper
 #endif
 
 #if defined(copysign)
 #    undef copysign
 #endif
 
+#if defined(PYBIND11_NUMPY_1_ONLY)
+#    define PYBIND11_INTERNAL_NUMPY_1_ONLY_DETECTED
+#endif
+
+#if defined(PYPY_VERSION) && !defined(PYBIND11_SIMPLE_GIL_MANAGEMENT)
+#    define PYBIND11_SIMPLE_GIL_MANAGEMENT
+#endif
+
 #if defined(_MSC_VER)
 #    if defined(PYBIND11_DEBUG_MARKER)
 #        define _DEBUG
 #        undef PYBIND11_DEBUG_MARKER
 #    endif
-#    pragma warning(pop)
+PYBIND11_WARNING_POP
 #endif
 
 #include <cstddef>
 #include <cstring>
 #include <exception>
 #include <forward_list>
 #include <memory>
@@ -253,95 +326,65 @@
 #include <vector>
 #if defined(__has_include)
 #    if __has_include(<version>)
 #        include <version>
 #    endif
 #endif
 
+// Must be after including <version> or one of the other headers specified by the standard
+#if defined(__cpp_lib_char8_t) && __cpp_lib_char8_t >= 201811L
+#    define PYBIND11_HAS_U8STRING
+#endif
+
+// See description of PR #4246:
+#if !defined(PYBIND11_NO_ASSERT_GIL_HELD_INCREF_DECREF) && !defined(NDEBUG)                       \
+    && !defined(PYPY_VERSION) && !defined(PYBIND11_ASSERT_GIL_HELD_INCREF_DECREF)
+#    define PYBIND11_ASSERT_GIL_HELD_INCREF_DECREF
+#endif
+
 // #define PYBIND11_STR_LEGACY_PERMISSIVE
 // If DEFINED, pybind11::str can hold PyUnicodeObject or PyBytesObject
 //             (probably surprising and never documented, but this was the
 //             legacy behavior until and including v2.6.x). As a side-effect,
 //             pybind11::isinstance<str>() is true for both pybind11::str and
 //             pybind11::bytes.
 // If UNDEFINED, pybind11::str can only hold PyUnicodeObject, and
 //               pybind11::isinstance<str>() is true only for pybind11::str.
 //               However, for Python 2 only (!), the pybind11::str caster
-//               implicitly decodes bytes to PyUnicodeObject. This is to ease
+//               implicitly decoded bytes to PyUnicodeObject. This was to ease
 //               the transition from the legacy behavior to the non-permissive
 //               behavior.
 
-#if PY_MAJOR_VERSION >= 3 /// Compatibility macros for various Python versions
-#    define PYBIND11_INSTANCE_METHOD_NEW(ptr, class_) PyInstanceMethod_New(ptr)
-#    define PYBIND11_INSTANCE_METHOD_CHECK PyInstanceMethod_Check
-#    define PYBIND11_INSTANCE_METHOD_GET_FUNCTION PyInstanceMethod_GET_FUNCTION
-#    define PYBIND11_BYTES_CHECK PyBytes_Check
-#    define PYBIND11_BYTES_FROM_STRING PyBytes_FromString
-#    define PYBIND11_BYTES_FROM_STRING_AND_SIZE PyBytes_FromStringAndSize
-#    define PYBIND11_BYTES_AS_STRING_AND_SIZE PyBytes_AsStringAndSize
-#    define PYBIND11_BYTES_AS_STRING PyBytes_AsString
-#    define PYBIND11_BYTES_SIZE PyBytes_Size
-#    define PYBIND11_LONG_CHECK(o) PyLong_Check(o)
-#    define PYBIND11_LONG_AS_LONGLONG(o) PyLong_AsLongLong(o)
-#    define PYBIND11_LONG_FROM_SIGNED(o) PyLong_FromSsize_t((ssize_t) (o))
-#    define PYBIND11_LONG_FROM_UNSIGNED(o) PyLong_FromSize_t((size_t) (o))
-#    define PYBIND11_BYTES_NAME "bytes"
-#    define PYBIND11_STRING_NAME "str"
-#    define PYBIND11_SLICE_OBJECT PyObject
-#    define PYBIND11_FROM_STRING PyUnicode_FromString
-#    define PYBIND11_STR_TYPE ::pybind11::str
-#    define PYBIND11_BOOL_ATTR "__bool__"
-#    define PYBIND11_NB_BOOL(ptr) ((ptr)->nb_bool)
-#    define PYBIND11_BUILTINS_MODULE "builtins"
+/// Compatibility macros for Python 2 / Python 3 versions TODO: remove
+#define PYBIND11_INSTANCE_METHOD_NEW(ptr, class_) PyInstanceMethod_New(ptr)
+#define PYBIND11_INSTANCE_METHOD_CHECK PyInstanceMethod_Check
+#define PYBIND11_INSTANCE_METHOD_GET_FUNCTION PyInstanceMethod_GET_FUNCTION
+#define PYBIND11_BYTES_CHECK PyBytes_Check
+#define PYBIND11_BYTES_FROM_STRING PyBytes_FromString
+#define PYBIND11_BYTES_FROM_STRING_AND_SIZE PyBytes_FromStringAndSize
+#define PYBIND11_BYTES_AS_STRING_AND_SIZE PyBytes_AsStringAndSize
+#define PYBIND11_BYTES_AS_STRING PyBytes_AsString
+#define PYBIND11_BYTES_SIZE PyBytes_Size
+#define PYBIND11_LONG_CHECK(o) PyLong_Check(o)
+#define PYBIND11_LONG_AS_LONGLONG(o) PyLong_AsLongLong(o)
+#define PYBIND11_LONG_FROM_SIGNED(o) PyLong_FromSsize_t((ssize_t) (o))
+#define PYBIND11_LONG_FROM_UNSIGNED(o) PyLong_FromSize_t((size_t) (o))
+#define PYBIND11_BYTES_NAME "bytes"
+#define PYBIND11_STRING_NAME "str"
+#define PYBIND11_SLICE_OBJECT PyObject
+#define PYBIND11_FROM_STRING PyUnicode_FromString
+#define PYBIND11_STR_TYPE ::pybind11::str
+#define PYBIND11_BOOL_ATTR "__bool__"
+#define PYBIND11_NB_BOOL(ptr) ((ptr)->nb_bool)
+#define PYBIND11_BUILTINS_MODULE "builtins"
 // Providing a separate declaration to make Clang's -Wmissing-prototypes happy.
 // See comment for PYBIND11_MODULE below for why this is marked "maybe unused".
-#    define PYBIND11_PLUGIN_IMPL(name)                                                            \
-        extern "C" PYBIND11_MAYBE_UNUSED PYBIND11_EXPORT PyObject *PyInit_##name();               \
-        extern "C" PYBIND11_EXPORT PyObject *PyInit_##name()
-
-#else
-#    define PYBIND11_INSTANCE_METHOD_NEW(ptr, class_) PyMethod_New(ptr, nullptr, class_)
-#    define PYBIND11_INSTANCE_METHOD_CHECK PyMethod_Check
-#    define PYBIND11_INSTANCE_METHOD_GET_FUNCTION PyMethod_GET_FUNCTION
-#    define PYBIND11_BYTES_CHECK PyString_Check
-#    define PYBIND11_BYTES_FROM_STRING PyString_FromString
-#    define PYBIND11_BYTES_FROM_STRING_AND_SIZE PyString_FromStringAndSize
-#    define PYBIND11_BYTES_AS_STRING_AND_SIZE PyString_AsStringAndSize
-#    define PYBIND11_BYTES_AS_STRING PyString_AsString
-#    define PYBIND11_BYTES_SIZE PyString_Size
-#    define PYBIND11_LONG_CHECK(o) (PyInt_Check(o) || PyLong_Check(o))
-#    define PYBIND11_LONG_AS_LONGLONG(o)                                                          \
-        (PyInt_Check(o) ? (long long) PyLong_AsLong(o) : PyLong_AsLongLong(o))
-#    define PYBIND11_LONG_FROM_SIGNED(o) PyInt_FromSsize_t((ssize_t) o) // Returns long if needed.
-#    define PYBIND11_LONG_FROM_UNSIGNED(o) PyInt_FromSize_t((size_t) o) // Returns long if needed.
-#    define PYBIND11_BYTES_NAME "str"
-#    define PYBIND11_STRING_NAME "unicode"
-#    define PYBIND11_SLICE_OBJECT PySliceObject
-#    define PYBIND11_FROM_STRING PyString_FromString
-#    define PYBIND11_STR_TYPE ::pybind11::bytes
-#    define PYBIND11_BOOL_ATTR "__nonzero__"
-#    define PYBIND11_NB_BOOL(ptr) ((ptr)->nb_nonzero)
-#    define PYBIND11_BUILTINS_MODULE "__builtin__"
-// Providing a separate PyInit decl to make Clang's -Wmissing-prototypes happy.
-// See comment for PYBIND11_MODULE below for why this is marked "maybe unused".
-#    define PYBIND11_PLUGIN_IMPL(name)                                                            \
-        static PyObject *pybind11_init_wrapper();                                                 \
-        extern "C" PYBIND11_MAYBE_UNUSED PYBIND11_EXPORT void init##name();                       \
-        extern "C" PYBIND11_EXPORT void init##name() { (void) pybind11_init_wrapper(); }          \
-        PyObject *pybind11_init_wrapper()
-#endif
-
-#if PY_VERSION_HEX >= 0x03050000 && PY_VERSION_HEX < 0x03050200
-extern "C" {
-struct _Py_atomic_address {
-    void *value;
-};
-PyAPI_DATA(_Py_atomic_address) _PyThreadState_Current;
-}
-#endif
+#define PYBIND11_PLUGIN_IMPL(name)                                                                \
+    extern "C" PYBIND11_MAYBE_UNUSED PYBIND11_EXPORT PyObject *PyInit_##name();                   \
+    extern "C" PYBIND11_EXPORT PyObject *PyInit_##name()
 
 #define PYBIND11_TRY_NEXT_OVERLOAD ((PyObject *) 1) // special failure return code
 #define PYBIND11_STRINGIFY(x) #x
 #define PYBIND11_TOSTRING(x) PYBIND11_STRINGIFY(x)
 #define PYBIND11_CONCAT(first, second) first##second
 #define PYBIND11_ENSURE_INTERNALS_READY pybind11::detail::get_internals();
 
@@ -358,39 +401,23 @@
                          "but the interpreter version is incompatible: %s.",                      \
                          compiled_ver,                                                            \
                          runtime_ver);                                                            \
             return nullptr;                                                                       \
         }                                                                                         \
     }
 
-#if PY_VERSION_HEX >= 0x03030000
-
-#    define PYBIND11_CATCH_INIT_EXCEPTIONS                                                        \
-        catch (pybind11::error_already_set & e) {                                                 \
-            pybind11::raise_from(e, PyExc_ImportError, "initialization failed");                  \
-            return nullptr;                                                                       \
-        }                                                                                         \
-        catch (const std::exception &e) {                                                         \
-            PyErr_SetString(PyExc_ImportError, e.what());                                         \
-            return nullptr;                                                                       \
-        }
-
-#else
-
-#    define PYBIND11_CATCH_INIT_EXCEPTIONS                                                        \
-        catch (pybind11::error_already_set & e) {                                                 \
-            PyErr_SetString(PyExc_ImportError, e.what());                                         \
-            return nullptr;                                                                       \
-        }                                                                                         \
-        catch (const std::exception &e) {                                                         \
-            PyErr_SetString(PyExc_ImportError, e.what());                                         \
-            return nullptr;                                                                       \
-        }
-
-#endif
+#define PYBIND11_CATCH_INIT_EXCEPTIONS                                                            \
+    catch (pybind11::error_already_set & e) {                                                     \
+        pybind11::raise_from(e, PyExc_ImportError, "initialization failed");                      \
+        return nullptr;                                                                           \
+    }                                                                                             \
+    catch (const std::exception &e) {                                                             \
+        ::pybind11::set_error(PyExc_ImportError, e.what());                                       \
+        return nullptr;                                                                           \
+    }
 
 /** \rst
     ***Deprecated in favor of PYBIND11_MODULE***
 
     This macro creates the entry point that will be invoked when the Python interpreter
     imports a plugin library. Please create a `module_` in the function body and return
     the pointer to its underlying Python object at the end.
@@ -414,15 +441,15 @@
         }                                                                                         \
         PYBIND11_CATCH_INIT_EXCEPTIONS                                                            \
     }                                                                                             \
     PyObject *pybind11_init()
 
 /** \rst
     This macro creates the entry point that will be invoked when the Python interpreter
-    imports an extension module. The module name is given as the fist argument and it
+    imports an extension module. The module name is given as the first argument and it
     should not be in quotes. The second macro argument defines a variable of type
     `py::module_` which can be used to initialize the module.
 
     The entry point is marked as "maybe unused" to aid dead-code detection analysis:
     since the entry point is typically only looked up at runtime and not referenced
     during translation, it would otherwise appear as unused ("dead") code.
 
@@ -479,15 +506,15 @@
         value is a pointer. This is the default conversion policy for function
         arguments when calling Python functions manually from C++ code (i.e. via
         handle::operator()). You probably won't need to use this. */
     automatic_reference,
 
     /** Reference an existing object (i.e. do not create a new copy) and take
         ownership. Python will call the destructor and delete operator when the
-        objects reference count reaches zero. Undefined behavior ensues when
+        object's reference count reaches zero. Undefined behavior ensues when
         the C++ side does the same.. */
     take_ownership,
 
     /** Create a new copy of the returned object, which will be owned by
         Python. This policy is comparably safe because the lifetimes of the two
         instances are decoupled. */
     copy,
@@ -495,24 +522,24 @@
     /** Use std::move to move the return value contents into a new instance
         that will be owned by Python. This policy is comparably safe because the
         lifetimes of the two instances (move source and destination) are
         decoupled. */
     move,
 
     /** Reference an existing object, but do not take ownership. The C++ side
-        is responsible for managing the objects lifetime and deallocating it
+        is responsible for managing the object's lifetime and deallocating it
         when it is no longer used. Warning: undefined behavior will ensue when
         the C++ side deletes an object that is still referenced and used by
         Python. */
     reference,
 
     /** This policy only applies to methods and properties. It references the
         object without taking ownership similar to the above
         return_value_policy::reference policy. In contrast to that policy, the
-        function or propertys implicit this argument (called the parent) is
+        function or property's implicit this argument (called the parent) is
         considered to be the the owner of the return value (the child).
         pybind11 then couples the lifetime of the parent to the child via a
         reference relationship that ensures that the parent cannot be garbage
         collected while Python is still using the child. More advanced
         variations of this scheme are also possible using combinations of
         return_value_policy::reference and the keep_alive call policy */
     reference_internal
@@ -611,15 +638,15 @@
     static constexpr uint8_t status_instance_registered = 2;
 };
 
 static_assert(std::is_standard_layout<instance>::value,
               "Internal error: `pybind11::detail::instance` is not standard layout!");
 
 /// from __cpp_future__ import (convenient aliases from C++14/17)
-#if defined(PYBIND11_CPP14) && (!defined(_MSC_VER) || _MSC_VER >= 1910)
+#if defined(PYBIND11_CPP14)
 using std::conditional_t;
 using std::enable_if_t;
 using std::remove_cv_t;
 using std::remove_reference_t;
 #else
 template <bool B, typename T = void>
 using enable_if_t = typename std::enable_if<B, T>::type;
@@ -639,14 +666,18 @@
 struct remove_cvref {
     using type = remove_cv_t<remove_reference_t<T>>;
 };
 template <class T>
 using remove_cvref_t = typename remove_cvref<T>::type;
 #endif
 
+/// Example usage: is_same_ignoring_cvref<T, PyObject *>::value
+template <typename T, typename U>
+using is_same_ignoring_cvref = std::is_same<detail::remove_cvref_t<T>, U>;
+
 /// Index sequences
 #if defined(PYBIND11_CPP14)
 using std::index_sequence;
 using std::make_index_sequence;
 #else
 template <size_t...>
 struct index_sequence {};
@@ -732,15 +763,24 @@
 struct remove_class<R (C::*)(A...)> {
     using type = R(A...);
 };
 template <typename C, typename R, typename... A>
 struct remove_class<R (C::*)(A...) const> {
     using type = R(A...);
 };
-
+#ifdef __cpp_noexcept_function_type
+template <typename C, typename R, typename... A>
+struct remove_class<R (C::*)(A...) noexcept> {
+    using type = R(A...);
+};
+template <typename C, typename R, typename... A>
+struct remove_class<R (C::*)(A...) const noexcept> {
+    using type = R(A...);
+};
+#endif
 /// Helper template to strip away type modifiers
 template <typename T>
 struct intrinsic_type {
     using type = T;
 };
 template <typename T>
 struct intrinsic_type<const T> {
@@ -874,18 +914,20 @@
     static std::true_type check(Base<Us...> *);
     static std::false_type check(...);
 };
 
 /// Check if a template is the base of a type. For example:
 /// `is_template_base_of<Base, T>` is true if `struct T : Base<U> {}` where U can be anything
 template <template <typename...> class Base, typename T>
+// Sadly, all MSVC versions incl. 2022 need the workaround, even in C++20 mode.
+// See also: https://github.com/pybind/pybind11/pull/3741
 #if !defined(_MSC_VER)
 using is_template_base_of
     = decltype(is_template_base_of_impl<Base>::check((intrinsic_t<T> *) nullptr));
-#else // MSVC2015 has trouble with decltype in template aliases
+#else
 struct is_template_base_of
     : decltype(is_template_base_of_impl<Base>::check((intrinsic_t<T> *) nullptr)) {
 };
 #endif
 
 /// Check if T is an instantiation of the template `Class`. For example:
 /// `is_instantiation<shared_ptr, T>` is true if `T == shared_ptr<U>` where U can be anything.
@@ -947,30 +989,21 @@
 using expand_side_effects = bool[];
 #    define PYBIND11_EXPAND_SIDE_EFFECTS(PATTERN)                                                 \
         (void) pybind11::detail::expand_side_effects { ((PATTERN), void(), false)..., false }
 #endif
 
 PYBIND11_NAMESPACE_END(detail)
 
-#if defined(_MSC_VER)
-#    pragma warning(push)
-#    pragma warning(disable : 4275)
-//     warning C4275: An exported class was derived from a class that wasn't exported.
-//     Can be ignored when derived from a STL class.
-#endif
 /// C++ bindings of builtin Python exceptions
 class PYBIND11_EXPORT_EXCEPTION builtin_exception : public std::runtime_error {
 public:
     using std::runtime_error::runtime_error;
     /// Set the error using the Python C API
     virtual void set_error() const = 0;
 };
-#if defined(_MSC_VER)
-#    pragma warning(pop)
-#endif
 
 #define PYBIND11_RUNTIME_EXCEPTION(name, type)                                                    \
     class PYBIND11_EXPORT_EXCEPTION name : public builtin_exception {                             \
     public:                                                                                       \
         using builtin_exception::builtin_exception;                                               \
         name() : name("") {}                                                                      \
         void set_error() const override { PyErr_SetString(type, what()); }                        \
@@ -986,23 +1019,34 @@
 PYBIND11_RUNTIME_EXCEPTION(attribute_error, PyExc_AttributeError)
 PYBIND11_RUNTIME_EXCEPTION(cast_error, PyExc_RuntimeError) /// Thrown when pybind11::cast or
                                                            /// handle::call fail due to a type
                                                            /// casting error
 PYBIND11_RUNTIME_EXCEPTION(reference_cast_error, PyExc_RuntimeError) /// Used internally
 
 [[noreturn]] PYBIND11_NOINLINE void pybind11_fail(const char *reason) {
+    assert(!PyErr_Occurred());
     throw std::runtime_error(reason);
 }
 [[noreturn]] PYBIND11_NOINLINE void pybind11_fail(const std::string &reason) {
+    assert(!PyErr_Occurred());
     throw std::runtime_error(reason);
 }
 
 template <typename T, typename SFINAE = void>
 struct format_descriptor {};
 
+template <typename T>
+struct format_descriptor<
+    T,
+    detail::enable_if_t<detail::is_same_ignoring_cvref<T, PyObject *>::value>> {
+    static constexpr const char c = 'O';
+    static constexpr const char value[2] = {c, '\0'};
+    static std::string format() { return std::string(1, c); }
+};
+
 PYBIND11_NAMESPACE_BEGIN(detail)
 // Returns the index of the given type in the type char array below, and in the list in numpy.h
 // The order here is: bool; 8 ints ((signed,unsigned)x(8,16,32,64)bits); float,double,long double;
 // complex float,double,long double.  Note that the long double types only participate when long
 // double is actually longer than double (it isn't under MSVC).
 // NB: not only the string below but also complex.h and numpy.h rely on this order.
 template <typename T, typename SFINAE = void>
@@ -1040,29 +1084,28 @@
 
 #endif
 
 /// RAII wrapper that temporarily clears any Python error state
 struct error_scope {
     PyObject *type, *value, *trace;
     error_scope() { PyErr_Fetch(&type, &value, &trace); }
+    error_scope(const error_scope &) = delete;
+    error_scope &operator=(const error_scope &) = delete;
     ~error_scope() { PyErr_Restore(type, value, trace); }
 };
 
 /// Dummy destructor wrapper that can be used to expose classes with a private destructor
 struct nodelete {
     template <typename T>
     void operator()(T *) {}
 };
 
 PYBIND11_NAMESPACE_BEGIN(detail)
 template <typename... Args>
 struct overload_cast_impl {
-    // NOLINTNEXTLINE(modernize-use-equals-default):  MSVC 2015 needs this
-    constexpr overload_cast_impl() {}
-
     template <typename Return>
     constexpr auto operator()(Return (*pf)(Args...)) const noexcept -> decltype(pf) {
         return pf;
     }
 
     template <typename Return, typename Class>
     constexpr auto operator()(Return (Class::*pmf)(Args...), std::false_type = {}) const noexcept
@@ -1081,16 +1124,15 @@
 // overload_cast requires variable templates: C++14
 #if defined(PYBIND11_CPP14)
 #    define PYBIND11_OVERLOAD_CAST 1
 /// Syntax sugar for resolving overloaded function pointers:
 ///  - regular: static_cast<Return (Class::*)(Arg0, Arg1, Arg2)>(&Class::func)
 ///  - sweet:   overload_cast<Arg0, Arg1, Arg2>(&Class::func)
 template <typename... Args>
-static constexpr detail::overload_cast_impl<Args...> overload_cast = {};
-// MSVC 2015 only accepts this particular initialization syntax for this variable template.
+static constexpr detail::overload_cast_impl<Args...> overload_cast{};
 #endif
 
 /// Const member function selector for overload_cast
 ///  - regular: static_cast<Return (Class::*)(Arg) const>(&Class::func)
 ///  - sweet:   overload_cast<Arg>(&Class::func, const_)
 static constexpr auto const_ = std::true_type{};
 
@@ -1168,15 +1210,15 @@
         return nullptr;
     }
 #endif
 }
 
 // For silencing "unused" compiler warnings in special situations.
 template <typename... Args>
-#if defined(_MSC_VER) && _MSC_VER >= 1910 && _MSC_VER < 1920 // MSVC 2017
+#if defined(_MSC_VER) && _MSC_VER < 1920 // MSVC 2017
 constexpr
 #endif
     inline void
     silence_unused_warnings(Args &&...) {
 }
 
 // MSVC warning C4100: Unreferenced formal parameter
@@ -1191,20 +1233,35 @@
 #if defined(__GNUG__) && !defined(__clang__) && !defined(__INTEL_COMPILER)
 #    define PYBIND11_WORKAROUND_INCORRECT_GCC_UNUSED_BUT_SET_PARAMETER(...)                       \
         detail::silence_unused_warnings(__VA_ARGS__)
 #else
 #    define PYBIND11_WORKAROUND_INCORRECT_GCC_UNUSED_BUT_SET_PARAMETER(...)
 #endif
 
-#if defined(_MSC_VER) // All versions (as of July 2021).
-
-// warning C4127: Conditional expression is constant
-constexpr inline bool silence_msvc_c4127(bool cond) { return cond; }
-
-#    define PYBIND11_SILENCE_MSVC_C4127(...) ::pybind11::detail::silence_msvc_c4127(__VA_ARGS__)
-
-#else
-#    define PYBIND11_SILENCE_MSVC_C4127(...) __VA_ARGS__
+#if defined(__clang__)                                                                            \
+    && (defined(__apple_build_version__) /* AppleClang 13.0.0.13000029 was the only data point    \
+                                            available. */                                         \
+        || (__clang_major__ >= 7                                                                  \
+            && __clang_major__ <= 12) /* Clang 3, 5, 13, 14, 15 do not generate the warning. */   \
+    )
+#    define PYBIND11_DETECTED_CLANG_WITH_MISLEADING_CALL_STD_MOVE_EXPLICITLY_WARNING
+// Example:
+// tests/test_kwargs_and_defaults.cpp:46:68: error: local variable 'args' will be copied despite
+// being returned by name [-Werror,-Wreturn-std-move]
+//     m.def("args_function", [](py::args args) -> py::tuple { return args; });
+//                                                                    ^~~~
+// test_kwargs_and_defaults.cpp:46:68: note: call 'std::move' explicitly to avoid copying
+//     m.def("args_function", [](py::args args) -> py::tuple { return args; });
+//                                                                    ^~~~
+//                                                                    std::move(args)
+#endif
+
+// Pybind offers detailed error messages by default for all builts that are debug (through the
+// negation of NDEBUG). This can also be manually enabled by users, for any builds, through
+// defining PYBIND11_DETAILED_ERROR_MESSAGES. This information is primarily useful for those
+// who are writing (as opposed to merely using) libraries that use pybind11.
+#if !defined(PYBIND11_DETAILED_ERROR_MESSAGES) && !defined(NDEBUG)
+#    define PYBIND11_DETAILED_ERROR_MESSAGES
 #endif
 
 PYBIND11_NAMESPACE_END(detail)
 PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `python_prtree-0.6.0/third/pybind11/include/pybind11/detail/descr.h` & `python_prtree-0.6.1/third/pybind11/include/pybind11/detail/descr.h`

 * *Files 4% similar despite different names*

```diff
@@ -139,19 +139,32 @@
 constexpr descr<0> concat() { return {}; }
 
 template <size_t N, typename... Ts>
 constexpr descr<N, Ts...> concat(const descr<N, Ts...> &descr) {
     return descr;
 }
 
+#ifdef __cpp_fold_expressions
+template <size_t N1, size_t N2, typename... Ts1, typename... Ts2>
+constexpr descr<N1 + N2 + 2, Ts1..., Ts2...> operator,(const descr<N1, Ts1...> &a,
+                                                       const descr<N2, Ts2...> &b) {
+    return a + const_name(", ") + b;
+}
+
+template <size_t N, typename... Ts, typename... Args>
+constexpr auto concat(const descr<N, Ts...> &d, const Args &...args) {
+    return (d, ..., args);
+}
+#else
 template <size_t N, typename... Ts, typename... Args>
 constexpr auto concat(const descr<N, Ts...> &d, const Args &...args)
     -> decltype(std::declval<descr<N + 2, Ts...>>() + concat(args...)) {
     return d + const_name(", ") + concat(args...);
 }
+#endif
 
 template <size_t N, typename... Ts>
 constexpr descr<N + 2, Ts...> type_descr(const descr<N, Ts...> &descr) {
     return const_name("{") + descr + const_name("}");
 }
 
 PYBIND11_NAMESPACE_END(detail)
```

### Comparing `python_prtree-0.6.0/third/pybind11/include/pybind11/detail/init.h` & `python_prtree-0.6.1/third/pybind11/include/pybind11/detail/init.h`

 * *Files 2% similar despite different names*

```diff
@@ -8,14 +8,17 @@
 */
 
 #pragma once
 
 #include "class.h"
 
 PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
+
+PYBIND11_WARNING_DISABLE_MSVC(4127)
+
 PYBIND11_NAMESPACE_BEGIN(detail)
 
 template <>
 class type_caster<value_and_holder> {
 public:
     bool load(handle h, bool) {
         value = reinterpret_cast<value_and_holder *>(h.ptr());
@@ -58,15 +61,15 @@
 // Failing fallback version of the above for a no-alias class (always returns false)
 template <typename /*Class*/>
 constexpr bool is_alias(void *) {
     return false;
 }
 
 // Constructs and returns a new object; if the given arguments don't map to a constructor, we fall
-// back to brace aggregate initiailization so that for aggregate initialization can be used with
+// back to brace aggregate initialization so that for aggregate initialization can be used with
 // py::init, e.g.  `py::init<int, int>` to initialize a `struct T { int a; int b; }`.  For
 // non-aggregate types, we need to use an ordinary T(...) constructor (invoking as `T{...}` usually
 // works, but will not do the expected thing when `T` has an `initializer_list<T>` constructor).
 template <typename Class,
           typename... Args,
           detail::enable_if_t<std::is_constructible<Class, Args...>::value, int> = 0>
 inline Class *construct_or_initialize(Args &&...args) {
@@ -111,15 +114,15 @@
 // If we don't need an alias (because this class doesn't have one, or because the final type is
 // inherited on the Python side) we can simply take over ownership.  Otherwise we need to try to
 // construct an Alias from the returned base instance.
 template <typename Class>
 void construct(value_and_holder &v_h, Cpp<Class> *ptr, bool need_alias) {
     PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(need_alias);
     no_nullptr(ptr);
-    if (PYBIND11_SILENCE_MSVC_C4127(Class::has_alias) && need_alias && !is_alias<Class>(ptr)) {
+    if (Class::has_alias && need_alias && !is_alias<Class>(ptr)) {
         // We're going to try to construct an alias by moving the cpp type.  Whether or not
         // that succeeds, we still need to destroy the original cpp pointer (either the
         // moved away leftover, if the alias construction works, or the value itself if we
         // throw an error), but we can't just call `delete ptr`: it might have a special
         // deleter, or might be shared_from_this.  So we construct a holder around it as if
         // it was a normal instance, then steal the holder away into a local variable; thus
         // the holder and destruction happens when we leave the C++ scope, and the holder
@@ -152,15 +155,15 @@
 // constructors).
 template <typename Class>
 void construct(value_and_holder &v_h, Holder<Class> holder, bool need_alias) {
     PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(need_alias);
     auto *ptr = holder_helper<Holder<Class>>::get(holder);
     no_nullptr(ptr);
     // If we need an alias, check that the held pointer is actually an alias instance
-    if (PYBIND11_SILENCE_MSVC_C4127(Class::has_alias) && need_alias && !is_alias<Class>(ptr)) {
+    if (Class::has_alias && need_alias && !is_alias<Class>(ptr)) {
         throw type_error("pybind11::init(): construction failed: returned holder-wrapped instance "
                          "is not an alias instance");
     }
 
     v_h.value_ptr() = ptr;
     v_h.type->init_instance(v_h.inst, &holder);
 }
@@ -168,30 +171,30 @@
 // return-by-value version 1: returning a cpp class by value.  If the class has an alias and an
 // alias is required the alias must have an `Alias(Cpp &&)` constructor so that we can construct
 // the alias from the base when needed (i.e. because of Python-side inheritance).  When we don't
 // need it, we simply move-construct the cpp value into a new instance.
 template <typename Class>
 void construct(value_and_holder &v_h, Cpp<Class> &&result, bool need_alias) {
     PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(need_alias);
-    static_assert(std::is_move_constructible<Cpp<Class>>::value,
+    static_assert(is_move_constructible<Cpp<Class>>::value,
                   "pybind11::init() return-by-value factory function requires a movable class");
-    if (PYBIND11_SILENCE_MSVC_C4127(Class::has_alias) && need_alias) {
+    if (Class::has_alias && need_alias) {
         construct_alias_from_cpp<Class>(is_alias_constructible<Class>{}, v_h, std::move(result));
     } else {
         v_h.value_ptr() = new Cpp<Class>(std::move(result));
     }
 }
 
 // return-by-value version 2: returning a value of the alias type itself.  We move-construct an
 // Alias instance (even if no the python-side inheritance is involved).  The is intended for
 // cases where Alias initialization is always desired.
 template <typename Class>
 void construct(value_and_holder &v_h, Alias<Class> &&result, bool) {
     static_assert(
-        std::is_move_constructible<Alias<Class>>::value,
+        is_move_constructible<Alias<Class>>::value,
         "pybind11::init() return-by-alias-value factory function requires a movable alias class");
     v_h.value_ptr() = new Alias<Class>(std::move(result));
 }
 
 // Implementing class for py::init<...>()
 template <typename... Args>
 struct constructor {
@@ -202,18 +205,19 @@
             [](value_and_holder &v_h, Args... args) {
                 v_h.value_ptr() = construct_or_initialize<Cpp<Class>>(std::forward<Args>(args)...);
             },
             is_new_style_constructor(),
             extra...);
     }
 
-    template <typename Class,
-              typename... Extra,
-              enable_if_t<Class::has_alias && std::is_constructible<Cpp<Class>, Args...>::value,
-                          int> = 0>
+    template <
+        typename Class,
+        typename... Extra,
+        enable_if_t<Class::has_alias && std::is_constructible<Cpp<Class>, Args...>::value, int>
+        = 0>
     static void execute(Class &cl, const Extra &...extra) {
         cl.def(
             "__init__",
             [](value_and_holder &v_h, Args... args) {
                 if (Py_TYPE(v_h.inst) == v_h.type->type) {
                     v_h.value_ptr()
                         = construct_or_initialize<Cpp<Class>>(std::forward<Args>(args)...);
@@ -222,18 +226,19 @@
                         = construct_or_initialize<Alias<Class>>(std::forward<Args>(args)...);
                 }
             },
             is_new_style_constructor(),
             extra...);
     }
 
-    template <typename Class,
-              typename... Extra,
-              enable_if_t<Class::has_alias && !std::is_constructible<Cpp<Class>, Args...>::value,
-                          int> = 0>
+    template <
+        typename Class,
+        typename... Extra,
+        enable_if_t<Class::has_alias && !std::is_constructible<Cpp<Class>, Args...>::value, int>
+        = 0>
     static void execute(Class &cl, const Extra &...extra) {
         cl.def(
             "__init__",
             [](value_and_holder &v_h, Args... args) {
                 v_h.value_ptr()
                     = construct_or_initialize<Alias<Class>>(std::forward<Args>(args)...);
             },
@@ -241,18 +246,19 @@
             extra...);
     }
 };
 
 // Implementing class for py::init_alias<...>()
 template <typename... Args>
 struct alias_constructor {
-    template <typename Class,
-              typename... Extra,
-              enable_if_t<Class::has_alias && std::is_constructible<Alias<Class>, Args...>::value,
-                          int> = 0>
+    template <
+        typename Class,
+        typename... Extra,
+        enable_if_t<Class::has_alias && std::is_constructible<Alias<Class>, Args...>::value, int>
+        = 0>
     static void execute(Class &cl, const Extra &...extra) {
         cl.def(
             "__init__",
             [](value_and_holder &v_h, Args... args) {
                 v_h.value_ptr()
                     = construct_or_initialize<Alias<Class>>(std::forward<Args>(args)...);
             },
@@ -421,8 +427,8 @@
             is_new_style_constructor(),
             extra...);
     }
 };
 
 PYBIND11_NAMESPACE_END(initimpl)
 PYBIND11_NAMESPACE_END(detail)
-PYBIND11_NAMESPACE_END(pybind11)
+PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
```

### Comparing `python_prtree-0.6.0/third/pybind11/include/pybind11/detail/internals.h` & `python_prtree-0.6.1/third/pybind11/include/pybind11/detail/internals.h`

 * *Files 13% similar despite different names*

```diff
@@ -5,14 +5,20 @@
 
     All rights reserved. Use of this source code is governed by a
     BSD-style license that can be found in the LICENSE file.
 */
 
 #pragma once
 
+#include "common.h"
+
+#if defined(WITH_THREAD) && defined(PYBIND11_SIMPLE_GIL_MANAGEMENT)
+#    include "../gil.h"
+#endif
+
 #include "../pytypes.h"
 
 #include <exception>
 
 /// Tracks the `internals` and `type_info` ABI version independent of the main library version.
 ///
 /// Some portions of the code use an ABI that is conditional depending on this
@@ -24,38 +30,55 @@
 /// newer ABI.
 ///
 /// WARNING: If you choose to manually increase the ABI version, note that
 /// pybind11 may not be tested as thoroughly with a non-default ABI version, and
 /// further ABI-incompatible changes may be made before the ABI is officially
 /// changed to the new version.
 #ifndef PYBIND11_INTERNALS_VERSION
-#    define PYBIND11_INTERNALS_VERSION 4
+#    if PY_VERSION_HEX >= 0x030C0000 || defined(_MSC_VER)
+// Version bump for Python 3.12+, before first 3.12 beta release.
+// Version bump for MSVC piggy-backed on PR #4779. See comments there.
+#        define PYBIND11_INTERNALS_VERSION 5
+#    else
+#        define PYBIND11_INTERNALS_VERSION 4
+#    endif
 #endif
 
+// This requirement is mainly to reduce the support burden (see PR #4570).
+static_assert(PY_VERSION_HEX < 0x030C0000 || PYBIND11_INTERNALS_VERSION >= 5,
+              "pybind11 ABI version 5 is the minimum for Python 3.12+");
+
 PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 
 using ExceptionTranslator = void (*)(std::exception_ptr);
 
 PYBIND11_NAMESPACE_BEGIN(detail)
 
+constexpr const char *internals_function_record_capsule_name = "pybind11_function_record_capsule";
+
 // Forward declarations
 inline PyTypeObject *make_static_property_type();
 inline PyTypeObject *make_default_metaclass();
 inline PyObject *make_object_base_type(PyTypeObject *metaclass);
 
 // The old Python Thread Local Storage (TLS) API is deprecated in Python 3.7 in favor of the new
 // Thread Specific Storage (TSS) API.
 #if PY_VERSION_HEX >= 0x03070000
 // Avoid unnecessary allocation of `Py_tss_t`, since we cannot use
 // `Py_LIMITED_API` anyway.
 #    if PYBIND11_INTERNALS_VERSION > 4
 #        define PYBIND11_TLS_KEY_REF Py_tss_t &
-#        ifdef __GNUC__
-// Clang on macOS warns due to `Py_tss_NEEDS_INIT` not specifying an initializer
-// for every field.
+#        if defined(__clang__)
+#            define PYBIND11_TLS_KEY_INIT(var)                                                    \
+                _Pragma("clang diagnostic push")                                         /**/     \
+                    _Pragma("clang diagnostic ignored \"-Wmissing-field-initializers\"") /**/     \
+                    Py_tss_t var                                                                  \
+                    = Py_tss_NEEDS_INIT;                                                          \
+                _Pragma("clang diagnostic pop")
+#        elif defined(__GNUC__) && !defined(__INTEL_COMPILER)
 #            define PYBIND11_TLS_KEY_INIT(var)                                                    \
                 _Pragma("GCC diagnostic push")                                         /**/       \
                     _Pragma("GCC diagnostic ignored \"-Wmissing-field-initializers\"") /**/       \
                     Py_tss_t var                                                                  \
                     = Py_tss_NEEDS_INIT;                                                          \
                 _Pragma("GCC diagnostic pop")
 #        else
@@ -78,15 +101,15 @@
 #    endif
 #else
 // Usually an int but a long on Cygwin64 with Python 3.x
 #    define PYBIND11_TLS_KEY_REF decltype(PyThread_create_key())
 #    define PYBIND11_TLS_KEY_INIT(var) PYBIND11_TLS_KEY_REF var = 0;
 #    define PYBIND11_TLS_KEY_CREATE(var) (((var) = PyThread_create_key()) != -1)
 #    define PYBIND11_TLS_GET_VALUE(key) PyThread_get_key_value((key))
-#    if PY_MAJOR_VERSION < 3 || defined(PYPY_VERSION)
+#    if defined(PYPY_VERSION)
 // On CPython < 3.4 and on PyPy, `PyThread_set_key_value` strangely does not set
 // the value if it has already been set.  Instead, it must first be deleted and
 // then set again.
 inline void tls_replace_value(PYBIND11_TLS_KEY_REF key, void *value) {
     PyThread_delete_key_value(key);
     PyThread_set_key_value(key, value);
 }
@@ -102,15 +125,16 @@
 
 // Python loads modules by default with dlopen with the RTLD_LOCAL flag; under libc++ and possibly
 // other STLs, this means `typeid(A)` from one module won't equal `typeid(A)` from another module
 // even when `A` is the same, non-hidden-visibility type (e.g. from a common include).  Under
 // libstdc++, this doesn't happen: equality and the type_index hash are based on the type name,
 // which works.  If not under a known-good stl, provide our own name-based hash and equality
 // functions that use the type name.
-#if defined(__GLIBCXX__)
+#if (PYBIND11_INTERNALS_VERSION <= 4 && defined(__GLIBCXX__))                                     \
+    || (PYBIND11_INTERNALS_VERSION >= 5 && !defined(_LIBCPP_VERSION))
 inline bool same_type(const std::type_info &lhs, const std::type_info &rhs) { return lhs == rhs; }
 using type_hash = std::hash<std::type_index>;
 using type_equal_to = std::equal_to<std::type_index>;
 #else
 inline bool same_type(const std::type_info &lhs, const std::type_info &rhs) {
     return lhs.name() == rhs.name() || std::strcmp(lhs.name(), rhs.name()) == 0;
 }
@@ -165,19 +189,31 @@
 #endif
     std::forward_list<std::string> static_strings; // Stores the std::strings backing
                                                    // detail::c_str()
     PyTypeObject *static_property_type;
     PyTypeObject *default_metaclass;
     PyObject *instance_base;
 #if defined(WITH_THREAD)
+    // Unused if PYBIND11_SIMPLE_GIL_MANAGEMENT is defined:
     PYBIND11_TLS_KEY_INIT(tstate)
 #    if PYBIND11_INTERNALS_VERSION > 4
     PYBIND11_TLS_KEY_INIT(loader_life_support_tls_key)
 #    endif // PYBIND11_INTERNALS_VERSION > 4
+    // Unused if PYBIND11_SIMPLE_GIL_MANAGEMENT is defined:
     PyInterpreterState *istate = nullptr;
+
+#    if PYBIND11_INTERNALS_VERSION > 4
+    // Note that we have to use a std::string to allocate memory to ensure a unique address
+    // We want unique addresses since we use pointer equality to compare function records
+    std::string function_record_capsule_name = internals_function_record_capsule_name;
+#    endif
+
+    internals() = default;
+    internals(const internals &other) = delete;
+    internals &operator=(const internals &other) = delete;
     ~internals() {
 #    if PYBIND11_INTERNALS_VERSION > 4
         PYBIND11_TLS_FREE(loader_life_support_tls_key);
 #    endif // PYBIND11_INTERNALS_VERSION > 4
 
         // This destructor is called *after* Py_Finalize() in finalize_interpreter().
         // That *SHOULD BE* fine. The following details what happens when PyThread_tss_free is
@@ -257,17 +293,20 @@
 #        define PYBIND11_STDLIB "_libstdcpp"
 #    else
 #        define PYBIND11_STDLIB ""
 #    endif
 #endif
 
 /// On Linux/OSX, changes in __GXX_ABI_VERSION__ indicate ABI incompatibility.
+/// On MSVC, changes in _MSC_VER may indicate ABI incompatibility (#2898).
 #ifndef PYBIND11_BUILD_ABI
 #    if defined(__GXX_ABI_VERSION)
 #        define PYBIND11_BUILD_ABI "_cxxabi" PYBIND11_TOSTRING(__GXX_ABI_VERSION)
+#    elif defined(_MSC_VER)
+#        define PYBIND11_BUILD_ABI "_mscver" PYBIND11_TOSTRING(_MSC_VER)
 #    else
 #        define PYBIND11_BUILD_ABI ""
 #    endif
 #endif
 
 #ifndef PYBIND11_INTERNALS_KIND
 #    if defined(WITH_THREAD)
@@ -290,15 +329,14 @@
 /// Each module locally stores a pointer to the `internals` data. The data
 /// itself is shared among modules with the same `PYBIND11_INTERNALS_ID`.
 inline internals **&get_internals_pp() {
     static internals **internals_pp = nullptr;
     return internals_pp;
 }
 
-#if PY_VERSION_HEX >= 0x03030000
 // forward decl
 inline void translate_exception(std::exception_ptr);
 
 template <class T,
           enable_if_t<std::is_same<std::nested_exception, remove_cvref_t<T>>::value, int> = 0>
 bool handle_nested_exception(const T &exc, const std::exception_ptr &p) {
     std::exception_ptr nested = exc.nested_ptr();
@@ -314,30 +352,20 @@
 bool handle_nested_exception(const T &exc, const std::exception_ptr &p) {
     if (const auto *nep = dynamic_cast<const std::nested_exception *>(std::addressof(exc))) {
         return handle_nested_exception(*nep, p);
     }
     return false;
 }
 
-#else
-
-template <class T>
-bool handle_nested_exception(const T &, std::exception_ptr &) {
-    return false;
-}
-#endif
-
 inline bool raise_err(PyObject *exc_type, const char *msg) {
-#if PY_VERSION_HEX >= 0x03030000
     if (PyErr_Occurred()) {
         raise_from(exc_type, msg);
         return true;
     }
-#endif
-    PyErr_SetString(exc_type, msg);
+    set_error(exc_type, msg);
     return false;
 }
 
 inline void translate_exception(std::exception_ptr p) {
     if (!p) {
         return;
     }
@@ -408,35 +436,78 @@
     } catch (const builtin_exception &e) {
         e.set_error();
         return;
     }
 }
 #endif
 
+inline object get_python_state_dict() {
+    object state_dict;
+#if PYBIND11_INTERNALS_VERSION <= 4 || PY_VERSION_HEX < 0x03080000 || defined(PYPY_VERSION)
+    state_dict = reinterpret_borrow<object>(PyEval_GetBuiltins());
+#else
+#    if PY_VERSION_HEX < 0x03090000
+    PyInterpreterState *istate = _PyInterpreterState_Get();
+#    else
+    PyInterpreterState *istate = PyInterpreterState_Get();
+#    endif
+    if (istate) {
+        state_dict = reinterpret_borrow<object>(PyInterpreterState_GetDict(istate));
+    }
+#endif
+    if (!state_dict) {
+        raise_from(PyExc_SystemError, "pybind11::detail::get_python_state_dict() FAILED");
+        throw error_already_set();
+    }
+    return state_dict;
+}
+
+inline object get_internals_obj_from_state_dict(handle state_dict) {
+    return reinterpret_borrow<object>(dict_getitemstring(state_dict.ptr(), PYBIND11_INTERNALS_ID));
+}
+
+inline internals **get_internals_pp_from_capsule(handle obj) {
+    void *raw_ptr = PyCapsule_GetPointer(obj.ptr(), /*name=*/nullptr);
+    if (raw_ptr == nullptr) {
+        raise_from(PyExc_SystemError, "pybind11::detail::get_internals_pp_from_capsule() FAILED");
+        throw error_already_set();
+    }
+    return static_cast<internals **>(raw_ptr);
+}
+
 /// Return a reference to the current `internals` data
 PYBIND11_NOINLINE internals &get_internals() {
     auto **&internals_pp = get_internals_pp();
     if (internals_pp && *internals_pp) {
         return **internals_pp;
     }
 
+#if defined(WITH_THREAD)
+#    if defined(PYBIND11_SIMPLE_GIL_MANAGEMENT)
+    gil_scoped_acquire gil;
+#    else
     // Ensure that the GIL is held since we will need to make Python calls.
     // Cannot use py::gil_scoped_acquire here since that constructor calls get_internals.
     struct gil_scoped_acquire_local {
         gil_scoped_acquire_local() : state(PyGILState_Ensure()) {}
+        gil_scoped_acquire_local(const gil_scoped_acquire_local &) = delete;
+        gil_scoped_acquire_local &operator=(const gil_scoped_acquire_local &) = delete;
         ~gil_scoped_acquire_local() { PyGILState_Release(state); }
         const PyGILState_STATE state;
     } gil;
+#    endif
+#endif
+    error_scope err_scope;
 
-    PYBIND11_STR_TYPE id(PYBIND11_INTERNALS_ID);
-    auto builtins = handle(PyEval_GetBuiltins());
-    if (builtins.contains(id) && isinstance<capsule>(builtins[id])) {
-        internals_pp = static_cast<internals **>(capsule(builtins[id]));
-
-        // We loaded builtins through python's builtins, which means that our `error_already_set`
+    dict state_dict = get_python_state_dict();
+    if (object internals_obj = get_internals_obj_from_state_dict(state_dict)) {
+        internals_pp = get_internals_pp_from_capsule(internals_obj);
+    }
+    if (internals_pp && *internals_pp) {
+        // We loaded the internals through `state_dict`, which means that our `error_already_set`
         // and `builtin_exception` may be different local classes than the ones set up in the
         // initial exception translator, below, so add another for our local exception classes.
         //
         // libstdc++ doesn't require this (types there are identified only by name)
         // libc++ with CPython doesn't require this (types are explicitly exported)
         // libc++ with PyPy still need it, awaiting further investigation
 #if !defined(__GLIBCXX__)
@@ -446,32 +517,31 @@
         if (!internals_pp) {
             internals_pp = new internals *();
         }
         auto *&internals_ptr = *internals_pp;
         internals_ptr = new internals();
 #if defined(WITH_THREAD)
 
-#    if PY_VERSION_HEX < 0x03090000
-        PyEval_InitThreads();
-#    endif
         PyThreadState *tstate = PyThreadState_Get();
+        // NOLINTNEXTLINE(bugprone-assignment-in-if-condition)
         if (!PYBIND11_TLS_KEY_CREATE(internals_ptr->tstate)) {
             pybind11_fail("get_internals: could not successfully initialize the tstate TSS key!");
         }
         PYBIND11_TLS_REPLACE_VALUE(internals_ptr->tstate, tstate);
 
 #    if PYBIND11_INTERNALS_VERSION > 4
+        // NOLINTNEXTLINE(bugprone-assignment-in-if-condition)
         if (!PYBIND11_TLS_KEY_CREATE(internals_ptr->loader_life_support_tls_key)) {
             pybind11_fail("get_internals: could not successfully initialize the "
                           "loader_life_support TSS key!");
         }
 #    endif
         internals_ptr->istate = tstate->interp;
 #endif
-        builtins[id] = capsule(internals_pp);
+        state_dict[PYBIND11_INTERNALS_ID] = capsule(internals_pp);
         internals_ptr->registered_exception_translators.push_front(&translate_exception);
         internals_ptr->static_property_type = make_static_property_type();
         internals_ptr->default_metaclass = make_default_metaclass();
         internals_ptr->instance_base = make_object_base_type(internals_ptr->default_metaclass);
     }
     return **internals_pp;
 }
@@ -495,14 +565,15 @@
     // plausible number).
     PYBIND11_TLS_KEY_INIT(loader_life_support_tls_key)
 
     // Holds the shared TLS key for the loader_life_support stack.
     struct shared_loader_life_support_data {
         PYBIND11_TLS_KEY_INIT(loader_life_support_tls_key)
         shared_loader_life_support_data() {
+            // NOLINTNEXTLINE(bugprone-assignment-in-if-condition)
             if (!PYBIND11_TLS_KEY_CREATE(loader_life_support_tls_key)) {
                 pybind11_fail("local_internals: could not successfully initialize the "
                               "loader_life_support TLS key!");
             }
         }
         // We can't help but leak the TLS key, because Python never unloads extension modules.
     };
@@ -518,29 +589,53 @@
             = static_cast<shared_loader_life_support_data *>(ptr)->loader_life_support_tls_key;
     }
 #endif //  defined(WITH_THREAD) && PYBIND11_INTERNALS_VERSION == 4
 };
 
 /// Works like `get_internals`, but for things which are locally registered.
 inline local_internals &get_local_internals() {
-    static local_internals locals;
-    return locals;
+    // Current static can be created in the interpreter finalization routine. If the later will be
+    // destroyed in another static variable destructor, creation of this static there will cause
+    // static deinitialization fiasco. In order to avoid it we avoid destruction of the
+    // local_internals static. One can read more about the problem and current solution here:
+    // https://google.github.io/styleguide/cppguide.html#Static_and_Global_Variables
+    static auto *locals = new local_internals();
+    return *locals;
 }
 
 /// Constructs a std::string with the given arguments, stores it in `internals`, and returns its
 /// `c_str()`.  Such strings objects have a long storage duration -- the internal strings are only
 /// cleared when the program exits or after interpreter shutdown (when embedding), and so are
 /// suitable for c-style strings needed by Python internals (such as PyTypeObject's tp_name).
 template <typename... Args>
 const char *c_str(Args &&...args) {
     auto &strings = get_internals().static_strings;
     strings.emplace_front(std::forward<Args>(args)...);
     return strings.front().c_str();
 }
 
+inline const char *get_function_record_capsule_name() {
+#if PYBIND11_INTERNALS_VERSION > 4
+    return get_internals().function_record_capsule_name.c_str();
+#else
+    return nullptr;
+#endif
+}
+
+// Determine whether or not the following capsule contains a pybind11 function record.
+// Note that we use `internals` to make sure that only ABI compatible records are touched.
+//
+// This check is currently used in two places:
+// - An important optimization in functional.h to avoid overhead in C++ -> Python -> C++
+// - The sibling feature of cpp_function to allow overloads
+inline bool is_function_record_capsule(const capsule &cap) {
+    // Pointer equality as we rely on internals() to ensure unique pointers
+    return cap.name() == get_function_record_capsule_name();
+}
+
 PYBIND11_NAMESPACE_END(detail)
 
 /// Returns a named pointer that is shared among all extension modules (using the same
 /// pybind11 version) running in the current interpreter. Names starting with underscores
 /// are reserved for internal usage. Returns `nullptr` if no matching entry was found.
 PYBIND11_NOINLINE void *get_shared_data(const std::string &name) {
     auto &internals = detail::get_internals();
```

### Comparing `python_prtree-0.6.0/third/pybind11/include/pybind11/detail/type_caster_base.h` & `python_prtree-0.6.1/third/pybind11/include/pybind11/detail/type_caster_base.h`

 * *Files 18% similar despite different names*

```diff
@@ -98,16 +98,30 @@
 
 // Gets the cache entry for the given type, creating it if necessary.  The return value is the pair
 // returned by emplace, i.e. an iterator for the entry and a bool set to `true` if the entry was
 // just created.
 inline std::pair<decltype(internals::registered_types_py)::iterator, bool>
 all_type_info_get_cache(PyTypeObject *type);
 
+// Band-aid workaround to fix a subtle but serious bug in a minimalistic fashion. See PR #4762.
+inline void all_type_info_add_base_most_derived_first(std::vector<type_info *> &bases,
+                                                      type_info *addl_base) {
+    for (auto it = bases.begin(); it != bases.end(); it++) {
+        type_info *existing_base = *it;
+        if (PyType_IsSubtype(addl_base->type, existing_base->type) != 0) {
+            bases.insert(it, addl_base);
+            return;
+        }
+    }
+    bases.push_back(addl_base);
+}
+
 // Populates a just-created cache entry.
 PYBIND11_NOINLINE void all_type_info_populate(PyTypeObject *t, std::vector<type_info *> &bases) {
+    assert(bases.empty());
     std::vector<PyTypeObject *> check;
     for (handle parent : reinterpret_borrow<tuple>(t->tp_bases)) {
         check.push_back((PyTypeObject *) parent.ptr());
     }
 
     auto const &type_dict = get_internals().registered_types_py;
     for (size_t i = 0; i < check.size(); i++) {
@@ -132,15 +146,15 @@
                 for (auto *known : bases) {
                     if (known == tinfo) {
                         found = true;
                         break;
                     }
                 }
                 if (!found) {
-                    bases.push_back(tinfo);
+                    all_type_info_add_base_most_derived_first(bases, tinfo);
                 }
             }
         } else if (type->tp_bases) {
             // It's some python type, so keep follow its bases classes to look for one or more
             // registered types
             if (i + 1 == check.size()) {
                 // When we're at the end, we can pop off the current element to avoid growing
@@ -221,16 +235,16 @@
     if (auto *gtype = get_global_type_info(tp)) {
         return gtype;
     }
 
     if (throw_if_missing) {
         std::string tname = tp.name();
         detail::clean_type_id(tname);
-        pybind11_fail("pybind11::detail::get_type_info: unable to find type info for \"" + tname
-                      + "\"");
+        pybind11_fail("pybind11::detail::get_type_info: unable to find type info for \""
+                      + std::move(tname) + '"');
     }
     return nullptr;
 }
 
 PYBIND11_NOINLINE handle get_type_handle(const std::type_info &tp, bool throw_if_missing) {
     detail::type_info *type_info = get_type_info(tp, throw_if_missing);
     return handle(type_info ? ((PyObject *) type_info->type) : nullptr);
@@ -254,17 +268,17 @@
     instance *inst = nullptr;
     size_t index = 0u;
     const detail::type_info *type = nullptr;
     void **vh = nullptr;
 
     // Main constructor for a found value/holder:
     value_and_holder(instance *i, const detail::type_info *type, size_t vpos, size_t index)
-        : inst{i}, index{index}, type{type}, vh{inst->simple_layout
-                                                    ? inst->simple_value_holder
-                                                    : &inst->nonsimple.values_and_holders[vpos]} {}
+        : inst{i}, index{index}, type{type},
+          vh{inst->simple_layout ? inst->simple_value_holder
+                                 : &inst->nonsimple.values_and_holders[vpos]} {}
 
     // Default constructor (used to signal a value-and-holder not found by get_value_and_holder())
     value_and_holder() = default;
 
     // Used for past-the-end iterator
     explicit value_and_holder(size_t index) : index{index} {}
 
@@ -318,26 +332,37 @@
     using type_vec = std::vector<detail::type_info *>;
     const type_vec &tinfo;
 
 public:
     explicit values_and_holders(instance *inst)
         : inst{inst}, tinfo(all_type_info(Py_TYPE(inst))) {}
 
+    explicit values_and_holders(PyObject *obj)
+        : inst{nullptr}, tinfo(all_type_info(Py_TYPE(obj))) {
+        if (!tinfo.empty()) {
+            inst = reinterpret_cast<instance *>(obj);
+        }
+    }
+
     struct iterator {
     private:
         instance *inst = nullptr;
         const type_vec *types = nullptr;
         value_and_holder curr;
         friend struct values_and_holders;
-        iterator(instance *inst, const type_vec *tinfo)
-            : inst{inst}, types{tinfo},
-              curr(inst /* instance */,
-                   types->empty() ? nullptr : (*types)[0] /* type info */,
-                   0, /* vpos: (non-simple types only): the first vptr comes first */
-                   0 /* index */) {}
+        iterator(instance *inst, const type_vec *tinfo) : inst{inst}, types{tinfo} {
+            if (inst != nullptr) {
+                assert(!types->empty());
+                curr = value_and_holder(
+                    inst /* instance */,
+                    (*types)[0] /* type info */,
+                    0, /* vpos: (non-simple types only): the first vptr comes first */
+                    0 /* index */);
+            }
+        }
         // Past-the-end iterator:
         explicit iterator(size_t end) : curr(end) {}
 
     public:
         bool operator==(const iterator &other) const { return curr.index == other.curr.index; }
         bool operator!=(const iterator &other) const { return curr.index != other.curr.index; }
         iterator &operator++() {
@@ -360,14 +385,24 @@
         while (it != endit && it->type != find_type) {
             ++it;
         }
         return it;
     }
 
     size_t size() { return tinfo.size(); }
+
+    // Band-aid workaround to fix a subtle but serious bug in a minimalistic fashion. See PR #4762.
+    bool is_redundant_value_and_holder(const value_and_holder &vh) {
+        for (size_t i = 0; i < vh.index; i++) {
+            if (PyType_IsSubtype(tinfo[i]->type, tinfo[vh.index]->type) != 0) {
+                return true;
+            }
+        }
+        return false;
+    }
 };
 
 /**
  * Extracts C++ value and holder pointer references from an instance (which may contain multiple
  * values/holders for python-side multiple inheritance) that match the given type.  Throws an error
  * if the given type (or ValueType, if omitted) is not a pybind11 base of the given instance.  If
  * `find_type` is omitted (or explicitly specified as nullptr) the first value/holder are returned,
@@ -390,23 +425,24 @@
         return *it;
     }
 
     if (!throw_if_missing) {
         return value_and_holder();
     }
 
-#if defined(NDEBUG)
-    pybind11_fail("pybind11::detail::instance::get_value_and_holder: "
-                  "type is not a pybind11 base of the given instance "
-                  "(compile in debug mode for type details)");
-#else
+#if defined(PYBIND11_DETAILED_ERROR_MESSAGES)
     pybind11_fail("pybind11::detail::instance::get_value_and_holder: `"
                   + get_fully_qualified_tp_name(find_type->type)
                   + "' is not a pybind11 base of the given `"
                   + get_fully_qualified_tp_name(Py_TYPE(this)) + "' instance");
+#else
+    pybind11_fail(
+        "pybind11::detail::instance::get_value_and_holder: "
+        "type is not a pybind11 base of the given instance "
+        "(#define PYBIND11_DETAILED_ERROR_MESSAGES or compile in debug mode for type details)");
 #endif
 }
 
 PYBIND11_NOINLINE void instance::allocate_layout() {
     const auto &tinfo = all_type_info(Py_TYPE(this));
 
     const size_t n_types = tinfo.size();
@@ -435,29 +471,23 @@
             space += t->holder_size_in_ptrs; // holder instance
         }
         size_t flags_at = space;
         space += size_in_ptrs(n_types); // status bytes (holder_constructed and
                                         // instance_registered)
 
         // Allocate space for flags, values, and holders, and initialize it to 0 (flags and values,
-        // in particular, need to be 0).  Use Python's memory allocation functions: in Python 3.6
-        // they default to using pymalloc, which is designed to be efficient for small allocations
-        // like the one we're doing here; in earlier versions (and for larger allocations) they are
-        // just wrappers around malloc.
-#if PY_VERSION_HEX >= 0x03050000
+        // in particular, need to be 0).  Use Python's memory allocation
+        // functions: Python is using pymalloc, which is designed to be
+        // efficient for small allocations like the one we're doing here;
+        // for larger allocations they are just wrappers around malloc.
+        // TODO: is this still true for pure Python 3.6?
         nonsimple.values_and_holders = (void **) PyMem_Calloc(space, sizeof(void *));
         if (!nonsimple.values_and_holders) {
             throw std::bad_alloc();
         }
-#else
-        nonsimple.values_and_holders = (void **) PyMem_New(void *, space);
-        if (!nonsimple.values_and_holders)
-            throw std::bad_alloc();
-        std::memset(nonsimple.values_and_holders, 0, space * sizeof(void *));
-#endif
         nonsimple.status
             = reinterpret_cast<std::uint8_t *>(&nonsimple.values_and_holders[flags_at]);
     }
     owned = true;
 }
 
 // NOLINTNEXTLINE(readability-make-member-function-const)
@@ -471,78 +501,14 @@
     handle type = detail::get_type_handle(tp, false);
     if (!type) {
         return false;
     }
     return isinstance(obj, type);
 }
 
-PYBIND11_NOINLINE std::string error_string() {
-    if (!PyErr_Occurred()) {
-        PyErr_SetString(PyExc_RuntimeError, "Unknown internal error occurred");
-        return "Unknown internal error occurred";
-    }
-
-    error_scope scope; // Preserve error state
-
-    std::string errorString;
-    if (scope.type) {
-        errorString += handle(scope.type).attr("__name__").cast<std::string>();
-        errorString += ": ";
-    }
-    if (scope.value) {
-        errorString += (std::string) str(scope.value);
-    }
-
-    PyErr_NormalizeException(&scope.type, &scope.value, &scope.trace);
-
-#if PY_MAJOR_VERSION >= 3
-    if (scope.trace != nullptr) {
-        PyException_SetTraceback(scope.value, scope.trace);
-    }
-#endif
-
-#if !defined(PYPY_VERSION)
-    if (scope.trace) {
-        auto *trace = (PyTracebackObject *) scope.trace;
-
-        /* Get the deepest trace possible */
-        while (trace->tb_next) {
-            trace = trace->tb_next;
-        }
-
-        PyFrameObject *frame = trace->tb_frame;
-        Py_XINCREF(frame);
-        errorString += "\n\nAt:\n";
-        while (frame) {
-#    if PY_VERSION_HEX >= 0x030900B1
-            PyCodeObject *f_code = PyFrame_GetCode(frame);
-#    else
-            PyCodeObject *f_code = frame->f_code;
-            Py_INCREF(f_code);
-#    endif
-            int lineno = PyFrame_GetLineNumber(frame);
-            errorString += "  " + handle(f_code->co_filename).cast<std::string>() + "("
-                           + std::to_string(lineno)
-                           + "): " + handle(f_code->co_name).cast<std::string>() + "\n";
-            Py_DECREF(f_code);
-#    if PY_VERSION_HEX >= 0x030900B1
-            auto *b_frame = PyFrame_GetBack(frame);
-#    else
-            auto *b_frame = frame->f_back;
-            Py_XINCREF(b_frame);
-#    endif
-            Py_DECREF(frame);
-            frame = b_frame;
-        }
-    }
-#endif
-
-    return errorString;
-}
-
 PYBIND11_NOINLINE handle get_object_handle(const void *ptr, const detail::type_info *type) {
     auto &instances = get_internals().registered_instances;
     auto range = instances.equal_range(ptr);
     for (auto it = range.first; it != range.second; ++it) {
         for (const auto &vh : values_and_holders(it->second)) {
             if (vh.type == type) {
                 return handle((PyObject *) it->second);
@@ -551,22 +517,18 @@
     }
     return handle();
 }
 
 inline PyThreadState *get_thread_state_unchecked() {
 #if defined(PYPY_VERSION)
     return PyThreadState_GET();
-#elif PY_VERSION_HEX < 0x03000000
-    return _PyThreadState_Current;
-#elif PY_VERSION_HEX < 0x03050000
-    return (PyThreadState *) _Py_atomic_load_relaxed(&_PyThreadState_Current);
-#elif PY_VERSION_HEX < 0x03050200
-    return (PyThreadState *) _PyThreadState_Current.value;
-#else
+#elif PY_VERSION_HEX < 0x030D0000
     return _PyThreadState_UncheckedGet();
+#else
+    return PyThreadState_GetUnchecked();
 #endif
 }
 
 // Forward declarations
 void keep_alive_impl(handle nurse, handle patient);
 inline PyObject *make_new_instance(PyTypeObject *type);
 
@@ -618,42 +580,44 @@
                 wrapper->owned = false;
                 break;
 
             case return_value_policy::copy:
                 if (copy_constructor) {
                     valueptr = copy_constructor(src);
                 } else {
-#if defined(NDEBUG)
-                    throw cast_error("return_value_policy = copy, but type is "
-                                     "non-copyable! (compile in debug mode for details)");
-#else
+#if defined(PYBIND11_DETAILED_ERROR_MESSAGES)
                     std::string type_name(tinfo->cpptype->name());
                     detail::clean_type_id(type_name);
                     throw cast_error("return_value_policy = copy, but type " + type_name
                                      + " is non-copyable!");
+#else
+                    throw cast_error("return_value_policy = copy, but type is "
+                                     "non-copyable! (#define PYBIND11_DETAILED_ERROR_MESSAGES or "
+                                     "compile in debug mode for details)");
 #endif
                 }
                 wrapper->owned = true;
                 break;
 
             case return_value_policy::move:
                 if (move_constructor) {
                     valueptr = move_constructor(src);
                 } else if (copy_constructor) {
                     valueptr = copy_constructor(src);
                 } else {
-#if defined(NDEBUG)
-                    throw cast_error("return_value_policy = move, but type is neither "
-                                     "movable nor copyable! "
-                                     "(compile in debug mode for details)");
-#else
+#if defined(PYBIND11_DETAILED_ERROR_MESSAGES)
                     std::string type_name(tinfo->cpptype->name());
                     detail::clean_type_id(type_name);
                     throw cast_error("return_value_policy = move, but type " + type_name
                                      + " is neither movable nor copyable!");
+#else
+                    throw cast_error("return_value_policy = move, but type is neither "
+                                     "movable nor copyable! "
+                                     "(#define PYBIND11_DETAILED_ERROR_MESSAGES or compile in "
+                                     "debug mode for details)");
 #endif
                 }
                 wrapper->owned = true;
                 break;
 
             case return_value_policy::reference_internal:
                 valueptr = src;
@@ -855,15 +819,15 @@
             return {src, const_cast<const type_info *>(tpi)};
         }
 
         // Not found, set error:
         std::string tname = rtti_type ? rtti_type->name() : cast_type.name();
         detail::clean_type_id(tname);
         std::string msg = "Unregistered type : " + tname;
-        PyErr_SetString(PyExc_TypeError, msg.c_str());
+        set_error(PyExc_TypeError, msg.c_str());
         return {nullptr, nullptr};
     }
 
     const type_info *typeinfo = nullptr;
     const std::type_info *cpptype = nullptr;
     void *value = nullptr;
 };
@@ -891,49 +855,207 @@
 using movable_cast_op_type
     = conditional_t<std::is_pointer<typename std::remove_reference<T>::type>::value,
                     typename std::add_pointer<intrinsic_t<T>>::type,
                     conditional_t<std::is_rvalue_reference<T>::value,
                                   typename std::add_rvalue_reference<intrinsic_t<T>>::type,
                                   typename std::add_lvalue_reference<intrinsic_t<T>>::type>>;
 
-// std::is_copy_constructible isn't quite enough: it lets std::vector<T> (and similar) through when
-// T is non-copyable, but code containing such a copy constructor fails to actually compile.
-template <typename T, typename SFINAE = void>
-struct is_copy_constructible : std::is_copy_constructible<T> {};
+// Does the container have a mapped type and is it recursive?
+// Implemented by specializations below.
+template <typename Container, typename SFINAE = void>
+struct container_mapped_type_traits {
+    static constexpr bool has_mapped_type = false;
+    static constexpr bool has_recursive_mapped_type = false;
+};
 
-// Specialization for types that appear to be copy constructible but also look like stl containers
-// (we specifically check for: has `value_type` and `reference` with `reference = value_type&`): if
-// so, copy constructability depends on whether the value_type is copy constructible.
 template <typename Container>
-struct is_copy_constructible<
+struct container_mapped_type_traits<
     Container,
-    enable_if_t<
-        all_of<std::is_copy_constructible<Container>,
-               std::is_same<typename Container::value_type &, typename Container::reference>,
-               // Avoid infinite recursion
-               negation<std::is_same<Container, typename Container::value_type>>>::value>>
-    : is_copy_constructible<typename Container::value_type> {};
+    typename std::enable_if<
+        std::is_same<typename Container::mapped_type, Container>::value>::type> {
+    static constexpr bool has_mapped_type = true;
+    static constexpr bool has_recursive_mapped_type = true;
+};
+
+template <typename Container>
+struct container_mapped_type_traits<
+    Container,
+    typename std::enable_if<
+        negation<std::is_same<typename Container::mapped_type, Container>>::value>::type> {
+    static constexpr bool has_mapped_type = true;
+    static constexpr bool has_recursive_mapped_type = false;
+};
+
+// Does the container have a value type and is it recursive?
+// Implemented by specializations below.
+template <typename Container, typename SFINAE = void>
+struct container_value_type_traits : std::false_type {
+    static constexpr bool has_value_type = false;
+    static constexpr bool has_recursive_value_type = false;
+};
+
+template <typename Container>
+struct container_value_type_traits<
+    Container,
+    typename std::enable_if<
+        std::is_same<typename Container::value_type, Container>::value>::type> {
+    static constexpr bool has_value_type = true;
+    static constexpr bool has_recursive_value_type = true;
+};
+
+template <typename Container>
+struct container_value_type_traits<
+    Container,
+    typename std::enable_if<
+        negation<std::is_same<typename Container::value_type, Container>>::value>::type> {
+    static constexpr bool has_value_type = true;
+    static constexpr bool has_recursive_value_type = false;
+};
+
+/*
+ * Tag to be used for representing the bottom of recursively defined types.
+ * Define this tag so we don't have to use void.
+ */
+struct recursive_bottom {};
+
+/*
+ * Implementation detail of `recursive_container_traits` below.
+ * `T` is the `value_type` of the container, which might need to be modified to
+ * avoid recursive types and const types.
+ */
+template <typename T, bool is_this_a_map>
+struct impl_type_to_check_recursively {
+    /*
+     * If the container is recursive, then no further recursion should be done.
+     */
+    using if_recursive = recursive_bottom;
+    /*
+     * Otherwise yield `T` unchanged.
+     */
+    using if_not_recursive = T;
+};
+
+/*
+ * For pairs - only as value type of a map -, the first type should remove the `const`.
+ * Also, if the map is recursive, then the recursive checking should consider
+ * the first type only.
+ */
+template <typename A, typename B>
+struct impl_type_to_check_recursively<std::pair<A, B>, /* is_this_a_map = */ true> {
+    using if_recursive = typename std::remove_const<A>::type;
+    using if_not_recursive = std::pair<typename std::remove_const<A>::type, B>;
+};
+
+/*
+ * Implementation of `recursive_container_traits` below.
+ */
+template <typename Container, typename SFINAE = void>
+struct impl_recursive_container_traits {
+    using type_to_check_recursively = recursive_bottom;
+};
+
+template <typename Container>
+struct impl_recursive_container_traits<
+    Container,
+    typename std::enable_if<container_value_type_traits<Container>::has_value_type>::type> {
+    static constexpr bool is_recursive
+        = container_mapped_type_traits<Container>::has_recursive_mapped_type
+          || container_value_type_traits<Container>::has_recursive_value_type;
+    /*
+     * This member dictates which type Pybind11 should check recursively in traits
+     * such as `is_move_constructible`, `is_copy_constructible`, `is_move_assignable`, ...
+     * Direct access to `value_type` should be avoided:
+     * 1. `value_type` might recursively contain the type again
+     * 2. `value_type` of STL map types is `std::pair<A const, B>`, the `const`
+     *    should be removed.
+     *
+     */
+    using type_to_check_recursively = typename std::conditional<
+        is_recursive,
+        typename impl_type_to_check_recursively<
+            typename Container::value_type,
+            container_mapped_type_traits<Container>::has_mapped_type>::if_recursive,
+        typename impl_type_to_check_recursively<
+            typename Container::value_type,
+            container_mapped_type_traits<Container>::has_mapped_type>::if_not_recursive>::type;
+};
+
+/*
+ * This trait defines the `type_to_check_recursively` which is needed to properly
+ * handle recursively defined traits such as `is_move_constructible` without going
+ * into an infinite recursion.
+ * Should be used instead of directly accessing the `value_type`.
+ * It cancels the recursion by returning the `recursive_bottom` tag.
+ *
+ * The default definition of `type_to_check_recursively` is as follows:
+ *
+ * 1. By default, it is `recursive_bottom`, so that the recursion is canceled.
+ * 2. If the type is non-recursive and defines a `value_type`, then the `value_type` is used.
+ *    If the `value_type` is a pair and a `mapped_type` is defined,
+ *    then the `const` is removed from the first type.
+ * 3. If the type is recursive and `value_type` is not a pair, then `recursive_bottom` is returned.
+ * 4. If the type is recursive and `value_type` is a pair and a `mapped_type` is defined,
+ *    then `const` is removed from the first type and the first type is returned.
+ *
+ * This behavior can be extended by the user as seen in test_stl_binders.cpp.
+ *
+ * This struct is exactly the same as impl_recursive_container_traits.
+ * The duplication achieves that user-defined specializations don't compete
+ * with internal specializations, but take precedence.
+ */
+template <typename Container, typename SFINAE = void>
+struct recursive_container_traits : impl_recursive_container_traits<Container> {};
+
+template <typename T>
+struct is_move_constructible
+    : all_of<std::is_move_constructible<T>,
+             is_move_constructible<
+                 typename recursive_container_traits<T>::type_to_check_recursively>> {};
+
+template <>
+struct is_move_constructible<recursive_bottom> : std::true_type {};
+
+// Likewise for std::pair
+// (after C++17 it is mandatory that the move constructor not exist when the two types aren't
+// themselves move constructible, but this can not be relied upon when T1 or T2 are themselves
+// containers).
+template <typename T1, typename T2>
+struct is_move_constructible<std::pair<T1, T2>>
+    : all_of<is_move_constructible<T1>, is_move_constructible<T2>> {};
+
+// std::is_copy_constructible isn't quite enough: it lets std::vector<T> (and similar) through when
+// T is non-copyable, but code containing such a copy constructor fails to actually compile.
+template <typename T>
+struct is_copy_constructible
+    : all_of<std::is_copy_constructible<T>,
+             is_copy_constructible<
+                 typename recursive_container_traits<T>::type_to_check_recursively>> {};
+
+template <>
+struct is_copy_constructible<recursive_bottom> : std::true_type {};
 
 // Likewise for std::pair
 // (after C++17 it is mandatory that the copy constructor not exist when the two types aren't
 // themselves copy constructible, but this can not be relied upon when T1 or T2 are themselves
 // containers).
 template <typename T1, typename T2>
 struct is_copy_constructible<std::pair<T1, T2>>
     : all_of<is_copy_constructible<T1>, is_copy_constructible<T2>> {};
 
 // The same problems arise with std::is_copy_assignable, so we use the same workaround.
-template <typename T, typename SFINAE = void>
-struct is_copy_assignable : std::is_copy_assignable<T> {};
-template <typename Container>
-struct is_copy_assignable<Container,
-                          enable_if_t<all_of<std::is_copy_assignable<Container>,
-                                             std::is_same<typename Container::value_type &,
-                                                          typename Container::reference>>::value>>
-    : is_copy_assignable<typename Container::value_type> {};
+template <typename T>
+struct is_copy_assignable
+    : all_of<
+          std::is_copy_assignable<T>,
+          is_copy_assignable<typename recursive_container_traits<T>::type_to_check_recursively>> {
+};
+
+template <>
+struct is_copy_assignable<recursive_bottom> : std::true_type {};
+
 template <typename T1, typename T2>
 struct is_copy_assignable<std::pair<T1, T2>>
     : all_of<is_copy_assignable<T1>, is_copy_assignable<T2>> {};
 
 PYBIND11_NAMESPACE_END(detail)
 
 // polymorphic_type_hook<itype>::get(src, tinfo) determines whether the object pointed
@@ -1063,21 +1185,34 @@
        decltype argument to apply SFINAE to the public copy/move constructors.*/
     template <typename T, typename = enable_if_t<is_copy_constructible<T>::value>>
     static auto make_copy_constructor(const T *)
         -> decltype(new T(std::declval<const T>()), Constructor{}) {
         return [](const void *arg) -> void * { return new T(*reinterpret_cast<const T *>(arg)); };
     }
 
-    template <typename T, typename = enable_if_t<std::is_move_constructible<T>::value>>
+    template <typename T, typename = enable_if_t<is_move_constructible<T>::value>>
     static auto make_move_constructor(const T *)
         -> decltype(new T(std::declval<T &&>()), Constructor{}) {
         return [](const void *arg) -> void * {
             return new T(std::move(*const_cast<T *>(reinterpret_cast<const T *>(arg))));
         };
     }
 
     static Constructor make_copy_constructor(...) { return nullptr; }
     static Constructor make_move_constructor(...) { return nullptr; }
 };
 
+inline std::string quote_cpp_type_name(const std::string &cpp_type_name) {
+    return cpp_type_name; // No-op for now. See PR #4888
+}
+
+PYBIND11_NOINLINE std::string type_info_description(const std::type_info &ti) {
+    if (auto *type_data = get_type_info(ti)) {
+        handle th((PyObject *) type_data->type);
+        return th.attr("__module__").cast<std::string>() + '.'
+               + th.attr("__qualname__").cast<std::string>();
+    }
+    return quote_cpp_type_name(clean_type_id(ti.name()));
+}
+
 PYBIND11_NAMESPACE_END(detail)
 PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
```

### Comparing `python_prtree-0.6.0/third/pybind11/include/pybind11/detail/typeid.h` & `python_prtree-0.6.1/third/pybind11/include/pybind11/detail/typeid.h`

 * *Files 14% similar despite different names*

```diff
@@ -16,14 +16,15 @@
 #    include <cxxabi.h>
 #endif
 
 #include "common.h"
 
 PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 PYBIND11_NAMESPACE_BEGIN(detail)
+
 /// Erase all occurrences of a substring
 inline void erase_all(std::string &string, const std::string &search) {
     for (size_t pos = 0;;) {
         pos = string.find(search, pos);
         if (pos == std::string::npos) {
             break;
         }
@@ -42,18 +43,23 @@
 #else
     detail::erase_all(name, "class ");
     detail::erase_all(name, "struct ");
     detail::erase_all(name, "enum ");
 #endif
     detail::erase_all(name, "pybind11::");
 }
+
+inline std::string clean_type_id(const char *typeid_name) {
+    std::string name(typeid_name);
+    detail::clean_type_id(name);
+    return name;
+}
+
 PYBIND11_NAMESPACE_END(detail)
 
 /// Return a string representation of a C++ type
 template <typename T>
 static std::string type_id() {
-    std::string name(typeid(T).name());
-    detail::clean_type_id(name);
-    return name;
+    return detail::clean_type_id(typeid(T).name());
 }
 
 PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
```

### Comparing `python_prtree-0.6.0/third/pybind11/include/pybind11/eigen.h` & `python_prtree-0.6.1/third/pybind11/include/pybind11/eigen/matrix.h`

 * *Files 5% similar despite different names*

```diff
@@ -1,51 +1,48 @@
 /*
-    pybind11/eigen.h: Transparent conversion for dense and sparse Eigen matrices
+    pybind11/eigen/matrix.h: Transparent conversion for dense and sparse Eigen matrices
 
     Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
 
     All rights reserved. Use of this source code is governed by a
     BSD-style license that can be found in the LICENSE file.
 */
 
 #pragma once
 
+#include "../numpy.h"
+#include "common.h"
+
 /* HINT: To suppress warnings originating from the Eigen headers, use -isystem.
    See also:
        https://stackoverflow.com/questions/2579576/i-dir-vs-isystem-dir
        https://stackoverflow.com/questions/1741816/isystem-for-ms-visual-studio-c-compiler
 */
-
-#include "numpy.h"
-
-// The C4127 suppression was introduced for Eigen 3.4.0. In theory we could
-// make it version specific, or even remove it later, but considering that
-// 1. C4127 is generally far more distracting than useful for modern template code, and
-// 2. we definitely want to ignore any MSVC warnings originating from Eigen code,
-// it is probably best to keep this around indefinitely.
-#if defined(_MSC_VER)
-#    pragma warning(push)
-#    pragma warning(disable : 4127) // C4127: conditional expression is constant
+PYBIND11_WARNING_PUSH
+PYBIND11_WARNING_DISABLE_MSVC(5054) // https://github.com/pybind/pybind11/pull/3741
+//       C5054: operator '&': deprecated between enumerations of different types
+#if defined(__MINGW32__)
+PYBIND11_WARNING_DISABLE_GCC("-Wmaybe-uninitialized")
 #endif
 
 #include <Eigen/Core>
 #include <Eigen/SparseCore>
 
-#if defined(_MSC_VER)
-#    pragma warning(pop)
-#endif
+PYBIND11_WARNING_POP
 
 // Eigen prior to 3.2.7 doesn't have proper move constructors--but worse, some classes get implicit
 // move constructors that break things.  We could detect this an explicitly copy, but an extra copy
 // of matrices seems highly undesirable.
 static_assert(EIGEN_VERSION_AT_LEAST(3, 2, 7),
-              "Eigen support in pybind11 requires Eigen >= 3.2.7");
+              "Eigen matrix support in pybind11 requires Eigen >= 3.2.7");
 
 PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 
+PYBIND11_WARNING_DISABLE_MSVC(4127)
+
 // Provide a convenience alias for easier pass-by-ref usage with fully dynamic strides:
 using EigenDStride = Eigen::Stride<Eigen::Dynamic, Eigen::Dynamic>;
 template <typename MatrixType>
 using EigenDRef = Eigen::Ref<MatrixType, 0, EigenDStride>;
 template <typename MatrixType>
 using EigenDMap = Eigen::Map<MatrixType, 0, EigenDStride>;
 
@@ -105,18 +102,24 @@
     EigenConformable(EigenIndex r, EigenIndex c, EigenIndex stride)
         : EigenConformable(r, c, r == 1 ? c * stride : stride, c == 1 ? r : r * stride) {}
 
     template <typename props>
     bool stride_compatible() const {
         // To have compatible strides, we need (on both dimensions) one of fully dynamic strides,
         // matching strides, or a dimension size of 1 (in which case the stride value is
-        // irrelevant)
-        return !negativestrides
-               && (props::inner_stride == Eigen::Dynamic || props::inner_stride == stride.inner()
-                   || (EigenRowMajor ? cols : rows) == 1)
+        // irrelevant). Alternatively, if any dimension size is 0, the strides are not relevant
+        // (and numpy  1.23 sets the strides to 0 in that case, so we need to check explicitly).
+        if (negativestrides) {
+            return false;
+        }
+        if (rows == 0 || cols == 0) {
+            return true;
+        }
+        return (props::inner_stride == Eigen::Dynamic || props::inner_stride == stride.inner()
+                || (EigenRowMajor ? cols : rows) == 1)
                && (props::outer_stride == Eigen::Dynamic || props::outer_stride == stride.outer()
                    || (EigenRowMajor ? rows : cols) == 1);
     }
     // NOLINTNEXTLINE(google-explicit-constructor)
     operator bool() const { return conformable; }
 };
 
@@ -173,29 +176,28 @@
         }
 
         if (dims == 2) { // Matrix type: require exact match (or dynamic)
 
             EigenIndex np_rows = a.shape(0), np_cols = a.shape(1),
                        np_rstride = a.strides(0) / static_cast<ssize_t>(sizeof(Scalar)),
                        np_cstride = a.strides(1) / static_cast<ssize_t>(sizeof(Scalar));
-            if ((PYBIND11_SILENCE_MSVC_C4127(fixed_rows) && np_rows != rows)
-                || (PYBIND11_SILENCE_MSVC_C4127(fixed_cols) && np_cols != cols)) {
+            if ((fixed_rows && np_rows != rows) || (fixed_cols && np_cols != cols)) {
                 return false;
             }
 
             return {np_rows, np_cols, np_rstride, np_cstride};
         }
 
         // Otherwise we're storing an n-vector.  Only one of the strides will be used, but
         // whichever is used, we want the (single) numpy stride value.
         const EigenIndex n = a.shape(0),
                          stride = a.strides(0) / static_cast<ssize_t>(sizeof(Scalar));
 
         if (vector) { // Eigen type is a compile-time vector
-            if (PYBIND11_SILENCE_MSVC_C4127(fixed) && size != n) {
+            if (fixed && size != n) {
                 return false; // Vector size mismatch
             }
             return {rows == 1 ? 1 : n, cols == 1 ? 1 : n, stride};
         }
         if (fixed) {
             // The type has a fixed size, but is not a vector: abort
             return false;
@@ -204,15 +206,15 @@
             // Since this isn't a vector, cols must be != 1.  We allow this only if it exactly
             // equals the number of elements (rows is Dynamic, and so 1 row is allowed).
             if (cols != n) {
                 return false;
             }
             return {1, n, stride};
         } // Otherwise it's either fully dynamic, or column dynamic; both become a column vector
-        if (PYBIND11_SILENCE_MSVC_C4127(fixed_rows) && rows != n) {
+        if (fixed_rows && rows != n) {
             return false;
         }
         return {n, 1, stride};
     }
 
     static constexpr bool show_writeable
         = is_eigen_dense_map<Type>::value && is_eigen_mutable_map<Type>::value;
@@ -282,14 +284,16 @@
 }
 
 // Type caster for regular, dense matrix types (e.g. MatrixXd), but not maps/refs/etc. of dense
 // types.
 template <typename Type>
 struct type_caster<Type, enable_if_t<is_eigen_dense_plain<Type>::value>> {
     using Scalar = typename Type::Scalar;
+    static_assert(!std::is_pointer<Scalar>::value,
+                  PYBIND11_EIGEN_MESSAGE_POINTER_TYPES_ARE_NOT_SUPPORTED);
     using props = EigenProps<Type>;
 
     bool load(handle src, bool convert) {
         // If we're in no-convert mode, only load if given an array of the correct type
         if (!convert && !isinstance<array_t<Scalar>>(src)) {
             return false;
         }
@@ -400,14 +404,17 @@
 private:
     Type value;
 };
 
 // Base class for casting reference/map/block/etc. objects back to python.
 template <typename MapType>
 struct eigen_map_caster {
+    static_assert(!std::is_pointer<typename MapType::Scalar>::value,
+                  PYBIND11_EIGEN_MESSAGE_POINTER_TYPES_ARE_NOT_SUPPORTED);
+
 private:
     using props = EigenProps<MapType>;
 
 public:
     // Directly referencing a ref/map's data is a bit dangerous (whatever the map/ref points to has
     // to stay around), but we'll allow it under the assumption that you know what you're doing
     // (and have an appropriate keep_alive in place).  We return a numpy array pointing directly at
@@ -452,14 +459,16 @@
     Eigen::Ref<PlainObjectType, 0, StrideType>,
     enable_if_t<is_eigen_dense_map<Eigen::Ref<PlainObjectType, 0, StrideType>>::value>>
     : public eigen_map_caster<Eigen::Ref<PlainObjectType, 0, StrideType>> {
 private:
     using Type = Eigen::Ref<PlainObjectType, 0, StrideType>;
     using props = EigenProps<Type>;
     using Scalar = typename props::Scalar;
+    static_assert(!std::is_pointer<Scalar>::value,
+                  PYBIND11_EIGEN_MESSAGE_POINTER_TYPES_ARE_NOT_SUPPORTED);
     using MapType = Eigen::Map<PlainObjectType, 0, StrideType>;
     using Array
         = array_t<Scalar,
                   array::forcecast
                       | ((props::row_major ? props::inner_stride : props::outer_stride) == 1
                              ? array::c_style
                          : (props::row_major ? props::outer_stride : props::inner_stride) == 1
@@ -599,14 +608,17 @@
 
 // type_caster for special matrix types (e.g. DiagonalMatrix), which are EigenBase, but not
 // EigenDense (i.e. they don't have a data(), at least not with the usual matrix layout).
 // load() is not supported, but we can cast them into the python domain by first copying to a
 // regular Eigen::Matrix, then casting that.
 template <typename Type>
 struct type_caster<Type, enable_if_t<is_eigen_other<Type>::value>> {
+    static_assert(!std::is_pointer<typename Type::Scalar>::value,
+                  PYBIND11_EIGEN_MESSAGE_POINTER_TYPES_ARE_NOT_SUPPORTED);
+
 protected:
     using Matrix
         = Eigen::Matrix<typename Type::Scalar, Type::RowsAtCompileTime, Type::ColsAtCompileTime>;
     using props = EigenProps<Matrix>;
 
 public:
     static handle cast(const Type &src, return_value_policy /* policy */, handle /* parent */) {
@@ -627,14 +639,16 @@
     template <typename>
     using cast_op_type = Type;
 };
 
 template <typename Type>
 struct type_caster<Type, enable_if_t<is_eigen_sparse<Type>::value>> {
     using Scalar = typename Type::Scalar;
+    static_assert(!std::is_pointer<Scalar>::value,
+                  PYBIND11_EIGEN_MESSAGE_POINTER_TYPES_ARE_NOT_SUPPORTED);
     using StorageIndex = remove_reference_t<decltype(*std::declval<Type>().outerIndexPtr())>;
     using Index = typename Type::Index;
     static constexpr bool rowMajor = Type::IsRowMajor;
 
     bool load(handle src, bool) {
         if (!src) {
             return false;
@@ -662,15 +676,15 @@
             return false;
         }
 
         value = EigenMapSparseMatrix<Scalar,
                                      Type::Flags &(Eigen::RowMajor | Eigen::ColMajor),
                                      StorageIndex>(shape[0].cast<Index>(),
                                                    shape[1].cast<Index>(),
-                                                   nnz,
+                                                   std::move(nnz),
                                                    outerIndices.mutable_data(),
                                                    innerIndices.mutable_data(),
                                                    values.mutable_data());
 
         return true;
     }
 
@@ -680,16 +694,17 @@
         object matrix_type
             = module_::import("scipy.sparse").attr(rowMajor ? "csr_matrix" : "csc_matrix");
 
         array data(src.nonZeros(), src.valuePtr());
         array outerIndices((rowMajor ? src.rows() : src.cols()) + 1, src.outerIndexPtr());
         array innerIndices(src.nonZeros(), src.innerIndexPtr());
 
-        return matrix_type(std::make_tuple(data, innerIndices, outerIndices),
-                           std::make_pair(src.rows(), src.cols()))
+        return matrix_type(pybind11::make_tuple(
+                               std::move(data), std::move(innerIndices), std::move(outerIndices)),
+                           pybind11::make_tuple(src.rows(), src.cols()))
             .release();
     }
 
     PYBIND11_TYPE_CASTER(Type,
                          const_name<(Type::IsRowMajor) != 0>("scipy.sparse.csr_matrix[",
                                                              "scipy.sparse.csc_matrix[")
                              + npy_format_descriptor<Scalar>::name + const_name("]"));
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `python_prtree-0.6.0/third/pybind11/include/pybind11/embed.h` & `python_prtree-0.6.1/third/pybind11/include/pybind11/embed.h`

 * *Files 18% similar despite different names*

```diff
@@ -15,23 +15,17 @@
 #include <memory>
 #include <vector>
 
 #if defined(PYPY_VERSION)
 #    error Embedding the interpreter is not supported with PyPy
 #endif
 
-#if PY_MAJOR_VERSION >= 3
-#    define PYBIND11_EMBEDDED_MODULE_IMPL(name)                                                   \
-        extern "C" PyObject *pybind11_init_impl_##name();                                         \
-        extern "C" PyObject *pybind11_init_impl_##name() { return pybind11_init_wrapper_##name(); }
-#else
-#    define PYBIND11_EMBEDDED_MODULE_IMPL(name)                                                   \
-        extern "C" void pybind11_init_impl_##name();                                              \
-        extern "C" void pybind11_init_impl_##name() { pybind11_init_wrapper_##name(); }
-#endif
+#define PYBIND11_EMBEDDED_MODULE_IMPL(name)                                                       \
+    extern "C" PyObject *pybind11_init_impl_##name();                                             \
+    extern "C" PyObject *pybind11_init_impl_##name() { return pybind11_init_wrapper_##name(); }
 
 /** \rst
     Add a new module to the table of builtins for the interpreter. Must be
     defined in global scope. The first macro parameter is the name of the
     module (without quotes). The second parameter is the variable which will
     be used as the interface to add functions and classes to the module.
 
@@ -63,115 +57,123 @@
                                                & variable) // NOLINT(bugprone-macro-parentheses)
 
 PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 PYBIND11_NAMESPACE_BEGIN(detail)
 
 /// Python 2.7/3.x compatible version of `PyImport_AppendInittab` and error checks.
 struct embedded_module {
-#if PY_MAJOR_VERSION >= 3
     using init_t = PyObject *(*) ();
-#else
-    using init_t = void (*)();
-#endif
     embedded_module(const char *name, init_t init) {
         if (Py_IsInitialized() != 0) {
             pybind11_fail("Can't add new modules after the interpreter has been initialized");
         }
 
         auto result = PyImport_AppendInittab(name, init);
         if (result == -1) {
             pybind11_fail("Insufficient memory to add a new module");
         }
     }
 };
 
 struct wide_char_arg_deleter {
     void operator()(wchar_t *ptr) const {
-#if PY_VERSION_HEX >= 0x030500f0
         // API docs: https://docs.python.org/3/c-api/sys.html#c.Py_DecodeLocale
         PyMem_RawFree(ptr);
-#else
-        delete[] ptr;
-#endif
     }
 };
 
 inline wchar_t *widen_chars(const char *safe_arg) {
-#if PY_VERSION_HEX >= 0x030500f0
     wchar_t *widened_arg = Py_DecodeLocale(safe_arg, nullptr);
-#else
-    wchar_t *widened_arg = nullptr;
-
-// warning C4996: 'mbstowcs': This function or variable may be unsafe.
-#    if defined(_MSC_VER)
-#        pragma warning(push)
-#        pragma warning(disable : 4996)
-#    endif
+    return widened_arg;
+}
 
-#    if defined(HAVE_BROKEN_MBSTOWCS) && HAVE_BROKEN_MBSTOWCS
-    size_t count = std::strlen(safe_arg);
-#    else
-    size_t count = std::mbstowcs(nullptr, safe_arg, 0);
-#    endif
-    if (count != static_cast<size_t>(-1)) {
-        widened_arg = new wchar_t[count + 1];
-        std::mbstowcs(widened_arg, safe_arg, count + 1);
+inline void precheck_interpreter() {
+    if (Py_IsInitialized() != 0) {
+        pybind11_fail("The interpreter is already running");
     }
+}
 
-#    if defined(_MSC_VER)
-#        pragma warning(pop)
-#    endif
-
+#if !defined(PYBIND11_PYCONFIG_SUPPORT_PY_VERSION_HEX)
+#    define PYBIND11_PYCONFIG_SUPPORT_PY_VERSION_HEX (0x03080000)
 #endif
-    return widened_arg;
-}
 
-/// Python 2.x/3.x-compatible version of `PySys_SetArgv`
-inline void set_interpreter_argv(int argc, const char *const *argv, bool add_program_dir_to_path) {
+#if PY_VERSION_HEX < PYBIND11_PYCONFIG_SUPPORT_PY_VERSION_HEX
+inline void initialize_interpreter_pre_pyconfig(bool init_signal_handlers,
+                                                int argc,
+                                                const char *const *argv,
+                                                bool add_program_dir_to_path) {
+    detail::precheck_interpreter();
+    Py_InitializeEx(init_signal_handlers ? 1 : 0);
+#    if defined(WITH_THREAD) && PY_VERSION_HEX < 0x03070000
+    PyEval_InitThreads();
+#    endif
+
     // Before it was special-cased in python 3.8, passing an empty or null argv
     // caused a segfault, so we have to reimplement the special case ourselves.
     bool special_case = (argv == nullptr || argc <= 0);
 
     const char *const empty_argv[]{"\0"};
     const char *const *safe_argv = special_case ? empty_argv : argv;
     if (special_case) {
         argc = 1;
     }
 
     auto argv_size = static_cast<size_t>(argc);
-#if PY_MAJOR_VERSION >= 3
     // SetArgv* on python 3 takes wchar_t, so we have to convert.
     std::unique_ptr<wchar_t *[]> widened_argv(new wchar_t *[argv_size]);
-    std::vector<std::unique_ptr<wchar_t[], wide_char_arg_deleter>> widened_argv_entries;
+    std::vector<std::unique_ptr<wchar_t[], detail::wide_char_arg_deleter>> widened_argv_entries;
     widened_argv_entries.reserve(argv_size);
     for (size_t ii = 0; ii < argv_size; ++ii) {
-        widened_argv_entries.emplace_back(widen_chars(safe_argv[ii]));
+        widened_argv_entries.emplace_back(detail::widen_chars(safe_argv[ii]));
         if (!widened_argv_entries.back()) {
             // A null here indicates a character-encoding failure or the python
             // interpreter out of memory. Give up.
             return;
         }
         widened_argv[ii] = widened_argv_entries.back().get();
     }
 
     auto *pysys_argv = widened_argv.get();
-#else
-    // python 2.x
-    std::vector<std::string> strings{safe_argv, safe_argv + argv_size};
-    std::vector<char *> char_strings{argv_size};
-    for (std::size_t i = 0; i < argv_size; ++i)
-        char_strings[i] = &strings[i][0];
-    char **pysys_argv = char_strings.data();
-#endif
 
     PySys_SetArgvEx(argc, pysys_argv, static_cast<int>(add_program_dir_to_path));
 }
+#endif
 
 PYBIND11_NAMESPACE_END(detail)
 
+#if PY_VERSION_HEX >= PYBIND11_PYCONFIG_SUPPORT_PY_VERSION_HEX
+inline void initialize_interpreter(PyConfig *config,
+                                   int argc = 0,
+                                   const char *const *argv = nullptr,
+                                   bool add_program_dir_to_path = true) {
+    detail::precheck_interpreter();
+    PyStatus status = PyConfig_SetBytesArgv(config, argc, const_cast<char *const *>(argv));
+    if (PyStatus_Exception(status) != 0) {
+        // A failure here indicates a character-encoding failure or the python
+        // interpreter out of memory. Give up.
+        PyConfig_Clear(config);
+        throw std::runtime_error(PyStatus_IsError(status) != 0 ? status.err_msg
+                                                               : "Failed to prepare CPython");
+    }
+    status = Py_InitializeFromConfig(config);
+    if (PyStatus_Exception(status) != 0) {
+        PyConfig_Clear(config);
+        throw std::runtime_error(PyStatus_IsError(status) != 0 ? status.err_msg
+                                                               : "Failed to init CPython");
+    }
+    if (add_program_dir_to_path) {
+        PyRun_SimpleString("import sys, os.path; "
+                           "sys.path.insert(0, "
+                           "os.path.abspath(os.path.dirname(sys.argv[0])) "
+                           "if sys.argv and os.path.exists(sys.argv[0]) else '')");
+    }
+    PyConfig_Clear(config);
+}
+#endif
+
 /** \rst
     Initialize the Python interpreter. No other pybind11 or CPython API functions can be
     called before this is done; with the exception of `PYBIND11_EMBEDDED_MODULE`. The
     optional `init_signal_handlers` parameter can be used to skip the registration of
     signal handlers (see the `Python documentation`_ for details). Calling this function
     again after the interpreter has already been initialized is a fatal error.
 
@@ -187,21 +189,26 @@
     .. |PySys_SetArgvEx documentation| replace:: ``PySys_SetArgvEx`` documentation
     .. _PySys_SetArgvEx documentation: https://docs.python.org/3/c-api/init.html#c.PySys_SetArgvEx
  \endrst */
 inline void initialize_interpreter(bool init_signal_handlers = true,
                                    int argc = 0,
                                    const char *const *argv = nullptr,
                                    bool add_program_dir_to_path = true) {
-    if (Py_IsInitialized() != 0) {
-        pybind11_fail("The interpreter is already running");
-    }
-
-    Py_InitializeEx(init_signal_handlers ? 1 : 0);
+#if PY_VERSION_HEX < PYBIND11_PYCONFIG_SUPPORT_PY_VERSION_HEX
+    detail::initialize_interpreter_pre_pyconfig(
+        init_signal_handlers, argc, argv, add_program_dir_to_path);
+#else
+    PyConfig config;
+    PyConfig_InitPythonConfig(&config);
+    // See PR #4473 for background
+    config.parse_argv = 0;
 
-    detail::set_interpreter_argv(argc, argv, add_program_dir_to_path);
+    config.install_signal_handlers = init_signal_handlers ? 1 : 0;
+    initialize_interpreter(&config, argc, argv, add_program_dir_to_path);
+#endif
 }
 
 /** \rst
     Shut down the Python interpreter. No pybind11 or CPython API functions can be called
     after this. In addition, pybind11 objects must not outlive the interpreter:
 
     .. code-block:: cpp
@@ -232,24 +239,22 @@
         itself cannot completely unload binary extension modules and there are several
         caveats with regard to interpreter restarting. All the details can be found
         in the CPython documentation. In short, not all interpreter memory may be
         freed, either due to reference cycles or user-created global data.
 
  \endrst */
 inline void finalize_interpreter() {
-    handle builtins(PyEval_GetBuiltins());
-    const char *id = PYBIND11_INTERNALS_ID;
-
     // Get the internals pointer (without creating it if it doesn't exist).  It's possible for the
     // internals to be created during Py_Finalize() (e.g. if a py::capsule calls `get_internals()`
     // during destruction), so we get the pointer-pointer here and check it after Py_Finalize().
     detail::internals **internals_ptr_ptr = detail::get_internals_pp();
-    // It could also be stashed in builtins, so look there too:
-    if (builtins.contains(id) && isinstance<capsule>(builtins[id])) {
-        internals_ptr_ptr = capsule(builtins[id]);
+    // It could also be stashed in state_dict, so look there too:
+    if (object internals_obj
+        = get_internals_obj_from_state_dict(detail::get_python_state_dict())) {
+        internals_ptr_ptr = detail::get_internals_pp_from_capsule(internals_obj);
     }
     // Local internals contains data managed by the current interpreter, so we must clear them to
     // avoid undefined behaviors when initializing another interpreter
     detail::get_local_internals().registered_types_cpp.clear();
     detail::get_local_internals().registered_exception_translators.clear();
 
     Py_Finalize();
@@ -280,14 +285,23 @@
     explicit scoped_interpreter(bool init_signal_handlers = true,
                                 int argc = 0,
                                 const char *const *argv = nullptr,
                                 bool add_program_dir_to_path = true) {
         initialize_interpreter(init_signal_handlers, argc, argv, add_program_dir_to_path);
     }
 
+#if PY_VERSION_HEX >= PYBIND11_PYCONFIG_SUPPORT_PY_VERSION_HEX
+    explicit scoped_interpreter(PyConfig *config,
+                                int argc = 0,
+                                const char *const *argv = nullptr,
+                                bool add_program_dir_to_path = true) {
+        initialize_interpreter(config, argc, argv, add_program_dir_to_path);
+    }
+#endif
+
     scoped_interpreter(const scoped_interpreter &) = delete;
     scoped_interpreter(scoped_interpreter &&other) noexcept { other.is_valid = false; }
     scoped_interpreter &operator=(const scoped_interpreter &) = delete;
     scoped_interpreter &operator=(scoped_interpreter &&) = delete;
 
     ~scoped_interpreter() {
         if (is_valid) {
```

### Comparing `python_prtree-0.6.0/third/pybind11/include/pybind11/eval.h` & `python_prtree-0.6.1/third/pybind11/include/pybind11/eval.h`

 * *Files 19% similar despite different names*

```diff
@@ -16,18 +16,18 @@
 #include <utility>
 
 PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 PYBIND11_NAMESPACE_BEGIN(detail)
 
 inline void ensure_builtins_in_globals(object &global) {
 #if defined(PYPY_VERSION) || PY_VERSION_HEX < 0x03080000
-    // Running exec and eval on Python 2 and 3 adds `builtins` module under
-    // `__builtins__` key to globals if not yet present.
-    // Python 3.8 made PyRun_String behave similarly. Let's also do that for
-    // older versions, for consistency. This was missing from PyPy3.8 7.3.7.
+    // Running exec and eval adds `builtins` module under `__builtins__` key to
+    // globals if not yet present.  Python 3.8 made PyRun_String behave
+    // similarly. Let's also do that for older versions, for consistency. This
+    // was missing from PyPy3.8 7.3.7.
     if (!global.contains("__builtins__"))
         global["__builtins__"] = module_::import(PYBIND11_BUILTINS_MODULE);
 #else
     (void) global;
 #endif
 }
 
@@ -90,15 +90,15 @@
 }
 
 template <size_t N>
 void exec(const char (&s)[N], object global = globals(), object local = object()) {
     eval<eval_statements>(s, std::move(global), std::move(local));
 }
 
-#if defined(PYPY_VERSION) && PY_VERSION_HEX >= 0x03000000
+#if defined(PYPY_VERSION)
 template <eval_mode mode = eval_statements>
 object eval_file(str, object, object) {
     pybind11_fail("eval_file not supported in PyPy3. Use eval");
 }
 template <eval_mode mode = eval_statements>
 object eval_file(str, object) {
     pybind11_fail("eval_file not supported in PyPy3. Use eval");
@@ -129,48 +129,26 @@
             break;
         default:
             pybind11_fail("invalid evaluation mode");
     }
 
     int closeFile = 1;
     std::string fname_str = (std::string) fname;
-#    if PY_VERSION_HEX >= 0x03040000
     FILE *f = _Py_fopen_obj(fname.ptr(), "r");
-#    elif PY_VERSION_HEX >= 0x03000000
-    FILE *f = _Py_fopen(fname.ptr(), "r");
-#    else
-    /* No unicode support in open() :( */
-    auto fobj = reinterpret_steal<object>(
-        PyFile_FromString(const_cast<char *>(fname_str.c_str()), const_cast<char *>("r")));
-    FILE *f = nullptr;
-    if (fobj)
-        f = PyFile_AsFile(fobj.ptr());
-    closeFile = 0;
-#    endif
     if (!f) {
         PyErr_Clear();
         pybind11_fail("File \"" + fname_str + "\" could not be opened!");
     }
 
-    // In Python2, this should be encoded by getfilesystemencoding.
-    // We don't boher setting it since Python2 is past EOL anyway.
-    // See PR#3233
-#    if PY_VERSION_HEX >= 0x03000000
     if (!global.contains("__file__")) {
         global["__file__"] = std::move(fname);
     }
-#    endif
 
-#    if PY_VERSION_HEX < 0x03000000 && defined(PYPY_VERSION)
-    PyObject *result = PyRun_File(f, fname_str.c_str(), start, global.ptr(), local.ptr());
-    (void) closeFile;
-#    else
     PyObject *result
         = PyRun_FileEx(f, fname_str.c_str(), start, global.ptr(), local.ptr(), closeFile);
-#    endif
 
     if (!result) {
         throw error_already_set();
     }
     return reinterpret_steal<object>(result);
 }
 #endif
```

### Comparing `python_prtree-0.6.0/third/pybind11/include/pybind11/functional.h` & `python_prtree-0.6.1/third/pybind11/include/pybind11/functional.h`

 * *Files 9% similar despite different names*

```diff
@@ -44,17 +44,24 @@
            a full C++ -> Python -> C++ roundtrip, which can be prohibitive.
            Here, we try to at least detect the case where the function is
            stateless (i.e. function pointer or lambda function without
            captured variables), in which case the roundtrip can be avoided.
          */
         if (auto cfunc = func.cpp_function()) {
             auto *cfunc_self = PyCFunction_GET_SELF(cfunc.ptr());
-            if (isinstance<capsule>(cfunc_self)) {
+            if (cfunc_self == nullptr) {
+                PyErr_Clear();
+            } else if (isinstance<capsule>(cfunc_self)) {
                 auto c = reinterpret_borrow<capsule>(cfunc_self);
-                auto *rec = (function_record *) c;
+
+                function_record *rec = nullptr;
+                // Check that we can safely reinterpret the capsule into a function_record
+                if (detail::is_function_record_capsule(c)) {
+                    rec = c.get_pointer<function_record>();
+                }
 
                 while (rec != nullptr) {
                     if (rec->is_stateless
                         && same_type(typeid(function_type),
                                      *reinterpret_cast<const std::type_info *>(rec->data[1]))) {
                         struct capture {
                             function_type f;
@@ -94,38 +101,38 @@
 
         // to emulate 'move initialization capture' in C++11
         struct func_wrapper {
             func_handle hfunc;
             explicit func_wrapper(func_handle &&hf) noexcept : hfunc(std::move(hf)) {}
             Return operator()(Args... args) const {
                 gil_scoped_acquire acq;
-                object retval(hfunc.f(std::forward<Args>(args)...));
-                /* Visual studio 2015 parser issue: need parentheses around this expression */
-                return (retval.template cast<Return>());
+                // casts the returned object as a rvalue to the return type
+                return hfunc.f(std::forward<Args>(args)...).template cast<Return>();
             }
         };
 
         value = func_wrapper(func_handle(std::move(func)));
         return true;
     }
 
     template <typename Func>
     static handle cast(Func &&f_, return_value_policy policy, handle /* parent */) {
         if (!f_) {
-            return none().inc_ref();
+            return none().release();
         }
 
         auto result = f_.template target<function_type>();
         if (result) {
             return cpp_function(*result, policy).release();
         }
         return cpp_function(std::forward<Func>(f_), policy).release();
     }
 
     PYBIND11_TYPE_CASTER(type,
-                         const_name("Callable[[") + concat(make_caster<Args>::name...)
+                         const_name("Callable[[")
+                             + ::pybind11::detail::concat(make_caster<Args>::name...)
                              + const_name("], ") + make_caster<retval_type>::name
                              + const_name("]"));
 };
 
 PYBIND11_NAMESPACE_END(detail)
 PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
```

### Comparing `python_prtree-0.6.0/third/pybind11/include/pybind11/gil.h` & `python_prtree-0.6.1/third/pybind11/include/pybind11/gil.h`

 * *Files 20% similar despite different names*

```diff
@@ -6,26 +6,33 @@
     All rights reserved. Use of this source code is governed by a
     BSD-style license that can be found in the LICENSE file.
 */
 
 #pragma once
 
 #include "detail/common.h"
-#include "detail/internals.h"
+
+#include <cassert>
+
+#if defined(WITH_THREAD) && !defined(PYBIND11_SIMPLE_GIL_MANAGEMENT)
+#    include "detail/internals.h"
+#endif
 
 PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 
 PYBIND11_NAMESPACE_BEGIN(detail)
 
 // forward declarations
 PyThreadState *get_thread_state_unchecked();
 
 PYBIND11_NAMESPACE_END(detail)
 
-#if defined(WITH_THREAD) && !defined(PYPY_VERSION)
+#if defined(WITH_THREAD)
+
+#    if !defined(PYBIND11_SIMPLE_GIL_MANAGEMENT)
 
 /* The functions below essentially reproduce the PyGILState_* API using a RAII
  * pattern, but there are a few important differences:
  *
  * 1. When acquiring the GIL from an non-main thread during the finalization
  *    phase, the GILState API blindly terminates the calling thread, which
  *    is often not what is wanted. This API does not do this.
@@ -58,50 +65,53 @@
                below. Note we don't save this state with internals.tstate, since we don't
                create it we would fail to clear it (its reference count should be > 0). */
             tstate = PyGILState_GetThisThreadState();
         }
 
         if (!tstate) {
             tstate = PyThreadState_New(internals.istate);
-#    if !defined(NDEBUG)
+#        if defined(PYBIND11_DETAILED_ERROR_MESSAGES)
             if (!tstate) {
                 pybind11_fail("scoped_acquire: could not create thread state!");
             }
-#    endif
+#        endif
             tstate->gilstate_counter = 0;
             PYBIND11_TLS_REPLACE_VALUE(internals.tstate, tstate);
         } else {
             release = detail::get_thread_state_unchecked() != tstate;
         }
 
         if (release) {
             PyEval_AcquireThread(tstate);
         }
 
         inc_ref();
     }
 
+    gil_scoped_acquire(const gil_scoped_acquire &) = delete;
+    gil_scoped_acquire &operator=(const gil_scoped_acquire &) = delete;
+
     void inc_ref() { ++tstate->gilstate_counter; }
 
     PYBIND11_NOINLINE void dec_ref() {
         --tstate->gilstate_counter;
-#    if !defined(NDEBUG)
+#        if defined(PYBIND11_DETAILED_ERROR_MESSAGES)
         if (detail::get_thread_state_unchecked() != tstate) {
             pybind11_fail("scoped_acquire::dec_ref(): thread state must be current!");
         }
         if (tstate->gilstate_counter < 0) {
             pybind11_fail("scoped_acquire::dec_ref(): reference count underflow!");
         }
-#    endif
+#        endif
         if (tstate->gilstate_counter == 0) {
-#    if !defined(NDEBUG)
+#        if defined(PYBIND11_DETAILED_ERROR_MESSAGES)
             if (!release) {
                 pybind11_fail("scoped_acquire::dec_ref(): internal error!");
             }
-#    endif
+#        endif
             PyThreadState_Clear(tstate);
             if (active) {
                 PyThreadState_DeleteCurrent();
             }
             PYBIND11_TLS_DELETE_VALUE(detail::get_internals().tstate);
             release = false;
         }
@@ -125,29 +135,34 @@
     PyThreadState *tstate = nullptr;
     bool release = true;
     bool active = true;
 };
 
 class gil_scoped_release {
 public:
+    // PRECONDITION: The GIL must be held when this constructor is called.
     explicit gil_scoped_release(bool disassoc = false) : disassoc(disassoc) {
+        assert(PyGILState_Check());
         // `get_internals()` must be called here unconditionally in order to initialize
         // `internals.tstate` for subsequent `gil_scoped_acquire` calls. Otherwise, an
         // initialization race could occur as multiple threads try `gil_scoped_acquire`.
         auto &internals = detail::get_internals();
         // NOLINTNEXTLINE(cppcoreguidelines-prefer-member-initializer)
         tstate = PyEval_SaveThread();
         if (disassoc) {
             // Python >= 3.7 can remove this, it's an int before 3.7
             // NOLINTNEXTLINE(readability-qualified-auto)
             auto key = internals.tstate;
             PYBIND11_TLS_DELETE_VALUE(key);
         }
     }
 
+    gil_scoped_release(const gil_scoped_release &) = delete;
+    gil_scoped_release &operator=(const gil_scoped_release &) = delete;
+
     /// This method will disable the PyThreadState_DeleteCurrent call and the
     /// GIL won't be acquired. This method should be used if the interpreter
     /// could be shutting down when this is called, as thread deletion is not
     /// allowed during shutdown. Check _Py_IsFinalizing() on Python 3.7+, and
     /// protect subsequent code.
     PYBIND11_NOINLINE void disarm() { active = false; }
 
@@ -168,35 +183,65 @@
     }
 
 private:
     PyThreadState *tstate;
     bool disassoc;
     bool active = true;
 };
-#elif defined(PYPY_VERSION)
+
+#    else // PYBIND11_SIMPLE_GIL_MANAGEMENT
+
 class gil_scoped_acquire {
     PyGILState_STATE state;
 
 public:
-    gil_scoped_acquire() { state = PyGILState_Ensure(); }
+    gil_scoped_acquire() : state{PyGILState_Ensure()} {}
+    gil_scoped_acquire(const gil_scoped_acquire &) = delete;
+    gil_scoped_acquire &operator=(const gil_scoped_acquire &) = delete;
     ~gil_scoped_acquire() { PyGILState_Release(state); }
     void disarm() {}
 };
 
 class gil_scoped_release {
     PyThreadState *state;
 
 public:
-    gil_scoped_release() { state = PyEval_SaveThread(); }
+    // PRECONDITION: The GIL must be held when this constructor is called.
+    gil_scoped_release() {
+        assert(PyGILState_Check());
+        state = PyEval_SaveThread();
+    }
+    gil_scoped_release(const gil_scoped_release &) = delete;
+    gil_scoped_release &operator=(const gil_scoped_release &) = delete;
     ~gil_scoped_release() { PyEval_RestoreThread(state); }
     void disarm() {}
 };
-#else
+
+#    endif // PYBIND11_SIMPLE_GIL_MANAGEMENT
+
+#else // WITH_THREAD
+
 class gil_scoped_acquire {
+public:
+    gil_scoped_acquire() {
+        // Trick to suppress `unused variable` error messages (at call sites).
+        (void) (this != (this + 1));
+    }
+    gil_scoped_acquire(const gil_scoped_acquire &) = delete;
+    gil_scoped_acquire &operator=(const gil_scoped_acquire &) = delete;
     void disarm() {}
 };
+
 class gil_scoped_release {
+public:
+    gil_scoped_release() {
+        // Trick to suppress `unused variable` error messages (at call sites).
+        (void) (this != (this + 1));
+    }
+    gil_scoped_release(const gil_scoped_release &) = delete;
+    gil_scoped_release &operator=(const gil_scoped_release &) = delete;
     void disarm() {}
 };
-#endif
+
+#endif // WITH_THREAD
 
 PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
```

### Comparing `python_prtree-0.6.0/third/pybind11/include/pybind11/iostream.h` & `python_prtree-0.6.1/third/pybind11/include/pybind11/iostream.h`

 * *Files 1% similar despite different names*

```diff
@@ -96,15 +96,15 @@
             gil_scoped_acquire tmp;
             // This subtraction cannot be negative, so dropping the sign.
             auto size = static_cast<size_t>(pptr() - pbase());
             size_t remainder = utf8_remainder();
 
             if (size > remainder) {
                 str line(pbase(), size - remainder);
-                pywrite(line);
+                pywrite(std::move(line));
                 pyflush();
             }
 
             // Copy the remainder at the end of the buffer to the beginning:
             if (remainder > 0) {
                 std::memmove(pbase(), pptr() - remainder, remainder);
             }
```

### Comparing `python_prtree-0.6.0/third/pybind11/include/pybind11/numpy.h` & `python_prtree-0.6.1/third/pybind11/include/pybind11/numpy.h`

 * *Files 3% similar despite different names*

```diff
@@ -6,15 +6,18 @@
     All rights reserved. Use of this source code is governed by a
     BSD-style license that can be found in the LICENSE file.
 */
 
 #pragma once
 
 #include "pybind11.h"
+#include "detail/common.h"
 #include "complex.h"
+#include "gil_safe_call_once.h"
+#include "pytypes.h"
 
 #include <algorithm>
 #include <array>
 #include <cstdint>
 #include <cstdlib>
 #include <cstring>
 #include <functional>
@@ -22,51 +25,102 @@
 #include <sstream>
 #include <string>
 #include <type_traits>
 #include <typeindex>
 #include <utility>
 #include <vector>
 
+#if defined(PYBIND11_NUMPY_1_ONLY) && !defined(PYBIND11_INTERNAL_NUMPY_1_ONLY_DETECTED)
+#    error PYBIND11_NUMPY_1_ONLY must be defined before any pybind11 header is included.
+#endif
+
 /* This will be true on all flat address space platforms and allows us to reduce the
    whole npy_intp / ssize_t / Py_intptr_t business down to just ssize_t for all size
    and dimension types (e.g. shape, strides, indexing), instead of inflicting this
-   upon the library user. */
+   upon the library user.
+   Note that NumPy 2 now uses ssize_t for `npy_intp` to simplify this. */
 static_assert(sizeof(::pybind11::ssize_t) == sizeof(Py_intptr_t), "ssize_t != Py_intptr_t");
 static_assert(std::is_signed<Py_intptr_t>::value, "Py_intptr_t must be signed");
 // We now can reinterpret_cast between py::ssize_t and Py_intptr_t (MSVC + PyPy cares)
 
 PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 
+PYBIND11_WARNING_DISABLE_MSVC(4127)
+
+class dtype; // Forward declaration
 class array; // Forward declaration
 
 PYBIND11_NAMESPACE_BEGIN(detail)
 
 template <>
+struct handle_type_name<dtype> {
+    static constexpr auto name = const_name("numpy.dtype");
+};
+
+template <>
 struct handle_type_name<array> {
     static constexpr auto name = const_name("numpy.ndarray");
 };
 
 template <typename type, typename SFINAE = void>
 struct npy_format_descriptor;
 
-struct PyArrayDescr_Proxy {
+/* NumPy 1 proxy (always includes legacy fields) */
+struct PyArrayDescr1_Proxy {
     PyObject_HEAD
     PyObject *typeobj;
     char kind;
     char type;
     char byteorder;
     char flags;
     int type_num;
     int elsize;
     int alignment;
     char *subarray;
     PyObject *fields;
     PyObject *names;
 };
 
+#ifndef PYBIND11_NUMPY_1_ONLY
+struct PyArrayDescr_Proxy {
+    PyObject_HEAD
+    PyObject *typeobj;
+    char kind;
+    char type;
+    char byteorder;
+    char _former_flags;
+    int type_num;
+    /* Additional fields are NumPy version specific. */
+};
+#else
+/* NumPy 1.x only, we can expose all fields */
+using PyArrayDescr_Proxy = PyArrayDescr1_Proxy;
+#endif
+
+/* NumPy 2 proxy, including legacy fields */
+struct PyArrayDescr2_Proxy {
+    PyObject_HEAD
+    PyObject *typeobj;
+    char kind;
+    char type;
+    char byteorder;
+    char _former_flags;
+    int type_num;
+    std::uint64_t flags;
+    ssize_t elsize;
+    ssize_t alignment;
+    PyObject *metadata;
+    Py_hash_t hash;
+    void *reserved_null[2];
+    /* The following fields only exist if 0 <= type_num < 2056 */
+    char *subarray;
+    PyObject *fields;
+    PyObject *names;
+};
+
 struct PyArray_Proxy {
     PyObject_HEAD
     char *data;
     int nd;
     ssize_t *dimensions;
     ssize_t *strides;
     PyObject *base;
@@ -114,14 +168,36 @@
     static numpy_internals *ptr = nullptr;
     if (!ptr) {
         load_numpy_internals(ptr);
     }
     return *ptr;
 }
 
+PYBIND11_NOINLINE module_ import_numpy_core_submodule(const char *submodule_name) {
+    module_ numpy = module_::import("numpy");
+    str version_string = numpy.attr("__version__");
+
+    module_ numpy_lib = module_::import("numpy.lib");
+    object numpy_version = numpy_lib.attr("NumpyVersion")(version_string);
+    int major_version = numpy_version.attr("major").cast<int>();
+
+#ifdef PYBIND11_NUMPY_1_ONLY
+    if (major_version >= 2) {
+        throw std::runtime_error(
+            "This extension was built with PYBIND11_NUMPY_1_ONLY defined, "
+            "but NumPy 2 is used in this process. For NumPy2 compatibility, "
+            "this extension needs to be rebuilt without the PYBIND11_NUMPY_1_ONLY define.");
+    }
+#endif
+    /* `numpy.core` was renamed to `numpy._core` in NumPy 2.0 as it officially
+        became a private module. */
+    std::string numpy_core_path = major_version >= 2 ? "numpy._core" : "numpy.core";
+    return module_::import((numpy_core_path + "." + submodule_name).c_str());
+}
+
 template <typename T>
 struct same_size {
     template <typename U>
     using as = bool_constant<sizeof(T) == sizeof(U)>;
 };
 
 template <typename Concrete>
@@ -180,22 +256,24 @@
         NPY_INT64_
         = platform_lookup<std::int64_t, long, long long, int>(NPY_LONG_, NPY_LONGLONG_, NPY_INT_),
         NPY_UINT64_
         = platform_lookup<std::uint64_t, unsigned long, unsigned long long, unsigned int>(
             NPY_ULONG_, NPY_ULONGLONG_, NPY_UINT_),
     };
 
+    unsigned int PyArray_RUNTIME_VERSION_;
+
     struct PyArray_Dims {
         Py_intptr_t *ptr;
         int len;
     };
 
     static npy_api &get() {
-        static npy_api api = lookup();
-        return api;
+        PYBIND11_CONSTINIT static gil_safe_call_once_and_store<npy_api> storage;
+        return storage.call_once_and_store_result(lookup).get_stored();
     }
 
     bool PyArray_Check_(PyObject *obj) const {
         return PyObject_TypeCheck(obj, PyArray_Type_) != 0;
     }
     bool PyArrayDescr_Check_(PyObject *obj) const {
         return PyObject_TypeCheck(obj, PyArrayDescr_Type_) != 0;
@@ -218,22 +296,24 @@
     PyTypeObject *PyArray_Type_;
     PyTypeObject *PyVoidArrType_Type_;
     PyTypeObject *PyArrayDescr_Type_;
     PyObject *(*PyArray_DescrFromScalar_)(PyObject *);
     PyObject *(*PyArray_FromAny_)(PyObject *, PyObject *, int, int, int, PyObject *);
     int (*PyArray_DescrConverter_)(PyObject *, PyObject **);
     bool (*PyArray_EquivTypes_)(PyObject *, PyObject *);
+#ifdef PYBIND11_NUMPY_1_ONLY
     int (*PyArray_GetArrayParamsFromObject_)(PyObject *,
                                              PyObject *,
                                              unsigned char,
                                              PyObject **,
                                              int *,
                                              Py_intptr_t *,
                                              PyObject **,
                                              PyObject *);
+#endif
     PyObject *(*PyArray_Squeeze_)(PyObject *);
     // Unused. Not removed because that affects ABI of the class.
     int (*PyArray_SetBaseObject_)(PyObject *, PyObject *);
     PyObject *(*PyArray_Resize_)(PyObject *, PyArray_Dims *, int, int);
     PyObject *(*PyArray_Newshape_)(PyObject *, PyArray_Dims *, int);
     PyObject *(*PyArray_View_)(PyObject *, PyObject *, PyObject *);
 
@@ -243,39 +323,43 @@
         API_PyArray_Type = 2,
         API_PyArrayDescr_Type = 3,
         API_PyVoidArrType_Type = 39,
         API_PyArray_DescrFromType = 45,
         API_PyArray_DescrFromScalar = 57,
         API_PyArray_FromAny = 69,
         API_PyArray_Resize = 80,
-        API_PyArray_CopyInto = 82,
+        // CopyInto was slot 82 and 50 was effectively an alias. NumPy 2 removed 82.
+        API_PyArray_CopyInto = 50,
         API_PyArray_NewCopy = 85,
         API_PyArray_NewFromDescr = 94,
         API_PyArray_DescrNewFromType = 96,
         API_PyArray_Newshape = 135,
         API_PyArray_Squeeze = 136,
         API_PyArray_View = 137,
         API_PyArray_DescrConverter = 174,
         API_PyArray_EquivTypes = 182,
+#ifdef PYBIND11_NUMPY_1_ONLY
         API_PyArray_GetArrayParamsFromObject = 278,
+#endif
         API_PyArray_SetBaseObject = 282
     };
 
     static npy_api lookup() {
-        module_ m = module_::import("numpy.core.multiarray");
+        module_ m = detail::import_numpy_core_submodule("multiarray");
         auto c = m.attr("_ARRAY_API");
-#if PY_MAJOR_VERSION >= 3
-        void **api_ptr = (void **) PyCapsule_GetPointer(c.ptr(), NULL);
-#else
-        void **api_ptr = (void **) PyCObject_AsVoidPtr(c.ptr());
-#endif
+        void **api_ptr = (void **) PyCapsule_GetPointer(c.ptr(), nullptr);
+        if (api_ptr == nullptr) {
+            raise_from(PyExc_SystemError, "FAILURE obtaining numpy _ARRAY_API pointer.");
+            throw error_already_set();
+        }
         npy_api api;
 #define DECL_NPY_API(Func) api.Func##_ = (decltype(api.Func##_)) api_ptr[API_##Func];
         DECL_NPY_API(PyArray_GetNDArrayCFeatureVersion);
-        if (api.PyArray_GetNDArrayCFeatureVersion_() < 0x7) {
+        api.PyArray_RUNTIME_VERSION_ = api.PyArray_GetNDArrayCFeatureVersion_();
+        if (api.PyArray_RUNTIME_VERSION_ < 0x7) {
             pybind11_fail("pybind11 numpy support requires numpy >= 1.7.0");
         }
         DECL_NPY_API(PyArray_Type);
         DECL_NPY_API(PyVoidArrType_Type);
         DECL_NPY_API(PyArrayDescr_Type);
         DECL_NPY_API(PyArray_DescrFromType);
         DECL_NPY_API(PyArray_DescrFromScalar);
@@ -286,15 +370,17 @@
         DECL_NPY_API(PyArray_NewFromDescr);
         DECL_NPY_API(PyArray_DescrNewFromType);
         DECL_NPY_API(PyArray_Newshape);
         DECL_NPY_API(PyArray_Squeeze);
         DECL_NPY_API(PyArray_View);
         DECL_NPY_API(PyArray_DescrConverter);
         DECL_NPY_API(PyArray_EquivTypes);
+#ifdef PYBIND11_NUMPY_1_ONLY
         DECL_NPY_API(PyArray_GetArrayParamsFromObject);
+#endif
         DECL_NPY_API(PyArray_SetBaseObject);
 
 #undef DECL_NPY_API
         return api;
     }
 };
 
@@ -308,14 +394,22 @@
     return reinterpret_cast<PyArrayDescr_Proxy *>(ptr);
 }
 
 inline const PyArrayDescr_Proxy *array_descriptor_proxy(const PyObject *ptr) {
     return reinterpret_cast<const PyArrayDescr_Proxy *>(ptr);
 }
 
+inline const PyArrayDescr1_Proxy *array_descriptor1_proxy(const PyObject *ptr) {
+    return reinterpret_cast<const PyArrayDescr1_Proxy *>(ptr);
+}
+
+inline const PyArrayDescr2_Proxy *array_descriptor2_proxy(const PyObject *ptr) {
+    return reinterpret_cast<const PyArrayDescr2_Proxy *>(ptr);
+}
+
 inline bool check_flags(const void *ptr, int flag) {
     return (flag == (array_proxy(ptr)->flags & flag));
 }
 
 template <typename T>
 struct is_std_array : std::false_type {};
 template <typename T, size_t N>
@@ -348,15 +442,15 @@
     // appends the extents to shape
     static void append_extents(list &shape) {
         shape.append(N);
         array_info<T>::append_extents(shape);
     }
 
     static constexpr auto extents = const_name<array_info<T>::is_array>(
-        concat(const_name<N>(), array_info<T>::extents), const_name<N>());
+        ::pybind11::detail::concat(const_name<N>(), array_info<T>::extents), const_name<N>());
 };
 // For numpy we have special handling for arrays of characters, so we don't include
 // the size in the array extents.
 template <size_t N>
 struct array_info<char[N]> : array_info_scalar<char[N]> {};
 template <size_t N>
 struct array_info<std::array<char, N>> : array_info_scalar<std::array<char, N>> {};
@@ -537,120 +631,192 @@
 struct type_caster<unchecked_mutable_reference<T, Dim>>
     : type_caster<unchecked_reference<T, Dim>> {};
 
 PYBIND11_NAMESPACE_END(detail)
 
 class dtype : public object {
 public:
-    PYBIND11_OBJECT_DEFAULT(dtype, object, detail::npy_api::get().PyArrayDescr_Check_);
+    PYBIND11_OBJECT_DEFAULT(dtype, object, detail::npy_api::get().PyArrayDescr_Check_)
 
     explicit dtype(const buffer_info &info) {
-        dtype descr(_dtype_from_pep3118()(PYBIND11_STR_TYPE(info.format)));
+        dtype descr(_dtype_from_pep3118()(pybind11::str(info.format)));
         // If info.itemsize == 0, use the value calculated from the format string
         m_ptr = descr.strip_padding(info.itemsize != 0 ? info.itemsize : descr.itemsize())
                     .release()
                     .ptr();
     }
 
-    explicit dtype(const std::string &format) {
-        m_ptr = from_args(pybind11::str(format)).release().ptr();
-    }
+    explicit dtype(const pybind11::str &format) : dtype(from_args(format)) {}
+
+    explicit dtype(const std::string &format) : dtype(pybind11::str(format)) {}
 
-    explicit dtype(const char *format) : dtype(std::string(format)) {}
+    explicit dtype(const char *format) : dtype(pybind11::str(format)) {}
 
     dtype(list names, list formats, list offsets, ssize_t itemsize) {
         dict args;
         args["names"] = std::move(names);
         args["formats"] = std::move(formats);
         args["offsets"] = std::move(offsets);
         args["itemsize"] = pybind11::int_(itemsize);
-        m_ptr = from_args(std::move(args)).release().ptr();
+        m_ptr = from_args(args).release().ptr();
+    }
+
+    /// Return dtype for the given typenum (one of the NPY_TYPES).
+    /// https://numpy.org/devdocs/reference/c-api/array.html#c.PyArray_DescrFromType
+    explicit dtype(int typenum)
+        : object(detail::npy_api::get().PyArray_DescrFromType_(typenum), stolen_t{}) {
+        if (m_ptr == nullptr) {
+            throw error_already_set();
+        }
     }
 
     /// This is essentially the same as calling numpy.dtype(args) in Python.
-    static dtype from_args(object args) {
+    static dtype from_args(const object &args) {
         PyObject *ptr = nullptr;
         if ((detail::npy_api::get().PyArray_DescrConverter_(args.ptr(), &ptr) == 0) || !ptr) {
             throw error_already_set();
         }
         return reinterpret_steal<dtype>(ptr);
     }
 
     /// Return dtype associated with a C++ type.
     template <typename T>
     static dtype of() {
         return detail::npy_format_descriptor<typename std::remove_cv<T>::type>::dtype();
     }
 
     /// Size of the data type in bytes.
+#ifdef PYBIND11_NUMPY_1_ONLY
     ssize_t itemsize() const { return detail::array_descriptor_proxy(m_ptr)->elsize; }
+#else
+    ssize_t itemsize() const {
+        if (detail::npy_api::get().PyArray_RUNTIME_VERSION_ < 0x12) {
+            return detail::array_descriptor1_proxy(m_ptr)->elsize;
+        }
+        return detail::array_descriptor2_proxy(m_ptr)->elsize;
+    }
+#endif
 
     /// Returns true for structured data types.
+#ifdef PYBIND11_NUMPY_1_ONLY
     bool has_fields() const { return detail::array_descriptor_proxy(m_ptr)->names != nullptr; }
+#else
+    bool has_fields() const {
+        if (detail::npy_api::get().PyArray_RUNTIME_VERSION_ < 0x12) {
+            return detail::array_descriptor1_proxy(m_ptr)->names != nullptr;
+        }
+        const auto *proxy = detail::array_descriptor2_proxy(m_ptr);
+        if (proxy->type_num < 0 || proxy->type_num >= 2056) {
+            return false;
+        }
+        return proxy->names != nullptr;
+    }
+#endif
 
     /// Single-character code for dtype's kind.
     /// For example, floating point types are 'f' and integral types are 'i'.
     char kind() const { return detail::array_descriptor_proxy(m_ptr)->kind; }
 
     /// Single-character for dtype's type.
     /// For example, ``float`` is 'f', ``double`` 'd', ``int`` 'i', and ``long`` 'l'.
     char char_() const {
         // Note: The signature, `dtype::char_` follows the naming of NumPy's
         // public Python API (i.e., ``dtype.char``), rather than its internal
         // C API (``PyArray_Descr::type``).
         return detail::array_descriptor_proxy(m_ptr)->type;
     }
 
+    /// type number of dtype.
+    int num() const {
+        // Note: The signature, `dtype::num` follows the naming of NumPy's public
+        // Python API (i.e., ``dtype.num``), rather than its internal
+        // C API (``PyArray_Descr::type_num``).
+        return detail::array_descriptor_proxy(m_ptr)->type_num;
+    }
+
+    /// Single character for byteorder
+    char byteorder() const { return detail::array_descriptor_proxy(m_ptr)->byteorder; }
+
+/// Alignment of the data type
+#ifdef PYBIND11_NUMPY_1_ONLY
+    int alignment() const { return detail::array_descriptor_proxy(m_ptr)->alignment; }
+#else
+    ssize_t alignment() const {
+        if (detail::npy_api::get().PyArray_RUNTIME_VERSION_ < 0x12) {
+            return detail::array_descriptor1_proxy(m_ptr)->alignment;
+        }
+        return detail::array_descriptor2_proxy(m_ptr)->alignment;
+    }
+#endif
+
+/// Flags for the array descriptor
+#ifdef PYBIND11_NUMPY_1_ONLY
+    char flags() const { return detail::array_descriptor_proxy(m_ptr)->flags; }
+#else
+    std::uint64_t flags() const {
+        if (detail::npy_api::get().PyArray_RUNTIME_VERSION_ < 0x12) {
+            return (unsigned char) detail::array_descriptor1_proxy(m_ptr)->flags;
+        }
+        return detail::array_descriptor2_proxy(m_ptr)->flags;
+    }
+#endif
+
 private:
-    static object _dtype_from_pep3118() {
-        static PyObject *obj = module_::import("numpy.core._internal")
-                                   .attr("_dtype_from_pep3118")
-                                   .cast<object>()
-                                   .release()
-                                   .ptr();
-        return reinterpret_borrow<object>(obj);
+    static object &_dtype_from_pep3118() {
+        PYBIND11_CONSTINIT static gil_safe_call_once_and_store<object> storage;
+        return storage
+            .call_once_and_store_result([]() {
+                return detail::import_numpy_core_submodule("_internal")
+                    .attr("_dtype_from_pep3118");
+            })
+            .get_stored();
     }
 
     dtype strip_padding(ssize_t itemsize) {
         // Recursively strip all void fields with empty names that are generated for
         // padding fields (as of NumPy v1.11).
         if (!has_fields()) {
             return *this;
         }
 
         struct field_descr {
-            PYBIND11_STR_TYPE name;
+            pybind11::str name;
             object format;
             pybind11::int_ offset;
+            field_descr(pybind11::str &&name, object &&format, pybind11::int_ &&offset)
+                : name{std::move(name)}, format{std::move(format)}, offset{std::move(offset)} {};
         };
+        auto field_dict = attr("fields").cast<dict>();
         std::vector<field_descr> field_descriptors;
+        field_descriptors.reserve(field_dict.size());
 
-        for (auto field : attr("fields").attr("items")()) {
+        for (auto field : field_dict.attr("items")()) {
             auto spec = field.cast<tuple>();
             auto name = spec[0].cast<pybind11::str>();
-            auto format = spec[1].cast<tuple>()[0].cast<dtype>();
-            auto offset = spec[1].cast<tuple>()[1].cast<pybind11::int_>();
+            auto spec_fo = spec[1].cast<tuple>();
+            auto format = spec_fo[0].cast<dtype>();
+            auto offset = spec_fo[1].cast<pybind11::int_>();
             if ((len(name) == 0u) && format.kind() == 'V') {
                 continue;
             }
-            field_descriptors.push_back(
-                {(PYBIND11_STR_TYPE) name, format.strip_padding(format.itemsize()), offset});
+            field_descriptors.emplace_back(
+                std::move(name), format.strip_padding(format.itemsize()), std::move(offset));
         }
 
         std::sort(field_descriptors.begin(),
                   field_descriptors.end(),
                   [](const field_descr &a, const field_descr &b) {
                       return a.offset.cast<int>() < b.offset.cast<int>();
                   });
 
         list names, formats, offsets;
         for (auto &descr : field_descriptors) {
-            names.append(descr.name);
-            formats.append(descr.format);
-            offsets.append(descr.offset);
+            names.append(std::move(descr.name));
+            formats.append(std::move(descr.format));
+            offsets.append(std::move(descr.offset));
         }
         return dtype(std::move(names), std::move(formats), std::move(offsets), itemsize);
     }
 };
 
 class array : public buffer {
 public:
@@ -755,17 +921,15 @@
 
     /// Total number of elements
     ssize_t size() const {
         return std::accumulate(shape(), shape() + ndim(), (ssize_t) 1, std::multiplies<ssize_t>());
     }
 
     /// Byte size of a single element
-    ssize_t itemsize() const {
-        return detail::array_descriptor_proxy(detail::array_proxy(m_ptr)->descr)->elsize;
-    }
+    ssize_t itemsize() const { return dtype().itemsize(); }
 
     /// Total number of bytes
     ssize_t nbytes() const { return size() * itemsize(); }
 
     /// Number of dimensions
     ssize_t ndim() const { return detail::array_proxy(m_ptr)->nd; }
 
@@ -846,15 +1010,15 @@
      * Returns a proxy object that provides access to the array's data without bounds or
      * dimensionality checking.  Will throw if the array is missing the `writeable` flag.  Use with
      * care: the array must not be destroyed or reshaped for the duration of the returned object,
      * and the caller must take care not to access invalid dimensions or dimension indices.
      */
     template <typename T, ssize_t Dims = -1>
     detail::unchecked_mutable_reference<T, Dims> mutable_unchecked() & {
-        if (PYBIND11_SILENCE_MSVC_C4127(Dims >= 0) && ndim() != Dims) {
+        if (Dims >= 0 && ndim() != Dims) {
             throw std::domain_error("array has incorrect number of dimensions: "
                                     + std::to_string(ndim()) + "; expected "
                                     + std::to_string(Dims));
         }
         return detail::unchecked_mutable_reference<T, Dims>(
             mutable_data(), shape(), strides(), ndim());
     }
@@ -864,15 +1028,15 @@
      * dimensionality checking.  Unlike `mutable_unchecked()`, this does not require that the
      * underlying array have the `writable` flag.  Use with care: the array must not be destroyed
      * or reshaped for the duration of the returned object, and the caller must take care not to
      * access invalid dimensions or dimension indices.
      */
     template <typename T, ssize_t Dims = -1>
     detail::unchecked_reference<T, Dims> unchecked() const & {
-        if (PYBIND11_SILENCE_MSVC_C4127(Dims >= 0) && ndim() != Dims) {
+        if (Dims >= 0 && ndim() != Dims) {
             throw std::domain_error("array has incorrect number of dimensions: "
                                     + std::to_string(ndim()) + "; expected "
                                     + std::to_string(Dims));
         }
         return detail::unchecked_reference<T, Dims>(data(), shape(), strides(), ndim());
     }
 
@@ -940,15 +1104,15 @@
 
 protected:
     template <typename, typename>
     friend struct detail::npy_format_descriptor;
 
     void fail_dim_check(ssize_t dim, const std::string &msg) const {
         throw index_error(msg + ": " + std::to_string(dim) + " (ndim = " + std::to_string(ndim())
-                          + ")");
+                          + ')');
     }
 
     template <typename... Ix>
     ssize_t byte_offset(Ix... index) const {
         check_dimensions(index...);
         return detail::byte_offset_unsafe(strides(), ssize_t(index)...);
     }
@@ -975,15 +1139,15 @@
         }
         check_dimensions_impl(axis + 1, shape + 1, index...);
     }
 
     /// Create array from any object -- always returns a new reference
     static PyObject *raw_array(PyObject *ptr, int ExtraFlags = 0) {
         if (ptr == nullptr) {
-            PyErr_SetString(PyExc_ValueError, "cannot create a pybind11::array from a nullptr");
+            set_error(PyExc_ValueError, "cannot create a pybind11::array from a nullptr");
             return nullptr;
         }
         return detail::npy_api::get().PyArray_FromAny_(
             ptr, nullptr, 0, 0, detail::npy_api::NPY_ARRAY_ENSUREARRAY_ | ExtraFlags, nullptr);
     }
 };
 
@@ -1090,18 +1254,18 @@
     template <ssize_t Dims = -1>
     detail::unchecked_mutable_reference<T, Dims> mutable_unchecked() & {
         return array::mutable_unchecked<T, Dims>();
     }
 
     /**
      * Returns a proxy object that provides const access to the array's data without bounds or
-     * dimensionality checking.  Unlike `unchecked()`, this does not require that the underlying
-     * array have the `writable` flag.  Use with care: the array must not be destroyed or reshaped
-     * for the duration of the returned object, and the caller must take care not to access invalid
-     * dimensions or dimension indices.
+     * dimensionality checking.  Unlike `mutable_unchecked()`, this does not require that the
+     * underlying array have the `writable` flag.  Use with care: the array must not be destroyed
+     * or reshaped for the duration of the returned object, and the caller must take care not to
+     * access invalid dimensions or dimension indices.
      */
     template <ssize_t Dims = -1>
     detail::unchecked_reference<T, Dims> unchecked() const & {
         return array::unchecked<T, Dims>();
     }
 
     /// Ensure that the argument is a NumPy array of the correct dtype (and if not, try to convert
@@ -1122,15 +1286,15 @@
                && detail::check_flags(h.ptr(), ExtraFlags & (array::c_style | array::f_style));
     }
 
 protected:
     /// Create array from any object -- always returns a new reference
     static PyObject *raw_array_t(PyObject *ptr) {
         if (ptr == nullptr) {
-            PyErr_SetString(PyExc_ValueError, "cannot create a pybind11::array_t from a nullptr");
+            set_error(PyExc_ValueError, "cannot create a pybind11::array_t from a nullptr");
             return nullptr;
         }
         return detail::npy_api::get().PyArray_FromAny_(ptr,
                                                        dtype::of<T>().release().ptr(),
                                                        0,
                                                        0,
                                                        detail::npy_api::NPY_ARRAY_ENSUREARRAY_
@@ -1144,19 +1308,19 @@
     static std::string format() {
         return detail::npy_format_descriptor<typename std::remove_cv<T>::type>::format();
     }
 };
 
 template <size_t N>
 struct format_descriptor<char[N]> {
-    static std::string format() { return std::to_string(N) + "s"; }
+    static std::string format() { return std::to_string(N) + 's'; }
 };
 template <size_t N>
 struct format_descriptor<std::array<char, N>> {
-    static std::string format() { return std::to_string(N) + "s"; }
+    static std::string format() { return std::to_string(N) + 's'; }
 };
 
 template <typename T>
 struct format_descriptor<T, detail::enable_if_t<std::is_enum<T>::value>> {
     static std::string format() {
         return format_descriptor<
             typename std::remove_cv<typename std::underlying_type<T>::type>::type>::format();
@@ -1252,20 +1416,24 @@
                                              npy_api::NPY_CFLOAT_,
                                              npy_api::NPY_CDOUBLE_,
                                              npy_api::NPY_CLONGDOUBLE_};
 
 public:
     static constexpr int value = values[detail::is_fmt_numeric<T>::index];
 
-    static pybind11::dtype dtype() {
-        if (auto *ptr = npy_api::get().PyArray_DescrFromType_(value)) {
-            return reinterpret_steal<pybind11::dtype>(ptr);
-        }
-        pybind11_fail("Unsupported buffer format!");
-    }
+    static pybind11::dtype dtype() { return pybind11::dtype(/*typenum*/ value); }
+};
+
+template <typename T>
+struct npy_format_descriptor<T, enable_if_t<is_same_ignoring_cvref<T, PyObject *>::value>> {
+    static constexpr auto name = const_name("object");
+
+    static constexpr int value = npy_api::NPY_OBJECT_;
+
+    static pybind11::dtype dtype() { return pybind11::dtype(/*typenum*/ value); }
 };
 
 #define PYBIND11_DECL_CHAR_FMT                                                                    \
     static constexpr auto name = const_name("S") + const_name<N>();                               \
     static pybind11::dtype dtype() {                                                              \
         return pybind11::dtype(std::string("S") + std::to_string(N));                             \
     }
@@ -1288,15 +1456,16 @@
     static_assert(!array_info<T>::is_empty, "Zero-sized arrays are not supported");
 
     static constexpr auto name
         = const_name("(") + array_info<T>::extents + const_name(")") + base_descr::name;
     static pybind11::dtype dtype() {
         list shape;
         array_info<T>::append_extents(shape);
-        return pybind11::dtype::from_args(pybind11::make_tuple(base_descr::dtype(), shape));
+        return pybind11::dtype::from_args(
+            pybind11::make_tuple(base_descr::dtype(), std::move(shape)));
     }
 };
 
 template <typename T>
 struct npy_format_descriptor<T, enable_if_t<std::is_enum<T>::value>> {
 private:
     using base_descr = npy_format_descriptor<typename std::underlying_type<T>::type>;
@@ -1334,15 +1503,15 @@
 
     list names, formats, offsets;
     for (auto &field : ordered_fields) {
         if (!field.descr) {
             pybind11_fail(std::string("NumPy: unsupported field dtype: `") + field.name + "` @ "
                           + tinfo.name());
         }
-        names.append(PYBIND11_STR_TYPE(field.name));
+        names.append(pybind11::str(field.name));
         formats.append(field.descr);
         offsets.append(pybind11::int_(field.offset));
     }
     auto *dtype_ptr
         = pybind11::dtype(std::move(names), std::move(formats), std::move(offsets), itemsize)
               .release()
               .ptr();
@@ -1371,23 +1540,23 @@
     }
     if (itemsize > offset) {
         oss << (itemsize - offset) << 'x';
     }
     oss << '}';
     auto format_str = oss.str();
 
-    // Sanity check: verify that NumPy properly parses our buffer format string
+    // Smoke test: verify that NumPy properly parses our buffer format string
     auto &api = npy_api::get();
     auto arr = array(buffer_info(nullptr, itemsize, format_str, 1));
     if (!api.PyArray_EquivTypes_(dtype_ptr, arr.dtype().ptr())) {
         pybind11_fail("NumPy: invalid buffer descriptor!");
     }
 
     auto tindex = std::type_index(tinfo);
-    numpy_internals.registered_dtypes[tindex] = {dtype_ptr, format_str};
+    numpy_internals.registered_dtypes[tindex] = {dtype_ptr, std::move(format_str)};
     get_internals().direct_conversions[tindex].push_back(direct_converter);
 }
 
 template <typename T, typename SFINAE>
 struct npy_format_descriptor {
     static_assert(is_pod_struct<T>::value,
                   "Attempt to use a non-POD or unimplemented POD type as a numpy dtype");
@@ -1439,15 +1608,15 @@
             Name, offsetof(T, Field), sizeof(decltype(std::declval<T>().Field)),                  \
                 ::pybind11::format_descriptor<decltype(std::declval<T>().Field)>::format(),       \
                 ::pybind11::detail::npy_format_descriptor<                                        \
                     decltype(std::declval<T>().Field)>::dtype()                                   \
         }
 
 // Extract name, offset and format descriptor for a struct field
-#    define PYBIND11_FIELD_DESCRIPTOR(T, Field) PYBIND11_FIELD_DESCRIPTOR_EX(T, Field, #    Field)
+#    define PYBIND11_FIELD_DESCRIPTOR(T, Field) PYBIND11_FIELD_DESCRIPTOR_EX(T, Field, #Field)
 
 // The main idea of this macro is borrowed from https://github.com/swansontec/map-macro
 // (C) William Swanson, Paul Fultz
 #    define PYBIND11_EVAL0(...) __VA_ARGS__
 #    define PYBIND11_EVAL1(...) PYBIND11_EVAL0(PYBIND11_EVAL0(PYBIND11_EVAL0(__VA_ARGS__)))
 #    define PYBIND11_EVAL2(...) PYBIND11_EVAL1(PYBIND11_EVAL1(PYBIND11_EVAL1(__VA_ARGS__)))
 #    define PYBIND11_EVAL3(...) PYBIND11_EVAL2(PYBIND11_EVAL2(PYBIND11_EVAL2(__VA_ARGS__)))
@@ -1526,15 +1695,15 @@
     }
 
     void increment(size_type dim) { p_ptr += m_strides[dim]; }
 
     void *data() const { return p_ptr; }
 
 private:
-    char *p_ptr{0};
+    char *p_ptr{nullptr};
     container_type m_strides;
 };
 
 template <size_t N>
 class multi_array_iterator {
 public:
     using container_type = std::vector<ssize_t>;
@@ -1836,27 +2005,33 @@
             PYBIND11_EXPAND_SIDE_EFFECTS(params[VIndex] = buffers[BIndex].ptr);
             return cast(
                 returned_array::call(f, *reinterpret_cast<param_n_t<Index> *>(params[Index])...));
         }
 
         auto result = returned_array::create(trivial, shape);
 
+        PYBIND11_WARNING_PUSH
+#ifdef PYBIND11_DETECTED_CLANG_WITH_MISLEADING_CALL_STD_MOVE_EXPLICITLY_WARNING
+        PYBIND11_WARNING_DISABLE_CLANG("-Wreturn-std-move")
+#endif
+
         if (size == 0) {
-            return std::move(result);
+            return result;
         }
 
         /* Call the function */
         auto *mutable_data = returned_array::mutable_data(result);
         if (trivial == broadcast_trivial::non_trivial) {
             apply_broadcast(buffers, params, mutable_data, size, shape, i_seq, vi_seq, bi_seq);
         } else {
             apply_trivial(buffers, params, mutable_data, size, i_seq, vi_seq, bi_seq);
         }
 
-        return std::move(result);
+        return result;
+        PYBIND11_WARNING_POP
     }
 
     template <size_t... Index, size_t... VIndex, size_t... BIndex>
     void apply_trivial(std::array<buffer_info, NVectorized> &buffers,
                        std::array<void *, N> &params,
                        Return *out,
                        size_t size,
```

### Comparing `python_prtree-0.6.0/third/pybind11/include/pybind11/operators.h` & `python_prtree-0.6.1/third/pybind11/include/pybind11/operators.h`

 * *Files 4% similar despite different names*

```diff
@@ -80,48 +80,30 @@
 /// base template of operator implementations
 template <op_id, op_type, typename B, typename L, typename R>
 struct op_impl {};
 
 /// Operator implementation generator
 template <op_id id, op_type ot, typename L, typename R>
 struct op_ {
+    static constexpr bool op_enable_if_hook = true;
     template <typename Class, typename... Extra>
     void execute(Class &cl, const Extra &...extra) const {
         using Base = typename Class::type;
         using L_type = conditional_t<std::is_same<L, self_t>::value, Base, L>;
         using R_type = conditional_t<std::is_same<R, self_t>::value, Base, R>;
         using op = op_impl<id, ot, Base, L_type, R_type>;
         cl.def(op::name(), &op::execute, is_operator(), extra...);
-#if PY_MAJOR_VERSION < 3
-        if (PYBIND11_SILENCE_MSVC_C4127(id == op_truediv)
-            || PYBIND11_SILENCE_MSVC_C4127(id == op_itruediv))
-            cl.def(id == op_itruediv ? "__idiv__"
-                   : ot == op_l      ? "__div__"
-                                     : "__rdiv__",
-                   &op::execute,
-                   is_operator(),
-                   extra...);
-#endif
     }
     template <typename Class, typename... Extra>
     void execute_cast(Class &cl, const Extra &...extra) const {
         using Base = typename Class::type;
         using L_type = conditional_t<std::is_same<L, self_t>::value, Base, L>;
         using R_type = conditional_t<std::is_same<R, self_t>::value, Base, R>;
         using op = op_impl<id, ot, Base, L_type, R_type>;
         cl.def(op::name(), &op::execute_cast, is_operator(), extra...);
-#if PY_MAJOR_VERSION < 3
-        if (id == op_truediv || id == op_itruediv)
-            cl.def(id == op_itruediv ? "__idiv__"
-                   : ot == op_l      ? "__div__"
-                                     : "__rdiv__",
-                   &op::execute,
-                   is_operator(),
-                   extra...);
-#endif
     }
 };
 
 #define PYBIND11_BINARY_OPERATOR(id, rid, op, expr)                                               \
     template <typename B, typename L, typename R>                                                 \
     struct op_impl<op_##id, op_l, B, L, R> {                                                      \
         static char const *name() { return "__" #id "__"; }                                       \
```

### Comparing `python_prtree-0.6.0/third/pybind11/include/pybind11/options.h` & `python_prtree-0.6.1/third/pybind11/include/pybind11/options.h`

 * *Files 25% similar despite different names*

```diff
@@ -43,30 +43,46 @@
     }
 
     options &enable_function_signatures() & {
         global_state().show_function_signatures = true;
         return *this;
     }
 
+    options &disable_enum_members_docstring() & {
+        global_state().show_enum_members_docstring = false;
+        return *this;
+    }
+
+    options &enable_enum_members_docstring() & {
+        global_state().show_enum_members_docstring = true;
+        return *this;
+    }
+
     // Getter methods (return the global state):
 
     static bool show_user_defined_docstrings() {
         return global_state().show_user_defined_docstrings;
     }
 
     static bool show_function_signatures() { return global_state().show_function_signatures; }
 
+    static bool show_enum_members_docstring() {
+        return global_state().show_enum_members_docstring;
+    }
+
     // This type is not meant to be allocated on the heap.
     void *operator new(size_t) = delete;
 
 private:
     struct state {
         bool show_user_defined_docstrings = true; //< Include user-supplied texts in docstrings.
         bool show_function_signatures = true;     //< Include auto-generated function signatures
                                                   //  in docstrings.
+        bool show_enum_members_docstring = true;  //< Include auto-generated member list in enum
+                                                  //  docstrings.
     };
 
     static state &global_state() {
         static state instance;
         return instance;
     }
```

### Comparing `python_prtree-0.6.0/third/pybind11/include/pybind11/pybind11.h` & `python_prtree-0.6.1/third/pybind11/include/pybind11/pybind11.h`

 * *Files 7% similar despite different names*

```diff
@@ -10,15 +10,17 @@
 
 #pragma once
 
 #include "detail/class.h"
 #include "detail/init.h"
 #include "attr.h"
 #include "gil.h"
+#include "gil_safe_call_once.h"
 #include "options.h"
+#include "typing.h"
 
 #include <cstdlib>
 #include <cstring>
 #include <memory>
 #include <new>
 #include <string>
 #include <utility>
@@ -31,30 +33,72 @@
 #    define PYBIND11_STD_LAUNDER
 #    define PYBIND11_HAS_STD_LAUNDER 0
 #endif
 #if defined(__GNUG__) && !defined(__clang__)
 #    include <cxxabi.h>
 #endif
 
+PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
+
 /* https://stackoverflow.com/questions/46798456/handling-gccs-noexcept-type-warning
    This warning is about ABI compatibility, not code health.
    It is only actually needed in a couple places, but apparently GCC 7 "generates this warning if
    and only if the first template instantiation ... involves noexcept" [stackoverflow], therefore
    it could get triggered from seemingly random places, depending on user code.
    No other GCC version generates this warning.
  */
 #if defined(__GNUC__) && __GNUC__ == 7
-#    pragma GCC diagnostic push
-#    pragma GCC diagnostic ignored "-Wnoexcept-type"
+PYBIND11_WARNING_DISABLE_GCC("-Wnoexcept-type")
 #endif
 
-PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
+PYBIND11_WARNING_DISABLE_MSVC(4127)
 
 PYBIND11_NAMESPACE_BEGIN(detail)
 
+inline std::string replace_newlines_and_squash(const char *text) {
+    const char *whitespaces = " \t\n\r\f\v";
+    std::string result(text);
+    bool previous_is_whitespace = false;
+
+    if (result.size() >= 2) {
+        // Do not modify string representations
+        char first_char = result[0];
+        char last_char = result[result.size() - 1];
+        if (first_char == last_char && first_char == '\'') {
+            return result;
+        }
+    }
+    result.clear();
+
+    // Replace characters in whitespaces array with spaces and squash consecutive spaces
+    while (*text != '\0') {
+        if (std::strchr(whitespaces, *text)) {
+            if (!previous_is_whitespace) {
+                result += ' ';
+                previous_is_whitespace = true;
+            }
+        } else {
+            result += *text;
+            previous_is_whitespace = false;
+        }
+        ++text;
+    }
+
+    // Strip leading and trailing whitespaces
+    const size_t str_begin = result.find_first_not_of(whitespaces);
+    if (str_begin == std::string::npos) {
+        return "";
+    }
+
+    const size_t str_end = result.find_last_not_of(whitespaces);
+    const size_t str_range = str_end - str_begin + 1;
+
+    return result.substr(str_begin, str_range);
+}
+
 // Apply all the extensions translators from a list
 // Return true if one of the translators completed without raising an exception
 // itself. Return of false indicates that if there are other translators
 // available, they should be tried.
 inline bool apply_exception_translators(std::forward_list<ExceptionTranslator> &translators) {
     auto last_exception = std::current_exception();
 
@@ -79,14 +123,15 @@
 
 /// Wraps an arbitrary C++ function/method/lambda function/.. into a callable Python object
 class cpp_function : public function {
 public:
     cpp_function() = default;
     // NOLINTNEXTLINE(google-explicit-constructor)
     cpp_function(std::nullptr_t) {}
+    cpp_function(std::nullptr_t, const is_setter &) {}
 
     /// Construct a cpp_function from a vanilla function pointer
     template <typename Return, typename... Args, typename... Extra>
     // NOLINTNEXTLINE(google-explicit-constructor)
     cpp_function(Return (*f)(Args...), const Extra &...extra) {
         initialize(f, f, extra...);
     }
@@ -173,42 +218,40 @@
         /* Store the function including any extra state it might have (e.g. a lambda capture
          * object) */
         // The unique_ptr makes sure nothing is leaked in case of an exception.
         auto unique_rec = make_function_record();
         auto *rec = unique_rec.get();
 
         /* Store the capture object directly in the function record if there is enough space */
-        if (PYBIND11_SILENCE_MSVC_C4127(sizeof(capture) <= sizeof(rec->data))) {
+        if (sizeof(capture) <= sizeof(rec->data)) {
             /* Without these pragmas, GCC warns that there might not be
                enough space to use the placement new operator. However, the
                'if' statement above ensures that this is the case. */
-#if defined(__GNUG__) && __GNUC__ >= 6 && !defined(__clang__) && !defined(__INTEL_COMPILER)
-#    pragma GCC diagnostic push
-#    pragma GCC diagnostic ignored "-Wplacement-new"
+            PYBIND11_WARNING_PUSH
+
+#if defined(__GNUG__) && __GNUC__ >= 6
+            PYBIND11_WARNING_DISABLE_GCC("-Wplacement-new")
 #endif
+
             new ((capture *) &rec->data) capture{std::forward<Func>(f)};
-#if defined(__GNUG__) && __GNUC__ >= 6 && !defined(__clang__) && !defined(__INTEL_COMPILER)
-#    pragma GCC diagnostic pop
-#endif
-#if defined(__GNUG__) && !PYBIND11_HAS_STD_LAUNDER && !defined(__INTEL_COMPILER)
-#    pragma GCC diagnostic push
-#    pragma GCC diagnostic ignored "-Wstrict-aliasing"
+
+#if !PYBIND11_HAS_STD_LAUNDER
+            PYBIND11_WARNING_DISABLE_GCC("-Wstrict-aliasing")
 #endif
+
             // UB without std::launder, but without breaking ABI and/or
             // a significant refactoring it's "impossible" to solve.
             if (!std::is_trivially_destructible<capture>::value) {
                 rec->free_data = [](function_record *r) {
                     auto data = PYBIND11_STD_LAUNDER((capture *) &r->data);
                     (void) data;
                     data->~capture();
                 };
             }
-#if defined(__GNUG__) && !PYBIND11_HAS_STD_LAUNDER && !defined(__INTEL_COMPILER)
-#    pragma GCC diagnostic pop
-#endif
+            PYBIND11_WARNING_POP
         } else {
             rec->data[0] = new capture{std::forward<Func>(f)};
             rec->free_data = [](function_record *r) { delete ((capture *) r->data[0]); };
         }
 
         /* Type casters for the function arguments and return value */
         using cast_in = argument_loader<Args...>;
@@ -241,18 +284,24 @@
             return_value_policy policy
                 = return_value_policy_override<Return>::policy(call.func.policy);
 
             /* Function scope guard -- defaults to the compile-to-nothing `void_type` */
             using Guard = extract_guard_t<Extra...>;
 
             /* Perform the function call */
-            handle result
-                = cast_out::cast(std::move(args_converter).template call<Return, Guard>(cap->f),
-                                 policy,
-                                 call.parent);
+            handle result;
+            if (call.func.is_setter) {
+                (void) std::move(args_converter).template call<Return, Guard>(cap->f);
+                result = none().release();
+            } else {
+                result = cast_out::cast(
+                    std::move(args_converter).template call<Return, Guard>(cap->f),
+                    policy,
+                    call.parent);
+            }
 
             /* Invoke call policy post-call hook */
             process_attributes<Extra...>::postcall(call, result);
 
             return result;
         };
 
@@ -308,14 +357,18 @@
     }
 
     // Utility class that keeps track of all duplicated strings, and cleans them up in its
     // destructor, unless they are released. Basically a RAII-solution to deal with exceptions
     // along the way.
     class strdup_guard {
     public:
+        strdup_guard() = default;
+        strdup_guard(const strdup_guard &) = delete;
+        strdup_guard &operator=(const strdup_guard &) = delete;
+
         ~strdup_guard() {
             for (auto *s : strings) {
                 std::free(s);
             }
         }
         char *operator()(const char *s) {
             auto *t = PYBIND11_COMPAT_STRDUP(s);
@@ -362,15 +415,15 @@
                 a.descr = guarded_strdup(repr(a.value).cast<std::string>().c_str());
             }
         }
 
         rec->is_constructor = (std::strcmp(rec->name, "__init__") == 0)
                               || (std::strcmp(rec->name, "__setstate__") == 0);
 
-#if !defined(NDEBUG) && !defined(PYBIND11_DISABLE_NEW_STYLE_INIT_WARNING)
+#if defined(PYBIND11_DETAILED_ERROR_MESSAGES) && !defined(PYBIND11_DISABLE_NEW_STYLE_INIT_WARNING)
         if (rec->is_constructor && !rec->is_new_style_constructor) {
             const auto class_name
                 = detail::get_fully_qualified_tp_name((PyTypeObject *) rec->scope.ptr());
             const auto func_name = std::string(rec->name);
             PyErr_WarnEx(PyExc_FutureWarning,
                          ("pybind11-bound class '" + class_name
                           + "' is using an old-style "
@@ -410,15 +463,15 @@
                     signature += "arg" + std::to_string(arg_index - (rec->is_method ? 1 : 0));
                 }
                 signature += ": ";
             } else if (c == '}') {
                 // Write default value if available.
                 if (!is_starred && arg_index < rec->args.size() && rec->args[arg_index].descr) {
                     signature += " = ";
-                    signature += rec->args[arg_index].descr;
+                    signature += detail::replace_newlines_and_squash(rec->args[arg_index].descr);
                 }
                 // Separator for positional-only arguments (placed after the
                 // argument, rather than before like *
                 if (rec->nargs_pos_only > 0 && (arg_index + 1) == rec->nargs_pos_only) {
                     signature += ", /";
                 }
                 if (!is_starred) {
@@ -427,64 +480,59 @@
             } else if (c == '%') {
                 const std::type_info *t = types[type_index++];
                 if (!t) {
                     pybind11_fail("Internal error while parsing type signature (1)");
                 }
                 if (auto *tinfo = detail::get_type_info(*t)) {
                     handle th((PyObject *) tinfo->type);
-                    signature += th.attr("__module__").cast<std::string>() + "." +
-                                 // Python 3.3+, but we backport it to earlier versions
-                                 th.attr("__qualname__").cast<std::string>();
+                    signature += th.attr("__module__").cast<std::string>() + "."
+                                 + th.attr("__qualname__").cast<std::string>();
                 } else if (rec->is_new_style_constructor && arg_index == 0) {
                     // A new-style `__init__` takes `self` as `value_and_holder`.
                     // Rewrite it to the proper class type.
                     signature += rec->scope.attr("__module__").cast<std::string>() + "."
                                  + rec->scope.attr("__qualname__").cast<std::string>();
                 } else {
-                    std::string tname(t->name());
-                    detail::clean_type_id(tname);
-                    signature += tname;
+                    signature += detail::quote_cpp_type_name(detail::clean_type_id(t->name()));
                 }
             } else {
                 signature += c;
             }
         }
 
         if (arg_index != args - rec->has_args - rec->has_kwargs || types[type_index] != nullptr) {
             pybind11_fail("Internal error while parsing type signature (2)");
         }
 
-#if PY_MAJOR_VERSION < 3
-        if (std::strcmp(rec->name, "__next__") == 0) {
-            std::free(rec->name);
-            rec->name = guarded_strdup("next");
-        } else if (std::strcmp(rec->name, "__bool__") == 0) {
-            std::free(rec->name);
-            rec->name = guarded_strdup("__nonzero__");
-        }
-#endif
         rec->signature = guarded_strdup(signature.c_str());
         rec->args.shrink_to_fit();
         rec->nargs = (std::uint16_t) args;
 
         if (rec->sibling && PYBIND11_INSTANCE_METHOD_CHECK(rec->sibling.ptr())) {
             rec->sibling = PYBIND11_INSTANCE_METHOD_GET_FUNCTION(rec->sibling.ptr());
         }
 
         detail::function_record *chain = nullptr, *chain_start = rec;
         if (rec->sibling) {
             if (PyCFunction_Check(rec->sibling.ptr())) {
                 auto *self = PyCFunction_GET_SELF(rec->sibling.ptr());
-                capsule rec_capsule = isinstance<capsule>(self) ? reinterpret_borrow<capsule>(self)
-                                                                : capsule(self);
-                chain = (detail::function_record *) rec_capsule;
-                /* Never append a method to an overload chain of a parent class;
-                   instead, hide the parent's overloads in this case */
-                if (!chain->scope.is(rec->scope)) {
+                if (!isinstance<capsule>(self)) {
                     chain = nullptr;
+                } else {
+                    auto rec_capsule = reinterpret_borrow<capsule>(self);
+                    if (detail::is_function_record_capsule(rec_capsule)) {
+                        chain = rec_capsule.get_pointer<detail::function_record>();
+                        /* Never append a method to an overload chain of a parent class;
+                           instead, hide the parent's overloads in this case */
+                        if (!chain->scope.is(rec->scope)) {
+                            chain = nullptr;
+                        }
+                    } else {
+                        chain = nullptr;
+                    }
                 }
             }
             // Don't trigger for things like the default __init__, which are wrapper_descriptors
             // that we are intentionally replacing
             else if (!rec->sibling.is_none() && rec->name[0] != '_') {
                 pybind11_fail("Cannot overload existing non-function object \""
                               + std::string(rec->name) + "\" with a function of the same name");
@@ -497,14 +545,15 @@
             std::memset(rec->def, 0, sizeof(PyMethodDef));
             rec->def->ml_name = rec->name;
             rec->def->ml_meth
                 = reinterpret_cast<PyCFunction>(reinterpret_cast<void (*)()>(dispatcher));
             rec->def->ml_flags = METH_VARARGS | METH_KEYWORDS;
 
             capsule rec_capsule(unique_rec.release(),
+                                detail::get_function_record_capsule_name(),
                                 [](void *ptr) { destruct((detail::function_record *) ptr); });
             guarded_strdup.release();
 
             object scope_module;
             if (rec->scope) {
                 if (hasattr(rec->scope, "__module__")) {
                     scope_module = rec->scope.attr("__module__");
@@ -520,16 +569,17 @@
         } else {
             /* Append at the beginning or end of the overload chain */
             m_ptr = rec->sibling.ptr();
             inc_ref();
             if (chain->is_method != rec->is_method) {
                 pybind11_fail(
                     "overloading a method with both static and instance methods is not supported; "
-#if defined(NDEBUG)
-                    "compile in debug mode for more details"
+#if !defined(PYBIND11_DETAILED_ERROR_MESSAGES)
+                    "#define PYBIND11_DETAILED_ERROR_MESSAGES or compile in debug mode for more "
+                    "details"
 #else
                     "error while attempting to bind "
                     + std::string(rec->is_method ? "instance" : "static") + " method "
                     + std::string(pybind11::str(rec->scope.attr("__name__"))) + "."
                     + std::string(rec->name) + signature
 #endif
                 );
@@ -567,39 +617,39 @@
             signatures += "Overloaded function.\n\n";
         }
         // Then specific overload signatures
         bool first_user_def = true;
         for (auto *it = chain_start; it != nullptr; it = it->next) {
             if (options::show_function_signatures()) {
                 if (index > 0) {
-                    signatures += "\n";
+                    signatures += '\n';
                 }
                 if (chain) {
                     signatures += std::to_string(++index) + ". ";
                 }
                 signatures += rec->name;
                 signatures += it->signature;
-                signatures += "\n";
+                signatures += '\n';
             }
             if (it->doc && it->doc[0] != '\0' && options::show_user_defined_docstrings()) {
                 // If we're appending another docstring, and aren't printing function signatures,
                 // we need to append a newline first:
                 if (!options::show_function_signatures()) {
                     if (first_user_def) {
                         first_user_def = false;
                     } else {
-                        signatures += "\n";
+                        signatures += '\n';
                     }
                 }
                 if (options::show_function_signatures()) {
-                    signatures += "\n";
+                    signatures += '\n';
                 }
                 signatures += it->doc;
                 if (options::show_function_signatures()) {
-                    signatures += "\n";
+                    signatures += '\n';
                 }
             }
         }
 
         /* Install docstring */
         auto *func = (PyCFunctionObject *) m_ptr;
         std::free(const_cast<char *>(func->m_ml->ml_doc));
@@ -662,33 +712,35 @@
             rec = next;
         }
     }
 
     /// Main dispatch logic for calls to functions bound using pybind11
     static PyObject *dispatcher(PyObject *self, PyObject *args_in, PyObject *kwargs_in) {
         using namespace detail;
+        assert(isinstance<capsule>(self));
 
         /* Iterator over the list of potentially admissible overloads */
-        const function_record *overloads = (function_record *) PyCapsule_GetPointer(self, nullptr),
-                              *it = overloads;
+        const function_record *overloads = reinterpret_cast<function_record *>(
+                                  PyCapsule_GetPointer(self, get_function_record_capsule_name())),
+                              *current_overload = overloads;
+        assert(overloads != nullptr);
 
         /* Need to know how many arguments + keyword arguments there are to pick the right
            overload */
         const auto n_args_in = (size_t) PyTuple_GET_SIZE(args_in);
 
         handle parent = n_args_in > 0 ? PyTuple_GET_ITEM(args_in, 0) : nullptr,
                result = PYBIND11_TRY_NEXT_OVERLOAD;
 
         auto self_value_and_holder = value_and_holder();
         if (overloads->is_constructor) {
             if (!parent
                 || !PyObject_TypeCheck(parent.ptr(), (PyTypeObject *) overloads->scope.ptr())) {
-                PyErr_SetString(
-                    PyExc_TypeError,
-                    "__init__(self, ...) called with invalid or missing `self` argument");
+                set_error(PyExc_TypeError,
+                          "__init__(self, ...) called with invalid or missing `self` argument");
                 return nullptr;
             }
 
             auto *const tinfo = get_type_info((PyTypeObject *) overloads->scope.ptr());
             auto *const pi = reinterpret_cast<instance *>(parent.ptr());
             self_value_and_holder = pi->get_value_and_holder(tinfo, true);
 
@@ -703,17 +755,18 @@
             // We do this in two passes: in the first pass, we load arguments with `convert=false`;
             // in the second, we allow conversion (except for arguments with an explicit
             // py::arg().noconvert()).  This lets us prefer calls without conversion, with
             // conversion as a fallback.
             std::vector<function_call> second_pass;
 
             // However, if there are no overloads, we can just skip the no-convert pass entirely
-            const bool overloaded = it != nullptr && it->next != nullptr;
+            const bool overloaded
+                = current_overload != nullptr && current_overload->next != nullptr;
 
-            for (; it != nullptr; it = it->next) {
+            for (; current_overload != nullptr; current_overload = current_overload->next) {
 
                 /* For each overload:
                    1. Copy all positional arguments we were given, also checking to make sure that
                       named positional arguments weren't *also* specified via kwarg.
                    2. If we weren't given enough, try to make up the omitted ones by checking
                       whether they were provided by a kwarg matching the `py::arg("name")` name. If
                       so, use it (and remove it from kwargs); if not, see if the function binding
@@ -726,15 +779,15 @@
                       extra tuple or dict at the end of the positional arguments.
                    6. Call the function call dispatcher (function_record::impl)
 
                    If one of these fail, move on to the next overload and keep trying until we get
                    a result other than PYBIND11_TRY_NEXT_OVERLOAD.
                  */
 
-                const function_record &func = *it;
+                const function_record &func = *current_overload;
                 size_t num_args = func.nargs; // Number of positional arguments that we need
                 if (func.has_args) {
                     --num_args; // (but don't count py::args
                 }
                 if (func.has_kwargs) {
                     --num_args; //  or py::kwargs)
                 }
@@ -908,15 +961,15 @@
                     call.args.push_back(kwargs);
                     call.args_convert.push_back(false);
                     call.kwargs_ref = std::move(kwargs);
                 }
 
 // 5. Put everything in a vector.  Not technically step 5, we've been building it
 // in `call.args` all along.
-#if !defined(NDEBUG)
+#if defined(PYBIND11_DETAILED_ERROR_MESSAGES)
                 if (call.args.size() != func.nargs || call.args_convert.size() != func.nargs) {
                     pybind11_fail("Internal error: function call dispatcher inserted wrong number "
                                   "of arguments!");
                 }
 #endif
 
                 std::vector<bool> second_pass_convert;
@@ -964,18 +1017,18 @@
                         loader_life_support guard{};
                         result = call.func.impl(call);
                     } catch (reference_cast_error &) {
                         result = PYBIND11_TRY_NEXT_OVERLOAD;
                     }
 
                     if (result.ptr() != PYBIND11_TRY_NEXT_OVERLOAD) {
-                        // The error reporting logic below expects 'it' to be valid, as it would be
-                        // if we'd encountered this failure in the first-pass loop.
+                        // The error reporting logic below expects 'current_overload' to be valid,
+                        // as it would be if we'd encountered this failure in the first-pass loop.
                         if (!result) {
-                            it = &call.func;
+                            current_overload = &call.func;
                         }
                         break;
                     }
                 }
             }
         } catch (error_already_set &e) {
             e.restore();
@@ -991,15 +1044,15 @@
                registration. If none of the module-locale translators handle
                the exception (or there are no module-locale translators) then
                the global translators will be tried, also in reverse order of
                registration.
 
                A translator may choose to do one of the following:
 
-                - catch the exception and call PyErr_SetString or PyErr_SetObject
+                - catch the exception and call py::set_error()
                   to set a standard (or custom) Python exception, or
                 - do nothing and let the exception fall through to the next translator, or
                 - delegate translation to the next translator by throwing a new type of exception.
              */
 
             auto &local_exception_translators
                 = get_local_internals().registered_exception_translators;
@@ -1007,16 +1060,15 @@
                 return nullptr;
             }
             auto &exception_translators = get_internals().registered_exception_translators;
             if (detail::apply_exception_translators(exception_translators)) {
                 return nullptr;
             }
 
-            PyErr_SetString(PyExc_SystemError,
-                            "Exception escaped from default exception translator!");
+            set_error(PyExc_SystemError, "Exception escaped from default exception translator!");
             return nullptr;
         }
 
         auto append_note_if_missing_header_is_suspected = [](std::string &msg) {
             if (msg.find("std::") != std::string::npos) {
                 msg += "\n\n"
                        "Did you forget to `#include <pybind11/stl.h>`? Or <pybind11/complex.h>,\n"
@@ -1061,15 +1113,15 @@
                         }
                     }
                 }
                 if (!wrote_sig) {
                     msg += it2->signature;
                 }
 
-                msg += "\n";
+                msg += '\n';
             }
             msg += "\nInvoked with: ";
             auto args_ = reinterpret_borrow<tuple>(args_in);
             bool some_args = false;
             for (size_t ti = overloads->is_constructor ? 1 : 0; ti < args_.size(); ++ti) {
                 if (!some_args) {
                     some_args = true;
@@ -1086,15 +1138,15 @@
                 auto kwargs = reinterpret_borrow<dict>(kwargs_in);
                 if (!kwargs.empty()) {
                     if (some_args) {
                         msg += "; ";
                     }
                     msg += "kwargs: ";
                     bool first = true;
-                    for (auto kwarg : kwargs) {
+                    for (const auto &kwarg : kwargs) {
                         if (first) {
                             first = false;
                         } else {
                             msg += ", ";
                         }
                         msg += pybind11::str("{}=").format(kwarg.first);
                         try {
@@ -1103,61 +1155,63 @@
                             msg += "<repr raised Error>";
                         }
                     }
                 }
             }
 
             append_note_if_missing_header_is_suspected(msg);
-#if PY_VERSION_HEX >= 0x03030000
             // Attach additional error info to the exception if supported
             if (PyErr_Occurred()) {
                 // #HelpAppreciated: unit test coverage for this branch.
                 raise_from(PyExc_TypeError, msg.c_str());
                 return nullptr;
             }
-#endif
-            PyErr_SetString(PyExc_TypeError, msg.c_str());
+            set_error(PyExc_TypeError, msg.c_str());
             return nullptr;
         }
         if (!result) {
             std::string msg = "Unable to convert function return value to a "
                               "Python type! The signature was\n\t";
-            msg += it->signature;
+            assert(current_overload != nullptr);
+            msg += current_overload->signature;
             append_note_if_missing_header_is_suspected(msg);
-#if PY_VERSION_HEX >= 0x03030000
             // Attach additional error info to the exception if supported
             if (PyErr_Occurred()) {
                 raise_from(PyExc_TypeError, msg.c_str());
                 return nullptr;
             }
-#endif
-            PyErr_SetString(PyExc_TypeError, msg.c_str());
+            set_error(PyExc_TypeError, msg.c_str());
             return nullptr;
         }
         if (overloads->is_constructor && !self_value_and_holder.holder_constructed()) {
             auto *pi = reinterpret_cast<instance *>(parent.ptr());
             self_value_and_holder.type->init_instance(pi, nullptr);
         }
         return result.ptr();
     }
 };
 
+PYBIND11_NAMESPACE_BEGIN(detail)
+
+template <>
+struct handle_type_name<cpp_function> {
+    static constexpr auto name = const_name("Callable");
+};
+
+PYBIND11_NAMESPACE_END(detail)
+
 /// Wrapper for Python extension modules
 class module_ : public object {
 public:
     PYBIND11_OBJECT_DEFAULT(module_, object, PyModule_Check)
 
     /// Create a new top-level Python module with the given name and docstring
     PYBIND11_DEPRECATED("Use PYBIND11_MODULE or module_::create_extension_module instead")
     explicit module_(const char *name, const char *doc = nullptr) {
-#if PY_MAJOR_VERSION >= 3
         *this = create_extension_module(name, doc, new PyModuleDef());
-#else
-        *this = create_extension_module(name, doc, nullptr);
-#endif
     }
 
     /** \rst
         Create Python binding for a new function within the module scope. ``Func``
         can be a plain C++ function, a function pointer, or a lambda function. For
         details on the ``Extra&& ... extra`` argument, see section :ref:`extras`.
     \endrst */
@@ -1182,17 +1236,24 @@
         .. code-block:: cpp
 
             py::module_ m("example", "pybind11 example plugin");
             py::module_ m2 = m.def_submodule("sub", "A submodule of 'example'");
             py::module_ m3 = m2.def_submodule("subsub", "A submodule of 'example.sub'");
     \endrst */
     module_ def_submodule(const char *name, const char *doc = nullptr) {
-        std::string full_name
-            = std::string(PyModule_GetName(m_ptr)) + std::string(".") + std::string(name);
-        auto result = reinterpret_borrow<module_>(PyImport_AddModule(full_name.c_str()));
+        const char *this_name = PyModule_GetName(m_ptr);
+        if (this_name == nullptr) {
+            throw error_already_set();
+        }
+        std::string full_name = std::string(this_name) + '.' + name;
+        handle submodule = PyImport_AddModule(full_name.c_str());
+        if (!submodule) {
+            throw error_already_set();
+        }
+        auto result = reinterpret_borrow<module_>(submodule);
         if (doc && options::show_user_defined_docstrings()) {
             result.attr("__doc__") = pybind11::str(doc);
         }
         attr(name) = result;
         return result;
     }
 
@@ -1227,81 +1288,76 @@
                 "Error during initialization: multiple incompatible definitions with name \""
                 + std::string(name) + "\"");
         }
 
         PyModule_AddObject(ptr(), name, obj.inc_ref().ptr() /* steals a reference */);
     }
 
-#if PY_MAJOR_VERSION >= 3
-    using module_def = PyModuleDef;
-#else
-    struct module_def {};
-#endif
+    using module_def = PyModuleDef; // TODO: Can this be removed (it was needed only for Python 2)?
 
     /** \rst
         Create a new top-level module that can be used as the main module of a C extension.
 
-        For Python 3, ``def`` should point to a statically allocated module_def.
-        For Python 2, ``def`` can be a nullptr and is completely ignored.
+        ``def`` should point to a statically allocated module_def.
     \endrst */
     static module_ create_extension_module(const char *name, const char *doc, module_def *def) {
-#if PY_MAJOR_VERSION >= 3
         // module_def is PyModuleDef
         // Placement new (not an allocation).
         def = new (def)
             PyModuleDef{/* m_base */ PyModuleDef_HEAD_INIT,
                         /* m_name */ name,
                         /* m_doc */ options::show_user_defined_docstrings() ? doc : nullptr,
                         /* m_size */ -1,
                         /* m_methods */ nullptr,
                         /* m_slots */ nullptr,
                         /* m_traverse */ nullptr,
                         /* m_clear */ nullptr,
                         /* m_free */ nullptr};
         auto *m = PyModule_Create(def);
-#else
-        // Ignore module_def *def; only necessary for Python 3
-        (void) def;
-        auto m = Py_InitModule3(
-            name, nullptr, options::show_user_defined_docstrings() ? doc : nullptr);
-#endif
         if (m == nullptr) {
             if (PyErr_Occurred()) {
                 throw error_already_set();
             }
             pybind11_fail("Internal error in module_::create_extension_module()");
         }
         // TODO: Should be reinterpret_steal for Python 3, but Python also steals it again when
-        // returned from PyInit_...
-        //       For Python 2, reinterpret_borrow is correct.
+        //       returned from PyInit_...
+        //       For Python 2, reinterpret_borrow was correct.
         return reinterpret_borrow<module_>(m);
     }
 };
 
+PYBIND11_NAMESPACE_BEGIN(detail)
+
+template <>
+struct handle_type_name<module_> {
+    static constexpr auto name = const_name("module");
+};
+
+PYBIND11_NAMESPACE_END(detail)
+
 // When inside a namespace (or anywhere as long as it's not the first item on a line),
 // C++20 allows "module" to be used. This is provided for backward compatibility, and for
 // simplicity, if someone wants to use py::module for example, that is perfectly safe.
 using module = module_;
 
 /// \ingroup python_builtins
 /// Return a dictionary representing the global variables in the current execution frame,
 /// or ``__main__.__dict__`` if there is no frame (usually when the interpreter is embedded).
 inline dict globals() {
     PyObject *p = PyEval_GetGlobals();
     return reinterpret_borrow<dict>(p ? p : module_::import("__main__").attr("__dict__").ptr());
 }
 
-#if PY_VERSION_HEX >= 0x03030000
 template <typename... Args, typename = detail::enable_if_t<args_are_all_keyword_or_ds<Args...>()>>
 PYBIND11_DEPRECATED("make_simple_namespace should be replaced with "
                     "py::module_::import(\"types\").attr(\"SimpleNamespace\") ")
 object make_simple_namespace(Args &&...args_) {
     return module_::import("types").attr("SimpleNamespace")(std::forward<Args>(args_)...);
 }
-#endif
 
 PYBIND11_NAMESPACE_BEGIN(detail)
 /// Generic support for creating new Python heap types
 class generic_type : public object {
 public:
     PYBIND11_OBJECT_DEFAULT(generic_type, object, PyType_Check)
 protected:
@@ -1432,17 +1488,17 @@
     void_t<decltype(static_cast<void (*)(void *, size_t)>(T::operator delete))>> : std::true_type {
 };
 /// Call class-specific delete if it exists or global otherwise. Can also be an overload set.
 template <typename T, enable_if_t<has_operator_delete<T>::value, int> = 0>
 void call_operator_delete(T *p, size_t, size_t) {
     T::operator delete(p);
 }
-template <
-    typename T,
-    enable_if_t<!has_operator_delete<T>::value && has_operator_delete_size<T>::value, int> = 0>
+template <typename T,
+          enable_if_t<!has_operator_delete<T>::value && has_operator_delete_size<T>::value, int>
+          = 0>
 void call_operator_delete(T *p, size_t s, size_t) {
     T::operator delete(p, s);
 }
 
 inline void call_operator_delete(void *p, size_t s, size_t a) {
     (void) s;
     (void) a;
@@ -1589,26 +1645,27 @@
         static_assert(!std::is_member_function_pointer<Func>::value,
                       "def_static(...) called with a non-static member function pointer");
         cpp_function cf(std::forward<Func>(f),
                         name(name_),
                         scope(*this),
                         sibling(getattr(*this, name_, none())),
                         extra...);
-        attr(cf.name()) = staticmethod(cf);
+        auto cf_name = cf.name();
+        attr(std::move(cf_name)) = staticmethod(std::move(cf));
         return *this;
     }
 
-    template <detail::op_id id, detail::op_type ot, typename L, typename R, typename... Extra>
-    class_ &def(const detail::op_<id, ot, L, R> &op, const Extra &...extra) {
+    template <typename T, typename... Extra, detail::enable_if_t<T::op_enable_if_hook, int> = 0>
+    class_ &def(const T &op, const Extra &...extra) {
         op.execute(*this, extra...);
         return *this;
     }
 
-    template <detail::op_id id, detail::op_type ot, typename L, typename R, typename... Extra>
-    class_ &def_cast(const detail::op_<id, ot, L, R> &op, const Extra &...extra) {
+    template <typename T, typename... Extra, detail::enable_if_t<T::op_enable_if_hook, int> = 0>
+    class_ &def_cast(const T &op, const Extra &...extra) {
         op.execute_cast(*this, extra...);
         return *this;
     }
 
     template <typename... Args, typename... Extra>
     class_ &def(const detail::initimpl::constructor<Args...> &init, const Extra &...extra) {
         PYBIND11_WORKAROUND_INCORRECT_MSVC_C4100(init);
@@ -1643,15 +1700,15 @@
         auto *ptr = new capture{std::forward<Func>(func)};
         install_buffer_funcs(
             [](PyObject *obj, void *ptr) -> buffer_info * {
                 detail::make_caster<type> caster;
                 if (!caster.load(obj, false)) {
                     return nullptr;
                 }
-                return new buffer_info(((capture *) ptr)->func(caster));
+                return new buffer_info(((capture *) ptr)->func(std::move(caster)));
             },
             ptr);
         weakref(m_ptr, cpp_function([ptr](handle wr) {
                     delete ptr;
                     wr.dec_ref();
                 }))
             .release();
@@ -1734,15 +1791,16 @@
         return def_property_static(name, fget, nullptr, extra...);
     }
 
     /// Uses return_value_policy::reference_internal by default
     template <typename Getter, typename Setter, typename... Extra>
     class_ &
     def_property(const char *name, const Getter &fget, const Setter &fset, const Extra &...extra) {
-        return def_property(name, fget, cpp_function(method_adaptor<type>(fset)), extra...);
+        return def_property(
+            name, fget, cpp_function(method_adaptor<type>(fset), is_setter()), extra...);
     }
     template <typename Getter, typename... Extra>
     class_ &def_property(const char *name,
                          const Getter &fget,
                          const cpp_function &fset,
                          const Extra &...extra) {
         return def_property(name,
@@ -1845,15 +1903,15 @@
     static void init_holder(detail::instance *inst,
                             detail::value_and_holder &v_h,
                             const holder_type *holder_ptr,
                             const void * /* dummy -- not enable_shared_from_this<T>) */) {
         if (holder_ptr) {
             init_holder_from_existing(v_h, holder_ptr, std::is_copy_constructible<holder_type>());
             v_h.set_holder_constructed();
-        } else if (inst->owned || detail::always_construct_holder<holder_type>::value) {
+        } else if (detail::always_construct_holder<holder_type>::value || inst->owned) {
             new (std::addressof(v_h.holder<holder_type>())) holder_type(v_h.value_ptr<type>());
             v_h.set_holder_constructed();
         }
     }
 
     /// Performs instance initialization including constructing a holder and registering the known
     /// instance.  Should be called as soon as the `type` value_ptr is set for an instance.  Takes
@@ -1885,17 +1943,30 @@
                 v_h.value_ptr<type>(), v_h.type->type_size, v_h.type->type_align);
         }
         v_h.value_ptr() = nullptr;
     }
 
     static detail::function_record *get_function_record(handle h) {
         h = detail::get_function(h);
-        return h ? (detail::function_record *) reinterpret_borrow<capsule>(
-                   PyCFunction_GET_SELF(h.ptr()))
-                 : nullptr;
+        if (!h) {
+            return nullptr;
+        }
+
+        handle func_self = PyCFunction_GET_SELF(h.ptr());
+        if (!func_self) {
+            throw error_already_set();
+        }
+        if (!isinstance<capsule>(func_self)) {
+            return nullptr;
+        }
+        auto cap = reinterpret_borrow<capsule>(func_self);
+        if (!detail::is_function_record_capsule(cap)) {
+            return nullptr;
+        }
+        return cap.get_pointer<detail::function_record>();
     }
 };
 
 /// Binds an existing constructor taking arguments Args...
 template <typename... Args>
 detail::initimpl::constructor<Args...> init() {
     return {};
@@ -1948,52 +2019,59 @@
         auto property = handle((PyObject *) &PyProperty_Type);
         auto static_property = handle((PyObject *) get_internals().static_property_type);
 
         m_base.attr("__repr__") = cpp_function(
             [](const object &arg) -> str {
                 handle type = type::handle_of(arg);
                 object type_name = type.attr("__name__");
-                return pybind11::str("<{}.{}: {}>").format(type_name, enum_name(arg), int_(arg));
+                return pybind11::str("<{}.{}: {}>")
+                    .format(std::move(type_name), enum_name(arg), int_(arg));
             },
             name("__repr__"),
             is_method(m_base));
 
         m_base.attr("name") = property(cpp_function(&enum_name, name("name"), is_method(m_base)));
 
         m_base.attr("__str__") = cpp_function(
             [](handle arg) -> str {
                 object type_name = type::handle_of(arg).attr("__name__");
-                return pybind11::str("{}.{}").format(type_name, enum_name(arg));
+                return pybind11::str("{}.{}").format(std::move(type_name), enum_name(arg));
             },
-            name("name"),
+            name("__str__"),
             is_method(m_base));
 
-        m_base.attr("__doc__") = static_property(
-            cpp_function(
-                [](handle arg) -> std::string {
-                    std::string docstring;
-                    dict entries = arg.attr("__entries");
-                    if (((PyTypeObject *) arg.ptr())->tp_doc) {
-                        docstring += std::string(((PyTypeObject *) arg.ptr())->tp_doc) + "\n\n";
-                    }
-                    docstring += "Members:";
-                    for (auto kv : entries) {
-                        auto key = std::string(pybind11::str(kv.first));
-                        auto comment = kv.second[int_(1)];
-                        docstring += "\n\n  " + key;
-                        if (!comment.is_none()) {
-                            docstring += " : " + (std::string) pybind11::str(comment);
+        if (options::show_enum_members_docstring()) {
+            m_base.attr("__doc__") = static_property(
+                cpp_function(
+                    [](handle arg) -> std::string {
+                        std::string docstring;
+                        dict entries = arg.attr("__entries");
+                        if (((PyTypeObject *) arg.ptr())->tp_doc) {
+                            docstring += std::string(
+                                reinterpret_cast<PyTypeObject *>(arg.ptr())->tp_doc);
+                            docstring += "\n\n";
                         }
-                    }
-                    return docstring;
-                },
-                name("__doc__")),
-            none(),
-            none(),
-            "");
+                        docstring += "Members:";
+                        for (auto kv : entries) {
+                            auto key = std::string(pybind11::str(kv.first));
+                            auto comment = kv.second[int_(1)];
+                            docstring += "\n\n  ";
+                            docstring += key;
+                            if (!comment.is_none()) {
+                                docstring += " : ";
+                                docstring += pybind11::str(comment).cast<std::string>();
+                            }
+                        }
+                        return docstring;
+                    },
+                    name("__doc__")),
+                none(),
+                none(),
+                "");
+        }
 
         m_base.attr("__members__") = static_property(cpp_function(
                                                          [](handle arg) -> dict {
                                                              dict entries = arg.attr("__entries"),
                                                                   m;
                                                              for (auto kv : entries) {
                                                                  m[kv.first] = kv.second[int_(0)];
@@ -2082,20 +2160,20 @@
     }
 
     PYBIND11_NOINLINE void value(char const *name_, object value, const char *doc = nullptr) {
         dict entries = m_base.attr("__entries");
         str name(name_);
         if (entries.contains(name)) {
             std::string type_name = (std::string) str(m_base.attr("__name__"));
-            throw value_error(type_name + ": element \"" + std::string(name_)
+            throw value_error(std::move(type_name) + ": element \"" + std::string(name_)
                               + "\" already exists!");
         }
 
-        entries[name] = std::make_pair(value, doc);
-        m_base.attr(name) = value;
+        entries[name] = pybind11::make_tuple(value, doc);
+        m_base.attr(std::move(name)) = std::move(value);
     }
 
     PYBIND11_NOINLINE void export_values() {
         dict entries = m_base.attr("__entries");
         for (auto kv : entries) {
             m_parent.attr(kv.first) = kv.second[int_(0)];
         }
@@ -2169,17 +2247,14 @@
         constexpr bool is_convertible = std::is_convertible<Type, Underlying>::value;
         m_base.init(is_arithmetic, is_convertible);
 
         def(init([](Scalar i) { return static_cast<Type>(i); }), arg("value"));
         def_property_readonly("value", [](Type value) { return (Scalar) value; });
         def("__int__", [](Type value) { return (Scalar) value; });
         def("__index__", [](Type value) { return (Scalar) value; });
-#if PY_MAJOR_VERSION < 3
-        def("__long__", [](Type value) { return (Scalar) value; });
-#endif
         attr("__setstate__") = cpp_function(
             [](detail::value_and_holder &v_h, Scalar arg) {
                 detail::initimpl::setstate<Base>(
                     v_h, static_cast<Type>(arg), Py_TYPE(v_h.inst) != v_h.type->type);
             },
             detail::is_new_style_constructor(),
             pybind11::name("__setstate__"),
@@ -2375,91 +2450,106 @@
                     return Access()(s.it);
                     // NOLINTNEXTLINE(readability-const-return-type) // PR #3263
                 },
                 std::forward<Extra>(extra)...,
                 Policy);
     }
 
-    return cast(state{first, last, true});
+    return cast(state{std::forward<Iterator>(first), std::forward<Sentinel>(last), true});
 }
 
 PYBIND11_NAMESPACE_END(detail)
 
 /// Makes a python iterator from a first and past-the-end C++ InputIterator.
 template <return_value_policy Policy = return_value_policy::reference_internal,
           typename Iterator,
           typename Sentinel,
           typename ValueType = typename detail::iterator_access<Iterator>::result_type,
           typename... Extra>
-iterator make_iterator(Iterator first, Sentinel last, Extra &&...extra) {
+typing::Iterator<ValueType> make_iterator(Iterator first, Sentinel last, Extra &&...extra) {
     return detail::make_iterator_impl<detail::iterator_access<Iterator>,
                                       Policy,
                                       Iterator,
                                       Sentinel,
                                       ValueType,
-                                      Extra...>(first, last, std::forward<Extra>(extra)...);
+                                      Extra...>(std::forward<Iterator>(first),
+                                                std::forward<Sentinel>(last),
+                                                std::forward<Extra>(extra)...);
 }
 
 /// Makes a python iterator over the keys (`.first`) of a iterator over pairs from a
 /// first and past-the-end InputIterator.
 template <return_value_policy Policy = return_value_policy::reference_internal,
           typename Iterator,
           typename Sentinel,
           typename KeyType = typename detail::iterator_key_access<Iterator>::result_type,
           typename... Extra>
-iterator make_key_iterator(Iterator first, Sentinel last, Extra &&...extra) {
+typing::Iterator<KeyType> make_key_iterator(Iterator first, Sentinel last, Extra &&...extra) {
     return detail::make_iterator_impl<detail::iterator_key_access<Iterator>,
                                       Policy,
                                       Iterator,
                                       Sentinel,
                                       KeyType,
-                                      Extra...>(first, last, std::forward<Extra>(extra)...);
+                                      Extra...>(std::forward<Iterator>(first),
+                                                std::forward<Sentinel>(last),
+                                                std::forward<Extra>(extra)...);
 }
 
 /// Makes a python iterator over the values (`.second`) of a iterator over pairs from a
 /// first and past-the-end InputIterator.
 template <return_value_policy Policy = return_value_policy::reference_internal,
           typename Iterator,
           typename Sentinel,
           typename ValueType = typename detail::iterator_value_access<Iterator>::result_type,
           typename... Extra>
-iterator make_value_iterator(Iterator first, Sentinel last, Extra &&...extra) {
+typing::Iterator<ValueType> make_value_iterator(Iterator first, Sentinel last, Extra &&...extra) {
     return detail::make_iterator_impl<detail::iterator_value_access<Iterator>,
                                       Policy,
                                       Iterator,
                                       Sentinel,
                                       ValueType,
-                                      Extra...>(first, last, std::forward<Extra>(extra)...);
+                                      Extra...>(std::forward<Iterator>(first),
+                                                std::forward<Sentinel>(last),
+                                                std::forward<Extra>(extra)...);
 }
 
 /// Makes an iterator over values of an stl container or other container supporting
 /// `std::begin()`/`std::end()`
 template <return_value_policy Policy = return_value_policy::reference_internal,
           typename Type,
+          typename ValueType = typename detail::iterator_access<
+              decltype(std::begin(std::declval<Type &>()))>::result_type,
           typename... Extra>
-iterator make_iterator(Type &value, Extra &&...extra) {
-    return make_iterator<Policy>(std::begin(value), std::end(value), extra...);
+typing::Iterator<ValueType> make_iterator(Type &value, Extra &&...extra) {
+    return make_iterator<Policy>(
+        std::begin(value), std::end(value), std::forward<Extra>(extra)...);
 }
 
 /// Makes an iterator over the keys (`.first`) of a stl map-like container supporting
 /// `std::begin()`/`std::end()`
 template <return_value_policy Policy = return_value_policy::reference_internal,
           typename Type,
+          typename KeyType = typename detail::iterator_key_access<
+              decltype(std::begin(std::declval<Type &>()))>::result_type,
           typename... Extra>
-iterator make_key_iterator(Type &value, Extra &&...extra) {
-    return make_key_iterator<Policy>(std::begin(value), std::end(value), extra...);
+typing::Iterator<KeyType> make_key_iterator(Type &value, Extra &&...extra) {
+    return make_key_iterator<Policy>(
+        std::begin(value), std::end(value), std::forward<Extra>(extra)...);
 }
 
 /// Makes an iterator over the values (`.second`) of a stl map-like container supporting
 /// `std::begin()`/`std::end()`
 template <return_value_policy Policy = return_value_policy::reference_internal,
           typename Type,
+          typename ValueType = typename detail::iterator_value_access<
+              decltype(std::begin(std::declval<Type &>()))>::result_type,
           typename... Extra>
-iterator make_value_iterator(Type &value, Extra &&...extra) {
-    return make_value_iterator<Policy>(std::begin(value), std::end(value), extra...);
+typing::Iterator<ValueType> make_value_iterator(Type &value, Extra &&...extra) {
+    return make_value_iterator<Policy>(
+        std::begin(value), std::end(value), std::forward<Extra>(extra)...);
 }
 
 template <typename InputType, typename OutputType>
 void implicitly_convertible() {
     struct set_flag {
         bool &flag;
         explicit set_flag(bool &flag_) : flag(flag_) { flag_ = true; }
@@ -2480,15 +2570,15 @@
         if (result == nullptr) {
             PyErr_Clear();
         }
         return result;
     };
 
     if (auto *tinfo = detail::get_type_info(typeid(OutputType))) {
-        tinfo->implicit_conversions.push_back(implicit_caster);
+        tinfo->implicit_conversions.emplace_back(std::move(implicit_caster));
     } else {
         pybind11_fail("implicitly_convertible: Unable to find type " + type_id<OutputType>());
     }
 }
 
 inline void register_exception_translator(ExceptionTranslator &&translator) {
     detail::get_internals().registered_exception_translators.push_front(
@@ -2505,71 +2595,69 @@
     detail::get_local_internals().registered_exception_translators.push_front(
         std::forward<ExceptionTranslator>(translator));
 }
 
 /**
  * Wrapper to generate a new Python exception type.
  *
- * This should only be used with PyErr_SetString for now.
+ * This should only be used with py::set_error() for now.
  * It is not (yet) possible to use as a py::base.
  * Template type argument is reserved for future use.
  */
 template <typename type>
 class exception : public object {
 public:
     exception() = default;
     exception(handle scope, const char *name, handle base = PyExc_Exception) {
         std::string full_name
             = scope.attr("__name__").cast<std::string>() + std::string(".") + name;
-        m_ptr = PyErr_NewException(const_cast<char *>(full_name.c_str()), base.ptr(), NULL);
+        m_ptr = PyErr_NewException(const_cast<char *>(full_name.c_str()), base.ptr(), nullptr);
         if (hasattr(scope, "__dict__") && scope.attr("__dict__").contains(name)) {
             pybind11_fail("Error during initialization: multiple incompatible "
                           "definitions with name \""
                           + std::string(name) + "\"");
         }
         scope.attr(name) = *this;
     }
 
     // Sets the current python exception to this exception object with the given message
-    void operator()(const char *message) { PyErr_SetString(m_ptr, message); }
+    PYBIND11_DEPRECATED("Please use py::set_error() instead "
+                        "(https://github.com/pybind/pybind11/pull/4772)")
+    void operator()(const char *message) const { set_error(*this, message); }
 };
 
 PYBIND11_NAMESPACE_BEGIN(detail)
-// Returns a reference to a function-local static exception object used in the simple
-// register_exception approach below.  (It would be simpler to have the static local variable
-// directly in register_exception, but that makes clang <3.5 segfault - issue #1349).
-template <typename CppException>
-exception<CppException> &get_exception_object() {
-    static exception<CppException> ex;
-    return ex;
-}
+
+template <>
+struct handle_type_name<exception<void>> {
+    static constexpr auto name = const_name("Exception");
+};
 
 // Helper function for register_exception and register_local_exception
 template <typename CppException>
 exception<CppException> &
 register_exception_impl(handle scope, const char *name, handle base, bool isLocal) {
-    auto &ex = detail::get_exception_object<CppException>();
-    if (!ex) {
-        ex = exception<CppException>(scope, name, base);
-    }
+    PYBIND11_CONSTINIT static gil_safe_call_once_and_store<exception<CppException>> exc_storage;
+    exc_storage.call_once_and_store_result(
+        [&]() { return exception<CppException>(scope, name, base); });
 
     auto register_func
         = isLocal ? &register_local_exception_translator : &register_exception_translator;
 
     register_func([](std::exception_ptr p) {
         if (!p) {
             return;
         }
         try {
             std::rethrow_exception(p);
         } catch (const CppException &e) {
-            detail::get_exception_object<CppException>()(e.what());
+            set_error(exc_storage.get_stored(), e.what());
         }
     });
-    return ex;
+    return exc_storage.get_stored();
 }
 
 PYBIND11_NAMESPACE_END(detail)
 
 /**
  * Registers a Python exception in `m` of the given `name` and installs a translator to
  * translate the C++ exception to the created Python exception using the what() method.
@@ -2598,16 +2686,16 @@
 
 PYBIND11_NAMESPACE_BEGIN(detail)
 PYBIND11_NOINLINE void print(const tuple &args, const dict &kwargs) {
     auto strings = tuple(args.size());
     for (size_t i = 0; i < args.size(); ++i) {
         strings[i] = str(args[i]);
     }
-    auto sep = kwargs.contains("sep") ? kwargs["sep"] : cast(" ");
-    auto line = sep.attr("join")(strings);
+    auto sep = kwargs.contains("sep") ? kwargs["sep"] : str(" ");
+    auto line = sep.attr("join")(std::move(strings));
 
     object file;
     if (kwargs.contains("file")) {
         file = kwargs["file"].cast<object>();
     } else {
         try {
             file = module_::import("sys").attr("stdout");
@@ -2617,40 +2705,44 @@
                importing 'sys' can fail. Give up rather than crashing the
                interpreter in this case. */
             return;
         }
     }
 
     auto write = file.attr("write");
-    write(line);
-    write(kwargs.contains("end") ? kwargs["end"] : cast("\n"));
+    write(std::move(line));
+    write(kwargs.contains("end") ? kwargs["end"] : str("\n"));
 
     if (kwargs.contains("flush") && kwargs["flush"].cast<bool>()) {
         file.attr("flush")();
     }
 }
 PYBIND11_NAMESPACE_END(detail)
 
 template <return_value_policy policy = return_value_policy::automatic_reference, typename... Args>
 void print(Args &&...args) {
     auto c = detail::collect_arguments<policy>(std::forward<Args>(args)...);
     detail::print(c.args(), c.kwargs());
 }
 
-error_already_set::~error_already_set() {
-    if (m_type) {
-        gil_scoped_acquire gil;
-        error_scope scope;
-        m_type.release().dec_ref();
-        m_value.release().dec_ref();
-        m_trace.release().dec_ref();
-    }
+inline void
+error_already_set::m_fetched_error_deleter(detail::error_fetch_and_normalize *raw_ptr) {
+    gil_scoped_acquire gil;
+    error_scope scope;
+    delete raw_ptr;
+}
+
+inline const char *error_already_set::what() const noexcept {
+    gil_scoped_acquire gil;
+    error_scope scope;
+    return m_fetched_error->error_string().c_str();
 }
 
 PYBIND11_NAMESPACE_BEGIN(detail)
+
 inline function
 get_type_override(const void *this_ptr, const type_info *this_type, const char *name) {
     handle self = get_object_handle(this_ptr, this_type);
     if (!self) {
         return function();
     }
     handle type = type::handle_of(self);
@@ -2661,30 +2753,34 @@
     auto &cache = get_internals().inactive_override_cache;
     if (cache.find(key) != cache.end()) {
         return function();
     }
 
     function override = getattr(self, name, function());
     if (override.is_cpp_function()) {
-        cache.insert(key);
+        cache.insert(std::move(key));
         return function();
     }
 
     /* Don't call dispatch code if invoked from overridden function.
        Unfortunately this doesn't work on PyPy. */
 #if !defined(PYPY_VERSION)
 #    if PY_VERSION_HEX >= 0x03090000
     PyFrameObject *frame = PyThreadState_GetFrame(PyThreadState_Get());
     if (frame != nullptr) {
         PyCodeObject *f_code = PyFrame_GetCode(frame);
         // f_code is guaranteed to not be NULL
         if ((std::string) str(f_code->co_name) == name && f_code->co_argcount > 0) {
             PyObject *locals = PyEval_GetLocals();
             if (locals != nullptr) {
+#        if PY_VERSION_HEX >= 0x030b0000
+                PyObject *co_varnames = PyCode_GetVarnames(f_code);
+#        else
                 PyObject *co_varnames = PyObject_GetAttrString((PyObject *) f_code, "co_varnames");
+#        endif
                 PyObject *self_arg = PyTuple_GET_ITEM(co_varnames, 0);
                 Py_DECREF(co_varnames);
                 PyObject *self_caller = dict_getitem(locals, self_arg);
                 if (self_caller == self.ptr()) {
                     Py_DECREF(f_code);
                     Py_DECREF(frame);
                     return function();
@@ -2861,11 +2957,7 @@
         PYBIND11_TYPE(ret_type), PYBIND11_TYPE(cname), name, fn, __VA_ARGS__);
 #define PYBIND11_OVERLOAD(ret_type, cname, fn, ...)                                               \
     PYBIND11_OVERRIDE(PYBIND11_TYPE(ret_type), PYBIND11_TYPE(cname), fn, __VA_ARGS__)
 #define PYBIND11_OVERLOAD_PURE(ret_type, cname, fn, ...)                                          \
     PYBIND11_OVERRIDE_PURE(PYBIND11_TYPE(ret_type), PYBIND11_TYPE(cname), fn, __VA_ARGS__);
 
 PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
-
-#if defined(__GNUC__) && __GNUC__ == 7
-#    pragma GCC diagnostic pop // -Wnoexcept-type
-#endif
```

### Comparing `python_prtree-0.6.0/third/pybind11/include/pybind11/pytypes.h` & `python_prtree-0.6.1/third/pybind11/include/pybind11/pytypes.h`

 * *Files 13% similar despite different names*

```diff
@@ -8,27 +8,37 @@
 */
 
 #pragma once
 
 #include "detail/common.h"
 #include "buffer_info.h"
 
+#include <assert.h>
+#include <cstddef>
+#include <exception>
+#include <frameobject.h>
+#include <iterator>
+#include <memory>
+#include <string>
 #include <type_traits>
+#include <typeinfo>
 #include <utility>
 
 #if defined(PYBIND11_HAS_OPTIONAL)
 #    include <optional>
 #endif
 
 #ifdef PYBIND11_HAS_STRING_VIEW
 #    include <string_view>
 #endif
 
 PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 
+PYBIND11_WARNING_DISABLE_MSVC(4127)
+
 /* A few forward declarations */
 class handle;
 class object;
 class str;
 class iterator;
 class type;
 struct arg;
@@ -45,14 +55,15 @@
 struct obj_attr;
 struct str_attr;
 struct generic_item;
 struct sequence_item;
 struct list_item;
 struct tuple_item;
 } // namespace accessor_policies
+// PLEASE KEEP handle_type_name SPECIALIZATIONS IN SYNC.
 using obj_attr_accessor = accessor<accessor_policies::obj_attr>;
 using str_attr_accessor = accessor<accessor_policies::str_attr>;
 using item_accessor = accessor<accessor_policies::generic_item>;
 using sequence_accessor = accessor<accessor_policies::sequence_item>;
 using list_accessor = accessor<accessor_policies::list_item>;
 using tuple_accessor = accessor<accessor_policies::tuple_item>;
 
@@ -81,25 +92,29 @@
     /** \rst
         Return an internal functor to invoke the object's sequence protocol. Casting
         the returned ``detail::item_accessor`` instance to a `handle` or `object`
         subclass causes a corresponding call to ``__getitem__``. Assigning a `handle`
         or `object` subclass causes a call to ``__setitem__``.
     \endrst */
     item_accessor operator[](handle key) const;
-    /// See above (the only difference is that they key is provided as a string literal)
+    /// See above (the only difference is that the key's reference is stolen)
+    item_accessor operator[](object &&key) const;
+    /// See above (the only difference is that the key is provided as a string literal)
     item_accessor operator[](const char *key) const;
 
     /** \rst
         Return an internal functor to access the object's attributes. Casting the
         returned ``detail::obj_attr_accessor`` instance to a `handle` or `object`
         subclass causes a corresponding call to ``getattr``. Assigning a `handle`
         or `object` subclass causes a call to ``setattr``.
     \endrst */
     obj_attr_accessor attr(handle key) const;
-    /// See above (the only difference is that they key is provided as a string literal)
+    /// See above (the only difference is that the key's reference is stolen)
+    obj_attr_accessor attr(object &&key) const;
+    /// See above (the only difference is that the key is provided as a string literal)
     str_attr_accessor attr(const char *key) const;
 
     /** \rst
         Matches * unpacking in Python, e.g. to unpack arguments out of a ``tuple``
         or ``list`` for a function call. Applying another * to the result yields
         ** unpacking, e.g. to unpack a dict as function keyword arguments.
         See :ref:`calling_python_functions`.
@@ -139,31 +154,31 @@
     bool operator<=(object_api const &other) const { return rich_compare(other, Py_LE); }
     bool operator>(object_api const &other) const { return rich_compare(other, Py_GT); }
     bool operator>=(object_api const &other) const { return rich_compare(other, Py_GE); }
 
     object operator-() const;
     object operator~() const;
     object operator+(object_api const &other) const;
-    object operator+=(object_api const &other) const;
+    object operator+=(object_api const &other);
     object operator-(object_api const &other) const;
-    object operator-=(object_api const &other) const;
+    object operator-=(object_api const &other);
     object operator*(object_api const &other) const;
-    object operator*=(object_api const &other) const;
+    object operator*=(object_api const &other);
     object operator/(object_api const &other) const;
-    object operator/=(object_api const &other) const;
+    object operator/=(object_api const &other);
     object operator|(object_api const &other) const;
-    object operator|=(object_api const &other) const;
+    object operator|=(object_api const &other);
     object operator&(object_api const &other) const;
-    object operator&=(object_api const &other) const;
+    object operator&=(object_api const &other);
     object operator^(object_api const &other) const;
-    object operator^=(object_api const &other) const;
+    object operator^=(object_api const &other);
     object operator<<(object_api const &other) const;
-    object operator<<=(object_api const &other) const;
+    object operator<<=(object_api const &other);
     object operator>>(object_api const &other) const;
-    object operator>>=(object_api const &other) const;
+    object operator>>=(object_api const &other);
 
     PYBIND11_DEPRECATED("Use py::str(obj) instead")
     pybind11::str str() const;
 
     /// Get or set the object's docstring, i.e. ``obj.__doc__``.
     str_attr_accessor doc() const;
 
@@ -174,16 +189,25 @@
     //     "Call py::type::handle_of(h) or py::type::of(h) instead of h.get_type()")
     handle get_type() const;
 
 private:
     bool rich_compare(object_api const &other, int value) const;
 };
 
+template <typename T>
+using is_pyobj_ptr_or_nullptr_t = detail::any_of<std::is_same<T, PyObject *>,
+                                                 std::is_same<T, PyObject *const>,
+                                                 std::is_same<T, std::nullptr_t>>;
+
 PYBIND11_NAMESPACE_END(detail)
 
+#if !defined(PYBIND11_HANDLE_REF_DEBUG) && !defined(NDEBUG)
+#    define PYBIND11_HANDLE_REF_DEBUG
+#endif
+
 /** \rst
     Holds a reference to a Python object (no reference counting)
 
     The `handle` class is a thin wrapper around an arbitrary Python object (i.e. a
     ``PyObject *`` in Python's C API). It does not perform any automatic reference
     counting and merely provides a basic C++ interface to various Python API functions.
 
@@ -191,38 +215,66 @@
         The `object` class inherits from `handle` and adds automatic reference
         counting features.
 \endrst */
 class handle : public detail::object_api<handle> {
 public:
     /// The default constructor creates a handle with a ``nullptr``-valued pointer
     handle() = default;
-    /// Creates a ``handle`` from the given raw Python object pointer
+
+    /// Enable implicit conversion from ``PyObject *`` and ``nullptr``.
+    /// Not using ``handle(PyObject *ptr)`` to avoid implicit conversion from ``0``.
+    template <typename T,
+              detail::enable_if_t<detail::is_pyobj_ptr_or_nullptr_t<T>::value, int> = 0>
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    handle(T ptr) : m_ptr(ptr) {}
+
+    /// Enable implicit conversion through ``T::operator PyObject *()``.
+    template <
+        typename T,
+        detail::enable_if_t<detail::all_of<detail::none_of<std::is_base_of<handle, T>,
+                                                           detail::is_pyobj_ptr_or_nullptr_t<T>>,
+                                           std::is_convertible<T, PyObject *>>::value,
+                            int>
+        = 0>
     // NOLINTNEXTLINE(google-explicit-constructor)
-    handle(PyObject *ptr) : m_ptr(ptr) {} // Allow implicit conversion from PyObject*
+    handle(T &obj) : m_ptr(obj) {}
 
     /// Return the underlying ``PyObject *`` pointer
     PyObject *ptr() const { return m_ptr; }
     PyObject *&ptr() { return m_ptr; }
 
     /** \rst
         Manually increase the reference count of the Python object. Usually, it is
         preferable to use the `object` class which derives from `handle` and calls
         this function automatically. Returns a reference to itself.
     \endrst */
     const handle &inc_ref() const & {
+#ifdef PYBIND11_HANDLE_REF_DEBUG
+        inc_ref_counter(1);
+#endif
+#ifdef PYBIND11_ASSERT_GIL_HELD_INCREF_DECREF
+        if (m_ptr != nullptr && !PyGILState_Check()) {
+            throw_gilstate_error("pybind11::handle::inc_ref()");
+        }
+#endif
         Py_XINCREF(m_ptr);
         return *this;
     }
 
     /** \rst
         Manually decrease the reference count of the Python object. Usually, it is
         preferable to use the `object` class which derives from `handle` and calls
         this function automatically. Returns a reference to itself.
     \endrst */
     const handle &dec_ref() const & {
+#ifdef PYBIND11_ASSERT_GIL_HELD_INCREF_DECREF
+        if (m_ptr != nullptr && !PyGILState_Check()) {
+            throw_gilstate_error("pybind11::handle::dec_ref()");
+        }
+#endif
         Py_XDECREF(m_ptr);
         return *this;
     }
 
     /** \rst
         Attempt to cast the Python object into the given C++ type. A `cast_error`
         will be throw upon failure.
@@ -240,16 +292,61 @@
     PYBIND11_DEPRECATED("Use !obj1.is(obj2) instead")
     bool operator!=(const handle &h) const { return m_ptr != h.m_ptr; }
     PYBIND11_DEPRECATED("Use handle::operator bool() instead")
     bool check() const { return m_ptr != nullptr; }
 
 protected:
     PyObject *m_ptr = nullptr;
+
+private:
+#ifdef PYBIND11_ASSERT_GIL_HELD_INCREF_DECREF
+    void throw_gilstate_error(const std::string &function_name) const {
+        fprintf(
+            stderr,
+            "%s is being called while the GIL is either not held or invalid. Please see "
+            "https://pybind11.readthedocs.io/en/stable/advanced/"
+            "misc.html#common-sources-of-global-interpreter-lock-errors for debugging advice.\n"
+            "If you are convinced there is no bug in your code, you can #define "
+            "PYBIND11_NO_ASSERT_GIL_HELD_INCREF_DECREF "
+            "to disable this check. In that case you have to ensure this #define is consistently "
+            "used for all translation units linked into a given pybind11 extension, otherwise "
+            "there will be ODR violations.",
+            function_name.c_str());
+        if (Py_TYPE(m_ptr)->tp_name != nullptr) {
+            fprintf(stderr,
+                    " The failing %s call was triggered on a %s object.",
+                    function_name.c_str(),
+                    Py_TYPE(m_ptr)->tp_name);
+        }
+        fprintf(stderr, "\n");
+        fflush(stderr);
+        throw std::runtime_error(function_name + " PyGILState_Check() failure.");
+    }
+#endif
+
+#ifdef PYBIND11_HANDLE_REF_DEBUG
+    static std::size_t inc_ref_counter(std::size_t add) {
+        thread_local std::size_t counter = 0;
+        counter += add;
+        return counter;
+    }
+
+public:
+    static std::size_t inc_ref_counter() { return inc_ref_counter(0); }
+#endif
 };
 
+inline void set_error(const handle &type, const char *message) {
+    PyErr_SetString(type.ptr(), message);
+}
+
+inline void set_error(const handle &type, const handle &value) {
+    PyErr_SetObject(type.ptr(), value.ptr());
+}
+
 /** \rst
     Holds a reference to a Python object (with reference counting)
 
     Like `handle`, the `object` class is a thin wrapper around an arbitrary Python
     object (i.e. a ``PyObject *`` in Python's C API). In contrast to `handle`, it
     optionally increases the object's reference count upon construction, and it
     *always* decreases the reference count when the `object` instance goes out of
@@ -264,18 +361,15 @@
         if (is_borrowed) {
             inc_ref();
         }
     }
     /// Copy constructor; always increases the reference count
     object(const object &o) : handle(o) { inc_ref(); }
     /// Move constructor; steals the object from ``other`` and preserves its reference count
-    object(object &&other) noexcept {
-        m_ptr = other.m_ptr;
-        other.m_ptr = nullptr;
-    }
+    object(object &&other) noexcept : handle(other) { other.m_ptr = nullptr; }
     /// Destructor; automatically calls `handle::dec_ref()`
     ~object() { dec_ref(); }
 
     /** \rst
         Resets the internal pointer to ``nullptr`` without decreasing the
         object's reference count. The function returns a raw handle to the original
         Python object.
@@ -283,33 +377,50 @@
     handle release() {
         PyObject *tmp = m_ptr;
         m_ptr = nullptr;
         return handle(tmp);
     }
 
     object &operator=(const object &other) {
-        other.inc_ref();
-        // Use temporary variable to ensure `*this` remains valid while
-        // `Py_XDECREF` executes, in case `*this` is accessible from Python.
-        handle temp(m_ptr);
-        m_ptr = other.m_ptr;
-        temp.dec_ref();
+        // Skip inc_ref and dec_ref if both objects are the same
+        if (!this->is(other)) {
+            other.inc_ref();
+            // Use temporary variable to ensure `*this` remains valid while
+            // `Py_XDECREF` executes, in case `*this` is accessible from Python.
+            handle temp(m_ptr);
+            m_ptr = other.m_ptr;
+            temp.dec_ref();
+        }
         return *this;
     }
 
     object &operator=(object &&other) noexcept {
         if (this != &other) {
             handle temp(m_ptr);
             m_ptr = other.m_ptr;
             other.m_ptr = nullptr;
             temp.dec_ref();
         }
         return *this;
     }
 
+#define PYBIND11_INPLACE_OP(iop)                                                                  \
+    object iop(object_api const &other) { return operator=(handle::iop(other)); }
+
+    PYBIND11_INPLACE_OP(operator+=)
+    PYBIND11_INPLACE_OP(operator-=)
+    PYBIND11_INPLACE_OP(operator*=)
+    PYBIND11_INPLACE_OP(operator/=)
+    PYBIND11_INPLACE_OP(operator|=)
+    PYBIND11_INPLACE_OP(operator&=)
+    PYBIND11_INPLACE_OP(operator^=)
+    PYBIND11_INPLACE_OP(operator<<=)
+    PYBIND11_INPLACE_OP(operator>>=)
+#undef PYBIND11_INPLACE_OP
+
     // Calling cast() on an object lvalue just copies (via handle::cast)
     template <typename T>
     T cast() const &;
     // Calling on an object rvalue does a move, if needed and/or possible
     template <typename T>
     T cast() &&;
 
@@ -359,86 +470,323 @@
 \endrst */
 template <typename T>
 T reinterpret_steal(handle h) {
     return {h, object::stolen_t{}};
 }
 
 PYBIND11_NAMESPACE_BEGIN(detail)
+
+// Equivalent to obj.__class__.__name__ (or obj.__name__ if obj is a class).
+inline const char *obj_class_name(PyObject *obj) {
+    if (PyType_Check(obj)) {
+        return reinterpret_cast<PyTypeObject *>(obj)->tp_name;
+    }
+    return Py_TYPE(obj)->tp_name;
+}
+
 std::string error_string();
-PYBIND11_NAMESPACE_END(detail)
 
-#if defined(_MSC_VER)
-#    pragma warning(push)
-#    pragma warning(disable : 4275 4251)
-//     warning C4275: An exported class was derived from a class that wasn't exported.
-//     Can be ignored when derived from a STL class.
-#endif
-/// Fetch and hold an error which was already set in Python.  An instance of this is typically
-/// thrown to propagate python-side errors back through C++ which can either be caught manually or
-/// else falls back to the function dispatcher (which then raises the captured error back to
-/// python).
-class PYBIND11_EXPORT_EXCEPTION error_already_set : public std::runtime_error {
-public:
-    /// Constructs a new exception from the current Python error indicator, if any.  The current
-    /// Python error indicator will be cleared.
-    error_already_set() : std::runtime_error(detail::error_string()) {
+// The code in this struct is very unusual, to minimize the chances of
+// masking bugs (elsewhere) by errors during the error handling (here).
+// This is meant to be a lifeline for troubleshooting long-running processes
+// that crash under conditions that are virtually impossible to reproduce.
+// Low-level implementation alternatives are preferred to higher-level ones
+// that might raise cascading exceptions. Last-ditch-kind-of attempts are made
+// to report as much of the original error as possible, even if there are
+// secondary issues obtaining some of the details.
+struct error_fetch_and_normalize {
+    // This comment only applies to Python <= 3.11:
+    //     Immediate normalization is long-established behavior (starting with
+    //     https://github.com/pybind/pybind11/commit/135ba8deafb8bf64a15b24d1513899eb600e2011
+    //     from Sep 2016) and safest. Normalization could be deferred, but this could mask
+    //     errors elsewhere, the performance gain is very minor in typical situations
+    //     (usually the dominant bottleneck is EH unwinding), and the implementation here
+    //     would be more complex.
+    // Starting with Python 3.12, PyErr_Fetch() normalizes exceptions immediately.
+    // Any errors during normalization are tracked under __notes__.
+    explicit error_fetch_and_normalize(const char *called) {
         PyErr_Fetch(&m_type.ptr(), &m_value.ptr(), &m_trace.ptr());
+        if (!m_type) {
+            pybind11_fail("Internal error: " + std::string(called)
+                          + " called while "
+                            "Python error indicator not set.");
+        }
+        const char *exc_type_name_orig = detail::obj_class_name(m_type.ptr());
+        if (exc_type_name_orig == nullptr) {
+            pybind11_fail("Internal error: " + std::string(called)
+                          + " failed to obtain the name "
+                            "of the original active exception type.");
+        }
+        m_lazy_error_string = exc_type_name_orig;
+#if PY_VERSION_HEX >= 0x030C0000
+        // The presence of __notes__ is likely due to exception normalization
+        // errors, although that is not necessarily true, therefore insert a
+        // hint only:
+        if (PyObject_HasAttrString(m_value.ptr(), "__notes__")) {
+            m_lazy_error_string += "[WITH __notes__]";
+        }
+#else
+        // PyErr_NormalizeException() may change the exception type if there are cascading
+        // failures. This can potentially be extremely confusing.
+        PyErr_NormalizeException(&m_type.ptr(), &m_value.ptr(), &m_trace.ptr());
+        if (m_type.ptr() == nullptr) {
+            pybind11_fail("Internal error: " + std::string(called)
+                          + " failed to normalize the "
+                            "active exception.");
+        }
+        const char *exc_type_name_norm = detail::obj_class_name(m_type.ptr());
+        if (exc_type_name_norm == nullptr) {
+            pybind11_fail("Internal error: " + std::string(called)
+                          + " failed to obtain the name "
+                            "of the normalized active exception type.");
+        }
+#    if defined(PYPY_VERSION_NUM) && PYPY_VERSION_NUM < 0x07030a00
+        // This behavior runs the risk of masking errors in the error handling, but avoids a
+        // conflict with PyPy, which relies on the normalization here to change OSError to
+        // FileNotFoundError (https://github.com/pybind/pybind11/issues/4075).
+        m_lazy_error_string = exc_type_name_norm;
+#    else
+        if (exc_type_name_norm != m_lazy_error_string) {
+            std::string msg = std::string(called)
+                              + ": MISMATCH of original and normalized "
+                                "active exception types: ";
+            msg += "ORIGINAL ";
+            msg += m_lazy_error_string;
+            msg += " REPLACED BY ";
+            msg += exc_type_name_norm;
+            msg += ": " + format_value_and_trace();
+            pybind11_fail(msg);
+        }
+#    endif
+#endif
     }
 
-    error_already_set(const error_already_set &) = default;
-    error_already_set(error_already_set &&) = default;
+    error_fetch_and_normalize(const error_fetch_and_normalize &) = delete;
+    error_fetch_and_normalize(error_fetch_and_normalize &&) = delete;
+
+    std::string format_value_and_trace() const {
+        std::string result;
+        std::string message_error_string;
+        if (m_value) {
+            auto value_str = reinterpret_steal<object>(PyObject_Str(m_value.ptr()));
+            constexpr const char *message_unavailable_exc
+                = "<MESSAGE UNAVAILABLE DUE TO ANOTHER EXCEPTION>";
+            if (!value_str) {
+                message_error_string = detail::error_string();
+                result = message_unavailable_exc;
+            } else {
+                // Not using `value_str.cast<std::string>()`, to not potentially throw a secondary
+                // error_already_set that will then result in process termination (#4288).
+                auto value_bytes = reinterpret_steal<object>(
+                    PyUnicode_AsEncodedString(value_str.ptr(), "utf-8", "backslashreplace"));
+                if (!value_bytes) {
+                    message_error_string = detail::error_string();
+                    result = message_unavailable_exc;
+                } else {
+                    char *buffer = nullptr;
+                    Py_ssize_t length = 0;
+                    if (PyBytes_AsStringAndSize(value_bytes.ptr(), &buffer, &length) == -1) {
+                        message_error_string = detail::error_string();
+                        result = message_unavailable_exc;
+                    } else {
+                        result = std::string(buffer, static_cast<std::size_t>(length));
+                    }
+                }
+            }
+#if PY_VERSION_HEX >= 0x030B0000
+            auto notes
+                = reinterpret_steal<object>(PyObject_GetAttrString(m_value.ptr(), "__notes__"));
+            if (!notes) {
+                PyErr_Clear(); // No notes is good news.
+            } else {
+                auto len_notes = PyList_Size(notes.ptr());
+                if (len_notes < 0) {
+                    result += "\nFAILURE obtaining len(__notes__): " + detail::error_string();
+                } else {
+                    result += "\n__notes__ (len=" + std::to_string(len_notes) + "):";
+                    for (ssize_t i = 0; i < len_notes; i++) {
+                        PyObject *note = PyList_GET_ITEM(notes.ptr(), i);
+                        auto note_bytes = reinterpret_steal<object>(
+                            PyUnicode_AsEncodedString(note, "utf-8", "backslashreplace"));
+                        if (!note_bytes) {
+                            result += "\nFAILURE obtaining __notes__[" + std::to_string(i)
+                                      + "]: " + detail::error_string();
+                        } else {
+                            char *buffer = nullptr;
+                            Py_ssize_t length = 0;
+                            if (PyBytes_AsStringAndSize(note_bytes.ptr(), &buffer, &length)
+                                == -1) {
+                                result += "\nFAILURE formatting __notes__[" + std::to_string(i)
+                                          + "]: " + detail::error_string();
+                            } else {
+                                result += '\n';
+                                result += std::string(buffer, static_cast<std::size_t>(length));
+                            }
+                        }
+                    }
+                }
+            }
+#endif
+        } else {
+            result = "<MESSAGE UNAVAILABLE>";
+        }
+        if (result.empty()) {
+            result = "<EMPTY MESSAGE>";
+        }
+
+        bool have_trace = false;
+        if (m_trace) {
+#if !defined(PYPY_VERSION)
+            auto *tb = reinterpret_cast<PyTracebackObject *>(m_trace.ptr());
+
+            // Get the deepest trace possible.
+            while (tb->tb_next) {
+                tb = tb->tb_next;
+            }
+
+            PyFrameObject *frame = tb->tb_frame;
+            Py_XINCREF(frame);
+            result += "\n\nAt:\n";
+            while (frame) {
+#    if PY_VERSION_HEX >= 0x030900B1
+                PyCodeObject *f_code = PyFrame_GetCode(frame);
+#    else
+                PyCodeObject *f_code = frame->f_code;
+                Py_INCREF(f_code);
+#    endif
+                int lineno = PyFrame_GetLineNumber(frame);
+                result += "  ";
+                result += handle(f_code->co_filename).cast<std::string>();
+                result += '(';
+                result += std::to_string(lineno);
+                result += "): ";
+                result += handle(f_code->co_name).cast<std::string>();
+                result += '\n';
+                Py_DECREF(f_code);
+#    if PY_VERSION_HEX >= 0x030900B1
+                auto *b_frame = PyFrame_GetBack(frame);
+#    else
+                auto *b_frame = frame->f_back;
+                Py_XINCREF(b_frame);
+#    endif
+                Py_DECREF(frame);
+                frame = b_frame;
+            }
 
-    inline ~error_already_set() override;
+            have_trace = true;
+#endif //! defined(PYPY_VERSION)
+        }
+
+        if (!message_error_string.empty()) {
+            if (!have_trace) {
+                result += '\n';
+            }
+            result += "\nMESSAGE UNAVAILABLE DUE TO EXCEPTION: " + message_error_string;
+        }
+
+        return result;
+    }
+
+    std::string const &error_string() const {
+        if (!m_lazy_error_string_completed) {
+            m_lazy_error_string += ": " + format_value_and_trace();
+            m_lazy_error_string_completed = true;
+        }
+        return m_lazy_error_string;
+    }
 
-    /// Give the currently-held error back to Python, if any.  If there is currently a Python error
-    /// already set it is cleared first.  After this call, the current object no longer stores the
-    /// error variables (but the `.what()` string is still available).
     void restore() {
-        PyErr_Restore(m_type.release().ptr(), m_value.release().ptr(), m_trace.release().ptr());
+        if (m_restore_called) {
+            pybind11_fail("Internal error: pybind11::detail::error_fetch_and_normalize::restore() "
+                          "called a second time. ORIGINAL ERROR: "
+                          + error_string());
+        }
+        PyErr_Restore(m_type.inc_ref().ptr(), m_value.inc_ref().ptr(), m_trace.inc_ref().ptr());
+        m_restore_called = true;
     }
 
+    bool matches(handle exc) const {
+        return (PyErr_GivenExceptionMatches(m_type.ptr(), exc.ptr()) != 0);
+    }
+
+    // Not protecting these for simplicity.
+    object m_type, m_value, m_trace;
+
+private:
+    // Only protecting invariants.
+    mutable std::string m_lazy_error_string;
+    mutable bool m_lazy_error_string_completed = false;
+    mutable bool m_restore_called = false;
+};
+
+inline std::string error_string() {
+    return error_fetch_and_normalize("pybind11::detail::error_string").error_string();
+}
+
+PYBIND11_NAMESPACE_END(detail)
+
+/// Fetch and hold an error which was already set in Python.  An instance of this is typically
+/// thrown to propagate python-side errors back through C++ which can either be caught manually or
+/// else falls back to the function dispatcher (which then raises the captured error back to
+/// python).
+class PYBIND11_EXPORT_EXCEPTION error_already_set : public std::exception {
+public:
+    /// Fetches the current Python exception (using PyErr_Fetch()), which will clear the
+    /// current Python error indicator.
+    error_already_set()
+        : m_fetched_error{new detail::error_fetch_and_normalize("pybind11::error_already_set"),
+                          m_fetched_error_deleter} {}
+
+    /// The what() result is built lazily on demand.
+    /// WARNING: This member function needs to acquire the Python GIL. This can lead to
+    ///          crashes (undefined behavior) if the Python interpreter is finalizing.
+    const char *what() const noexcept override;
+
+    /// Restores the currently-held Python error (which will clear the Python error indicator first
+    /// if already set).
+    /// NOTE: This member function will always restore the normalized exception, which may or may
+    ///       not be the original Python exception.
+    /// WARNING: The GIL must be held when this member function is called!
+    void restore() { m_fetched_error->restore(); }
+
     /// If it is impossible to raise the currently-held error, such as in a destructor, we can
     /// write it out using Python's unraisable hook (`sys.unraisablehook`). The error context
     /// should be some object whose `repr()` helps identify the location of the error. Python
-    /// already knows the type and value of the error, so there is no need to repeat that. After
-    /// this call, the current object no longer stores the error variables, and neither does
-    /// Python.
+    /// already knows the type and value of the error, so there is no need to repeat that.
     void discard_as_unraisable(object err_context) {
         restore();
         PyErr_WriteUnraisable(err_context.ptr());
     }
     /// An alternate version of `discard_as_unraisable()`, where a string provides information on
     /// the location of the error. For example, `__func__` could be helpful.
+    /// WARNING: The GIL must be held when this member function is called!
     void discard_as_unraisable(const char *err_context) {
         discard_as_unraisable(reinterpret_steal<object>(PYBIND11_FROM_STRING(err_context)));
     }
 
     // Does nothing; provided for backwards compatibility.
     PYBIND11_DEPRECATED("Use of error_already_set.clear() is deprecated")
     void clear() {}
 
     /// Check if the currently trapped error type matches the given Python exception class (or a
     /// subclass thereof).  May also be passed a tuple to search for any exception class matches in
     /// the given tuple.
-    bool matches(handle exc) const {
-        return (PyErr_GivenExceptionMatches(m_type.ptr(), exc.ptr()) != 0);
-    }
+    bool matches(handle exc) const { return m_fetched_error->matches(exc); }
 
-    const object &type() const { return m_type; }
-    const object &value() const { return m_value; }
-    const object &trace() const { return m_trace; }
+    const object &type() const { return m_fetched_error->m_type; }
+    const object &value() const { return m_fetched_error->m_value; }
+    const object &trace() const { return m_fetched_error->m_trace; }
 
 private:
-    object m_type, m_value, m_trace;
-};
-#if defined(_MSC_VER)
-#    pragma warning(pop)
-#endif
+    std::shared_ptr<detail::error_fetch_and_normalize> m_fetched_error;
 
-#if PY_VERSION_HEX >= 0x03030000
+    /// WARNING: This custom deleter needs to acquire the Python GIL. This can lead to
+    ///          crashes (undefined behavior) if the Python interpreter is finalizing.
+    static void m_fetched_error_deleter(detail::error_fetch_and_normalize *raw_ptr);
+};
 
 /// Replaces the current Python error indicator with the chosen error, performing a
 /// 'raise from' to indicate that the chosen error was caused by the original error.
 inline void raise_from(PyObject *type, const char *message) {
     // Based on _PyErr_FormatVFromCause:
     // https://github.com/python/cpython/blob/467ab194fc6189d9f7310c89937c51abeac56839/Python/errors.c#L405
     // See https://github.com/pybind/pybind11/pull/2112 for details.
@@ -462,23 +810,20 @@
     PyException_SetCause(val2, val);
     PyException_SetContext(val2, val);
     PyErr_Restore(exc, val2, tb);
 }
 
 /// Sets the current Python error indicator with the chosen error, performing a 'raise from'
 /// from the error contained in error_already_set to indicate that the chosen error was
-/// caused by the original error. After this function is called error_already_set will
-/// no longer contain an error.
+/// caused by the original error.
 inline void raise_from(error_already_set &err, PyObject *type, const char *message) {
     err.restore();
     raise_from(type, message);
 }
 
-#endif
-
 /** \defgroup python_builtins const_name
     Unless stated otherwise, the following C++ functions behave the same
     as their Python counterparts.
  */
 
 /** \ingroup python_builtins
     \rst
@@ -587,59 +932,48 @@
 }
 
 /// @} python_builtins
 
 PYBIND11_NAMESPACE_BEGIN(detail)
 inline handle get_function(handle value) {
     if (value) {
-#if PY_MAJOR_VERSION >= 3
         if (PyInstanceMethod_Check(value.ptr())) {
             value = PyInstanceMethod_GET_FUNCTION(value.ptr());
-        } else
-#endif
-            if (PyMethod_Check(value.ptr())) {
+        } else if (PyMethod_Check(value.ptr())) {
             value = PyMethod_GET_FUNCTION(value.ptr());
         }
     }
     return value;
 }
 
 // Reimplementation of python's dict helper functions to ensure that exceptions
 // aren't swallowed (see #2862)
 
 // copied from cpython _PyDict_GetItemStringWithError
 inline PyObject *dict_getitemstring(PyObject *v, const char *key) {
-#if PY_MAJOR_VERSION >= 3
     PyObject *kv = nullptr, *rv = nullptr;
     kv = PyUnicode_FromString(key);
-    if (kv == NULL) {
+    if (kv == nullptr) {
         throw error_already_set();
     }
 
     rv = PyDict_GetItemWithError(v, kv);
     Py_DECREF(kv);
-    if (rv == NULL && PyErr_Occurred()) {
+    if (rv == nullptr && PyErr_Occurred()) {
         throw error_already_set();
     }
     return rv;
-#else
-    return PyDict_GetItemString(v, key);
-#endif
 }
 
 inline PyObject *dict_getitem(PyObject *v, PyObject *key) {
-#if PY_MAJOR_VERSION >= 3
     PyObject *rv = PyDict_GetItemWithError(v, key);
-    if (rv == NULL && PyErr_Occurred()) {
+    if (rv == nullptr && PyErr_Occurred()) {
         throw error_already_set();
     }
     return rv;
-#else
-    return PyDict_GetItem(v, key);
-#endif
 }
 
 // Helper aliases/functions to support implicit casting of values given to python
 // accessors/methods. When given a pyobject, this simply returns the pyobject as-is; for other C++
 // type, the value goes through pybind11::cast(obj) to convert it to an `object`.
 template <typename T, enable_if_t<is_pyobject<T>::value, int> = 0>
 auto object_or_cast(T &&o) -> decltype(std::forward<T>(o)) {
@@ -647,18 +981,16 @@
 }
 // The following casting version is implemented in cast.h:
 template <typename T, enable_if_t<!is_pyobject<T>::value, int> = 0>
 object object_or_cast(T &&o);
 // Match a PyObject*, which we want to convert directly to handle via its converting constructor
 inline handle object_or_cast(PyObject *ptr) { return ptr; }
 
-#if defined(_MSC_VER) && _MSC_VER < 1920
-#    pragma warning(push)
-#    pragma warning(disable : 4522) // warning C4522: multiple assignment operators specified
-#endif
+PYBIND11_WARNING_PUSH
+PYBIND11_WARNING_DISABLE_MSVC(4522) // warning C4522: multiple assignment operators specified
 template <typename Policy>
 class accessor : public object_api<accessor<Policy>> {
     using key_type = typename Policy::key_type;
 
 public:
     accessor(handle obj, key_type key) : obj(obj), key(std::move(key)) {}
     accessor(const accessor &) = default;
@@ -671,15 +1003,15 @@
 
     template <typename T>
     void operator=(T &&value) && {
         Policy::set(obj, key, object_or_cast(std::forward<T>(value)));
     }
     template <typename T>
     void operator=(T &&value) & {
-        get_cache() = reinterpret_borrow<object>(object_or_cast(std::forward<T>(value)));
+        get_cache() = ensure_object(object_or_cast(std::forward<T>(value)));
     }
 
     template <typename T = Policy>
     PYBIND11_DEPRECATED(
         "Use of obj.attr(...) as bool is deprecated in favor of pybind11::hasattr(obj, ...)")
     explicit
     operator enable_if_t<std::is_same<T, accessor_policies::str_attr>::value
@@ -699,29 +1031,30 @@
     PyObject *ptr() const { return get_cache().ptr(); }
     template <typename T>
     T cast() const {
         return get_cache().template cast<T>();
     }
 
 private:
+    static object ensure_object(object &&o) { return std::move(o); }
+    static object ensure_object(handle h) { return reinterpret_borrow<object>(h); }
+
     object &get_cache() const {
         if (!cache) {
             cache = Policy::get(obj, key);
         }
         return cache;
     }
 
 private:
     handle obj;
     key_type key;
     mutable object cache;
 };
-#if defined(_MSC_VER) && _MSC_VER < 1920
-#    pragma warning(pop)
-#endif
+PYBIND11_WARNING_POP
 
 PYBIND11_NAMESPACE_BEGIN(accessor_policies)
 struct obj_attr {
     using key_type = object;
     static object get(handle obj, handle key) { return getattr(obj, key); }
     static void set(handle obj, handle key, handle val) { setattr(obj, key, val); }
 };
@@ -1049,25 +1382,25 @@
 #define PYBIND11_OBJECT_CVT(Name, Parent, CheckFun, ConvertFun)                                   \
     PYBIND11_OBJECT_COMMON(Name, Parent, CheckFun)                                                \
     /* This is deliberately not 'explicit' to allow implicit conversion from object: */           \
     /* NOLINTNEXTLINE(google-explicit-constructor) */                                             \
     Name(const object &o)                                                                         \
         : Parent(check_(o) ? o.inc_ref().ptr() : ConvertFun(o.ptr()), stolen_t{}) {               \
         if (!m_ptr)                                                                               \
-            throw error_already_set();                                                            \
+            throw ::pybind11::error_already_set();                                                \
     }                                                                                             \
     /* NOLINTNEXTLINE(google-explicit-constructor) */                                             \
     Name(object &&o) : Parent(check_(o) ? o.release().ptr() : ConvertFun(o.ptr()), stolen_t{}) {  \
         if (!m_ptr)                                                                               \
-            throw error_already_set();                                                            \
+            throw ::pybind11::error_already_set();                                                \
     }
 
 #define PYBIND11_OBJECT_CVT_DEFAULT(Name, Parent, CheckFun, ConvertFun)                           \
     PYBIND11_OBJECT_CVT(Name, Parent, CheckFun, ConvertFun)                                       \
-    Name() : Parent() {}
+    Name() = default;
 
 #define PYBIND11_OBJECT_CHECK_FAILED(Name, o_ptr)                                                 \
     ::pybind11::type_error("Object of type '"                                                     \
                            + ::pybind11::detail::get_fully_qualified_tp_name(Py_TYPE(o_ptr))      \
                            + "' is not an instance of '" #Name "'")
 
 #define PYBIND11_OBJECT(Name, Parent, CheckFun)                                                   \
@@ -1082,15 +1415,15 @@
     Name(object &&o) : Parent(std::move(o)) {                                                     \
         if (m_ptr && !check_(m_ptr))                                                              \
             throw PYBIND11_OBJECT_CHECK_FAILED(Name, m_ptr);                                      \
     }
 
 #define PYBIND11_OBJECT_DEFAULT(Name, Parent, CheckFun)                                           \
     PYBIND11_OBJECT(Name, Parent, CheckFun)                                                       \
-    Name() : Parent() {}
+    Name() = default;
 
 /// \addtogroup pytypes
 /// @{
 
 /** \rst
     Wraps a Python iterator so that it can also be used as a C++ input iterator
 
@@ -1151,15 +1484,15 @@
 
     friend bool operator==(const iterator &a, const iterator &b) { return a->ptr() == b->ptr(); }
     friend bool operator!=(const iterator &a, const iterator &b) { return a->ptr() != b->ptr(); }
 
 private:
     void advance() {
         value = reinterpret_steal<object>(PyIter_Next(m_ptr));
-        if (PyErr_Occurred()) {
+        if (value.ptr() == nullptr && PyErr_Occurred()) {
             throw error_already_set();
         }
     }
 
 private:
     object value = {};
 };
@@ -1201,23 +1534,29 @@
 public:
     PYBIND11_OBJECT_CVT(str, object, PYBIND11_STR_CHECK_FUN, raw_str)
 
     template <typename SzType, detail::enable_if_t<std::is_integral<SzType>::value, int> = 0>
     str(const char *c, const SzType &n)
         : object(PyUnicode_FromStringAndSize(c, ssize_t_cast(n)), stolen_t{}) {
         if (!m_ptr) {
+            if (PyErr_Occurred()) {
+                throw error_already_set();
+            }
             pybind11_fail("Could not allocate string object!");
         }
     }
 
     // 'explicit' is explicitly omitted from the following constructors to allow implicit
     // conversion to py::str from C++ string-like objects
     // NOLINTNEXTLINE(google-explicit-constructor)
     str(const char *c = "") : object(PyUnicode_FromString(c), stolen_t{}) {
         if (!m_ptr) {
+            if (PyErr_Occurred()) {
+                throw error_already_set();
+            }
             pybind11_fail("Could not allocate string object!");
         }
     }
 
     // NOLINTNEXTLINE(google-explicit-constructor)
     str(const std::string &s) : str(s.data(), s.size()) {}
 
@@ -1254,46 +1593,47 @@
             temp = reinterpret_steal<object>(PyUnicode_AsUTF8String(m_ptr));
             if (!temp) {
                 throw error_already_set();
             }
         }
         char *buffer = nullptr;
         ssize_t length = 0;
-        if (PYBIND11_BYTES_AS_STRING_AND_SIZE(temp.ptr(), &buffer, &length)) {
-            pybind11_fail("Unable to extract string contents! (invalid type)");
+        if (PyBytes_AsStringAndSize(temp.ptr(), &buffer, &length) != 0) {
+            throw error_already_set();
         }
         return std::string(buffer, (size_t) length);
     }
 
     template <typename... Args>
     str format(Args &&...args) const {
         return attr("format")(std::forward<Args>(args)...);
     }
 
 private:
     /// Return string representation -- always returns a new reference, even if already a str
     static PyObject *raw_str(PyObject *op) {
         PyObject *str_value = PyObject_Str(op);
-#if PY_MAJOR_VERSION < 3
-        if (!str_value)
-            throw error_already_set();
-        PyObject *unicode = PyUnicode_FromEncodedObject(str_value, "utf-8", nullptr);
-        Py_XDECREF(str_value);
-        str_value = unicode;
-#endif
         return str_value;
     }
 };
 /// @} pytypes
 
 inline namespace literals {
 /** \rst
     String literal version of `str`
  \endrst */
-inline str operator"" _s(const char *s, size_t size) { return {s, size}; }
+inline str
+#if !defined(__clang__) && defined(__GNUC__) && __GNUC__ < 5
+operator"" _s // gcc 4.8.5 insists on having a space (hard error).
+#else
+operator""_s // clang 17 generates a deprecation warning if there is a space.
+#endif
+    (const char *s, size_t size) {
+    return {s, size};
+}
 } // namespace literals
 
 /// \addtogroup pytypes
 /// @{
 class bytes : public object {
 public:
     PYBIND11_OBJECT(bytes, object, PYBIND11_BYTES_CHECK)
@@ -1317,75 +1657,74 @@
     // Allow implicit conversion:
     // NOLINTNEXTLINE(google-explicit-constructor)
     bytes(const std::string &s) : bytes(s.data(), s.size()) {}
 
     explicit bytes(const pybind11::str &s);
 
     // NOLINTNEXTLINE(google-explicit-constructor)
-    operator std::string() const {
-        char *buffer = nullptr;
-        ssize_t length = 0;
-        if (PYBIND11_BYTES_AS_STRING_AND_SIZE(m_ptr, &buffer, &length)) {
-            pybind11_fail("Unable to extract bytes contents!");
-        }
-        return std::string(buffer, (size_t) length);
-    }
+    operator std::string() const { return string_op<std::string>(); }
 
 #ifdef PYBIND11_HAS_STRING_VIEW
     // enable_if is needed to avoid "ambiguous conversion" errors (see PR #3521).
     template <typename T, detail::enable_if_t<std::is_same<T, std::string_view>::value, int> = 0>
     // NOLINTNEXTLINE(google-explicit-constructor)
     bytes(T s) : bytes(s.data(), s.size()) {}
 
     // Obtain a string view that views the current `bytes` buffer value.  Note that this is only
     // valid so long as the `bytes` instance remains alive and so generally should not outlive the
     // lifetime of the `bytes` instance.
     // NOLINTNEXTLINE(google-explicit-constructor)
-    operator std::string_view() const {
+    operator std::string_view() const { return string_op<std::string_view>(); }
+#endif
+private:
+    template <typename T>
+    T string_op() const {
         char *buffer = nullptr;
         ssize_t length = 0;
-        if (PYBIND11_BYTES_AS_STRING_AND_SIZE(m_ptr, &buffer, &length)) {
-            pybind11_fail("Unable to extract bytes contents!");
+        if (PyBytes_AsStringAndSize(m_ptr, &buffer, &length) != 0) {
+            throw error_already_set();
         }
         return {buffer, static_cast<size_t>(length)};
     }
-#endif
 };
 // Note: breathe >= 4.17.0 will fail to build docs if the below two constructors
 // are included in the doxygen group; close here and reopen after as a workaround
 /// @} pytypes
 
 inline bytes::bytes(const pybind11::str &s) {
     object temp = s;
     if (PyUnicode_Check(s.ptr())) {
         temp = reinterpret_steal<object>(PyUnicode_AsUTF8String(s.ptr()));
         if (!temp) {
-            pybind11_fail("Unable to extract string contents! (encoding issue)");
+            throw error_already_set();
         }
     }
     char *buffer = nullptr;
     ssize_t length = 0;
-    if (PYBIND11_BYTES_AS_STRING_AND_SIZE(temp.ptr(), &buffer, &length)) {
-        pybind11_fail("Unable to extract string contents! (invalid type)");
+    if (PyBytes_AsStringAndSize(temp.ptr(), &buffer, &length) != 0) {
+        throw error_already_set();
     }
     auto obj = reinterpret_steal<object>(PYBIND11_BYTES_FROM_STRING_AND_SIZE(buffer, length));
     if (!obj) {
         pybind11_fail("Could not allocate bytes object!");
     }
     m_ptr = obj.release().ptr();
 }
 
 inline str::str(const bytes &b) {
     char *buffer = nullptr;
     ssize_t length = 0;
-    if (PYBIND11_BYTES_AS_STRING_AND_SIZE(b.ptr(), &buffer, &length)) {
-        pybind11_fail("Unable to extract bytes contents!");
+    if (PyBytes_AsStringAndSize(b.ptr(), &buffer, &length) != 0) {
+        throw error_already_set();
     }
     auto obj = reinterpret_steal<object>(PyUnicode_FromStringAndSize(buffer, length));
     if (!obj) {
+        if (PyErr_Occurred()) {
+            throw error_already_set();
+        }
         pybind11_fail("Could not allocate string object!");
     }
     m_ptr = obj.release().ptr();
 }
 
 /// \addtogroup pytypes
 /// @{
@@ -1455,19 +1794,15 @@
 PYBIND11_NAMESPACE_BEGIN(detail)
 // Converts a value to the given unsigned type.  If an error occurs, you get back (Unsigned) -1;
 // otherwise you get back the unsigned long or unsigned long long value cast to (Unsigned).
 // (The distinction is critically important when casting a returned -1 error value to some other
 // unsigned type: (A)-1 != (B)-1 when A and B are unsigned types of different sizes).
 template <typename Unsigned>
 Unsigned as_unsigned(PyObject *o) {
-    if (PYBIND11_SILENCE_MSVC_C4127(sizeof(Unsigned) <= sizeof(unsigned long))
-#if PY_VERSION_HEX < 0x03000000
-        || PyInt_Check(o)
-#endif
-    ) {
+    if (sizeof(Unsigned) <= sizeof(unsigned long)) {
         unsigned long v = PyLong_AsUnsignedLong(o);
         return v == (unsigned long) -1 && PyErr_Occurred() ? (Unsigned) -1 : (Unsigned) v;
     }
     unsigned long long v = PyLong_AsUnsignedLongLong(o);
     return v == (unsigned long long) -1 && PyErr_Occurred() ? (Unsigned) -1 : (Unsigned) v;
 }
 PYBIND11_NAMESPACE_END(detail)
@@ -1476,15 +1811,15 @@
 public:
     PYBIND11_OBJECT_CVT(int_, object, PYBIND11_LONG_CHECK, PyNumber_Long)
     int_() : object(PyLong_FromLong(0), stolen_t{}) {}
     // Allow implicit conversion from C++ integral types:
     template <typename T, detail::enable_if_t<std::is_integral<T>::value, int> = 0>
     // NOLINTNEXTLINE(google-explicit-constructor)
     int_(T value) {
-        if (PYBIND11_SILENCE_MSVC_C4127(sizeof(T) <= sizeof(long))) {
+        if (sizeof(T) <= sizeof(long)) {
             if (std::is_signed<T>::value) {
                 m_ptr = PyLong_FromLong((long) value);
             } else {
                 m_ptr = PyLong_FromUnsignedLong((unsigned long) value);
             }
         } else {
             if (std::is_signed<T>::value) {
@@ -1531,27 +1866,30 @@
 
 class weakref : public object {
 public:
     PYBIND11_OBJECT_CVT_DEFAULT(weakref, object, PyWeakref_Check, raw_weakref)
     explicit weakref(handle obj, handle callback = {})
         : object(PyWeakref_NewRef(obj.ptr(), callback.ptr()), stolen_t{}) {
         if (!m_ptr) {
+            if (PyErr_Occurred()) {
+                throw error_already_set();
+            }
             pybind11_fail("Could not allocate weak reference!");
         }
     }
 
 private:
     static PyObject *raw_weakref(PyObject *o) { return PyWeakref_NewRef(o, nullptr); }
 };
 
 class slice : public object {
 public:
     PYBIND11_OBJECT_DEFAULT(slice, object, PySlice_Check)
-    slice(handle start, handle stop, handle step) {
-        m_ptr = PySlice_New(start.ptr(), stop.ptr(), step.ptr());
+    slice(handle start, handle stop, handle step)
+        : object(PySlice_New(start.ptr(), stop.ptr(), step.ptr()), stolen_t{}) {
         if (!m_ptr) {
             pybind11_fail("Could not allocate slice object!");
         }
     }
 
 #ifdef PYBIND11_HAS_OPTIONAL
     slice(std::optional<ssize_t> start, std::optional<ssize_t> stop, std::optional<ssize_t> step)
@@ -1590,82 +1928,129 @@
     PYBIND11_OBJECT_DEFAULT(capsule, object, PyCapsule_CheckExact)
     PYBIND11_DEPRECATED("Use reinterpret_borrow<capsule>() or reinterpret_steal<capsule>()")
     capsule(PyObject *ptr, bool is_borrowed)
         : object(is_borrowed ? object(ptr, borrowed_t{}) : object(ptr, stolen_t{})) {}
 
     explicit capsule(const void *value,
                      const char *name = nullptr,
-                     void (*destructor)(PyObject *) = nullptr)
+                     PyCapsule_Destructor destructor = nullptr)
         : object(PyCapsule_New(const_cast<void *>(value), name, destructor), stolen_t{}) {
         if (!m_ptr) {
-            pybind11_fail("Could not allocate capsule object!");
+            throw error_already_set();
         }
     }
 
-    PYBIND11_DEPRECATED("Please pass a destructor that takes a void pointer as input")
-    capsule(const void *value, void (*destruct)(PyObject *))
-        : object(PyCapsule_New(const_cast<void *>(value), nullptr, destruct), stolen_t{}) {
+    PYBIND11_DEPRECATED("Please use the ctor with value, name, destructor args")
+    capsule(const void *value, PyCapsule_Destructor destructor)
+        : object(PyCapsule_New(const_cast<void *>(value), nullptr, destructor), stolen_t{}) {
         if (!m_ptr) {
-            pybind11_fail("Could not allocate capsule object!");
+            throw error_already_set();
         }
     }
 
+    /// Capsule name is nullptr.
     capsule(const void *value, void (*destructor)(void *)) {
-        m_ptr = PyCapsule_New(const_cast<void *>(value), nullptr, [](PyObject *o) {
-            auto destructor = reinterpret_cast<void (*)(void *)>(PyCapsule_GetContext(o));
-            void *ptr = PyCapsule_GetPointer(o, nullptr);
-            destructor(ptr);
-        });
-
-        if (!m_ptr) {
-            pybind11_fail("Could not allocate capsule object!");
-        }
+        initialize_with_void_ptr_destructor(value, nullptr, destructor);
+    }
 
-        if (PyCapsule_SetContext(m_ptr, (void *) destructor) != 0) {
-            pybind11_fail("Could not set capsule context!");
-        }
+    capsule(const void *value, const char *name, void (*destructor)(void *)) {
+        initialize_with_void_ptr_destructor(value, name, destructor);
     }
 
     explicit capsule(void (*destructor)()) {
         m_ptr = PyCapsule_New(reinterpret_cast<void *>(destructor), nullptr, [](PyObject *o) {
-            auto destructor = reinterpret_cast<void (*)()>(PyCapsule_GetPointer(o, nullptr));
+            const char *name = get_name_in_error_scope(o);
+            auto destructor = reinterpret_cast<void (*)()>(PyCapsule_GetPointer(o, name));
+            if (destructor == nullptr) {
+                throw error_already_set();
+            }
             destructor();
         });
 
         if (!m_ptr) {
-            pybind11_fail("Could not allocate capsule object!");
+            throw error_already_set();
         }
     }
 
     template <typename T>
     operator T *() const { // NOLINT(google-explicit-constructor)
         return get_pointer<T>();
     }
 
     /// Get the pointer the capsule holds.
     template <typename T = void>
     T *get_pointer() const {
         const auto *name = this->name();
         T *result = static_cast<T *>(PyCapsule_GetPointer(m_ptr, name));
         if (!result) {
-            PyErr_Clear();
-            pybind11_fail("Unable to extract capsule contents!");
+            throw error_already_set();
         }
         return result;
     }
 
     /// Replaces a capsule's pointer *without* calling the destructor on the existing one.
     void set_pointer(const void *value) {
         if (PyCapsule_SetPointer(m_ptr, const_cast<void *>(value)) != 0) {
-            PyErr_Clear();
-            pybind11_fail("Could not set capsule pointer");
+            throw error_already_set();
         }
     }
 
-    const char *name() const { return PyCapsule_GetName(m_ptr); }
+    const char *name() const {
+        const char *name = PyCapsule_GetName(m_ptr);
+        if ((name == nullptr) && PyErr_Occurred()) {
+            throw error_already_set();
+        }
+        return name;
+    }
+
+    /// Replaces a capsule's name *without* calling the destructor on the existing one.
+    void set_name(const char *new_name) {
+        if (PyCapsule_SetName(m_ptr, new_name) != 0) {
+            throw error_already_set();
+        }
+    }
+
+private:
+    static const char *get_name_in_error_scope(PyObject *o) {
+        error_scope error_guard;
+
+        const char *name = PyCapsule_GetName(o);
+        if ((name == nullptr) && PyErr_Occurred()) {
+            // write out and consume error raised by call to PyCapsule_GetName
+            PyErr_WriteUnraisable(o);
+        }
+
+        return name;
+    }
+
+    void initialize_with_void_ptr_destructor(const void *value,
+                                             const char *name,
+                                             void (*destructor)(void *)) {
+        m_ptr = PyCapsule_New(const_cast<void *>(value), name, [](PyObject *o) {
+            // guard if destructor called while err indicator is set
+            error_scope error_guard;
+            auto destructor = reinterpret_cast<void (*)(void *)>(PyCapsule_GetContext(o));
+            if (destructor == nullptr && PyErr_Occurred()) {
+                throw error_already_set();
+            }
+            const char *name = get_name_in_error_scope(o);
+            void *ptr = PyCapsule_GetPointer(o, name);
+            if (ptr == nullptr) {
+                throw error_already_set();
+            }
+
+            if (destructor != nullptr) {
+                destructor(ptr);
+            }
+        });
+
+        if (!m_ptr || PyCapsule_SetContext(m_ptr, reinterpret_cast<void *>(destructor)) != 0) {
+            throw error_already_set();
+        }
+    }
 };
 
 class tuple : public object {
 public:
     PYBIND11_OBJECT_CVT(tuple, object, PyTuple_Check, PySequence_Tuple)
     template <typename SzType = ssize_t,
               detail::enable_if_t<std::is_integral<SzType>::value, int> = 0>
@@ -1674,15 +2059,18 @@
         if (!m_ptr) {
             pybind11_fail("Could not allocate tuple object!");
         }
     }
     size_t size() const { return (size_t) PyTuple_Size(m_ptr); }
     bool empty() const { return size() == 0; }
     detail::tuple_accessor operator[](size_t index) const { return {*this, index}; }
-    detail::item_accessor operator[](handle h) const { return object::operator[](h); }
+    template <typename T, detail::enable_if_t<detail::is_pyobject<T>::value, int> = 0>
+    detail::item_accessor operator[](T &&o) const {
+        return object::operator[](std::forward<T>(o));
+    }
     detail::tuple_iterator begin() const { return {*this, 0}; }
     detail::tuple_iterator end() const { return {*this, PyTuple_GET_SIZE(m_ptr)}; }
 };
 
 // We need to put this into a separate function because the Intel compiler
 // fails to compile enable_if_t<all_of<is_keyword_or_ds<Args>...>::value> part below
 // (tested with ICC 2021.1 Beta 20200827).
@@ -1709,15 +2097,19 @@
     size_t size() const { return (size_t) PyDict_Size(m_ptr); }
     bool empty() const { return size() == 0; }
     detail::dict_iterator begin() const { return {*this, 0}; }
     detail::dict_iterator end() const { return {}; }
     void clear() /* py-non-const */ { PyDict_Clear(ptr()); }
     template <typename T>
     bool contains(T &&key) const {
-        return PyDict_Contains(m_ptr, detail::object_or_cast(std::forward<T>(key)).ptr()) == 1;
+        auto result = PyDict_Contains(m_ptr, detail::object_or_cast(std::forward<T>(key)).ptr());
+        if (result == -1) {
+            throw error_already_set();
+        }
+        return result == 1;
     }
 
 private:
     /// Call the `dict` Python type -- always returns a new reference
     static PyObject *raw_dict(PyObject *op) {
         if (PyDict_Check(op)) {
             return handle(op).inc_ref().ptr();
@@ -1734,15 +2126,18 @@
         if (result == -1) {
             throw error_already_set();
         }
         return (size_t) result;
     }
     bool empty() const { return size() == 0; }
     detail::sequence_accessor operator[](size_t index) const { return {*this, index}; }
-    detail::item_accessor operator[](handle h) const { return object::operator[](h); }
+    template <typename T, detail::enable_if_t<detail::is_pyobject<T>::value, int> = 0>
+    detail::item_accessor operator[](T &&o) const {
+        return object::operator[](std::forward<T>(o));
+    }
     detail::sequence_iterator begin() const { return {*this, 0}; }
     detail::sequence_iterator end() const { return {*this, PySequence_Size(m_ptr)}; }
 };
 
 class list : public object {
 public:
     PYBIND11_OBJECT_CVT(list, object, PyList_Check, PySequence_List)
@@ -1753,56 +2148,79 @@
         if (!m_ptr) {
             pybind11_fail("Could not allocate list object!");
         }
     }
     size_t size() const { return (size_t) PyList_Size(m_ptr); }
     bool empty() const { return size() == 0; }
     detail::list_accessor operator[](size_t index) const { return {*this, index}; }
-    detail::item_accessor operator[](handle h) const { return object::operator[](h); }
+    template <typename T, detail::enable_if_t<detail::is_pyobject<T>::value, int> = 0>
+    detail::item_accessor operator[](T &&o) const {
+        return object::operator[](std::forward<T>(o));
+    }
     detail::list_iterator begin() const { return {*this, 0}; }
     detail::list_iterator end() const { return {*this, PyList_GET_SIZE(m_ptr)}; }
     template <typename T>
     void append(T &&val) /* py-non-const */ {
-        PyList_Append(m_ptr, detail::object_or_cast(std::forward<T>(val)).ptr());
+        if (PyList_Append(m_ptr, detail::object_or_cast(std::forward<T>(val)).ptr()) != 0) {
+            throw error_already_set();
+        }
     }
     template <typename IdxType,
               typename ValType,
               detail::enable_if_t<std::is_integral<IdxType>::value, int> = 0>
     void insert(const IdxType &index, ValType &&val) /* py-non-const */ {
-        PyList_Insert(
-            m_ptr, ssize_t_cast(index), detail::object_or_cast(std::forward<ValType>(val)).ptr());
+        if (PyList_Insert(m_ptr,
+                          ssize_t_cast(index),
+                          detail::object_or_cast(std::forward<ValType>(val)).ptr())
+            != 0) {
+            throw error_already_set();
+        }
     }
 };
 
 class args : public tuple {
     PYBIND11_OBJECT_DEFAULT(args, tuple, PyTuple_Check)
 };
 class kwargs : public dict {
     PYBIND11_OBJECT_DEFAULT(kwargs, dict, PyDict_Check)
 };
 
-class set : public object {
+class anyset : public object {
+public:
+    PYBIND11_OBJECT(anyset, object, PyAnySet_Check)
+    size_t size() const { return static_cast<size_t>(PySet_Size(m_ptr)); }
+    bool empty() const { return size() == 0; }
+    template <typename T>
+    bool contains(T &&val) const {
+        auto result = PySet_Contains(m_ptr, detail::object_or_cast(std::forward<T>(val)).ptr());
+        if (result == -1) {
+            throw error_already_set();
+        }
+        return result == 1;
+    }
+};
+
+class set : public anyset {
 public:
-    PYBIND11_OBJECT_CVT(set, object, PySet_Check, PySet_New)
-    set() : object(PySet_New(nullptr), stolen_t{}) {
+    PYBIND11_OBJECT_CVT(set, anyset, PySet_Check, PySet_New)
+    set() : anyset(PySet_New(nullptr), stolen_t{}) {
         if (!m_ptr) {
             pybind11_fail("Could not allocate set object!");
         }
     }
-    size_t size() const { return (size_t) PySet_Size(m_ptr); }
-    bool empty() const { return size() == 0; }
     template <typename T>
     bool add(T &&val) /* py-non-const */ {
         return PySet_Add(m_ptr, detail::object_or_cast(std::forward<T>(val)).ptr()) == 0;
     }
     void clear() /* py-non-const */ { PySet_Clear(m_ptr); }
-    template <typename T>
-    bool contains(T &&val) const {
-        return PySet_Contains(m_ptr, detail::object_or_cast(std::forward<T>(val)).ptr()) == 1;
-    }
+};
+
+class frozenset : public anyset {
+public:
+    PYBIND11_OBJECT_CVT(frozenset, anyset, PyFrozenSet_Check, PyFrozenSet_New)
 };
 
 class function : public object {
 public:
     PYBIND11_OBJECT_DEFAULT(function, object, PyCallable_Check)
     handle cpp_function() const {
         handle fun = detail::get_function(m_ptr);
@@ -1906,36 +2324,34 @@
     static memoryview from_buffer(T *ptr,
                                   detail::any_container<ssize_t> shape,
                                   detail::any_container<ssize_t> strides,
                                   bool readonly = false) {
         return memoryview::from_buffer(reinterpret_cast<void *>(ptr),
                                        sizeof(T),
                                        format_descriptor<T>::value,
-                                       shape,
-                                       strides,
+                                       std::move(shape),
+                                       std::move(strides),
                                        readonly);
     }
 
     template <typename T>
     static memoryview from_buffer(const T *ptr,
                                   detail::any_container<ssize_t> shape,
                                   detail::any_container<ssize_t> strides) {
-        return memoryview::from_buffer(const_cast<T *>(ptr), shape, strides, true);
+        return memoryview::from_buffer(
+            const_cast<T *>(ptr), std::move(shape), std::move(strides), true);
     }
 
-#if PY_MAJOR_VERSION >= 3
     /** \rst
         Creates ``memoryview`` from static memory.
 
         This method is meant for providing a ``memoryview`` for C/C++ buffer not
         managed by Python. The caller is responsible for managing the lifetime
         of ``mem``, which MUST outlive the memoryview constructed here.
 
-        This method is not available in Python 2.
-
         See also: Python C API documentation for `PyMemoryView_FromBuffer`_.
 
         .. _PyMemoryView_FromMemory:
            https://docs.python.org/c-api/memoryview.html#c.PyMemoryView_FromMemory
      \endrst */
     static memoryview from_memory(void *mem, ssize_t size, bool readonly = false) {
         PyObject *ptr = PyMemoryView_FromMemory(
@@ -1946,20 +2362,18 @@
         return memoryview(object(ptr, stolen_t{}));
     }
 
     static memoryview from_memory(const void *mem, ssize_t size) {
         return memoryview::from_memory(const_cast<void *>(mem), size, true);
     }
 
-#    ifdef PYBIND11_HAS_STRING_VIEW
+#ifdef PYBIND11_HAS_STRING_VIEW
     static memoryview from_memory(std::string_view mem) {
         return from_memory(const_cast<char *>(mem.data()), static_cast<ssize_t>(mem.size()), true);
     }
-#    endif
-
 #endif
 };
 
 /// @cond DUPLICATE
 inline memoryview memoryview::from_buffer(void *ptr,
                                           ssize_t itemsize,
                                           const char *format,
@@ -2006,40 +2420,29 @@
     }
     return (size_t) result;
 }
 
 /// Get the length hint of a Python object.
 /// Returns 0 when this cannot be determined.
 inline size_t len_hint(handle h) {
-#if PY_VERSION_HEX >= 0x03040000
     ssize_t result = PyObject_LengthHint(h.ptr(), 0);
-#else
-    ssize_t result = PyObject_Length(h.ptr());
-#endif
     if (result < 0) {
         // Sometimes a length can't be determined at all (eg generators)
         // In which case simply return 0
         PyErr_Clear();
         return 0;
     }
     return (size_t) result;
 }
 
 inline str repr(handle h) {
     PyObject *str_value = PyObject_Repr(h.ptr());
     if (!str_value) {
         throw error_already_set();
     }
-#if PY_MAJOR_VERSION < 3
-    PyObject *unicode = PyUnicode_FromEncodedObject(str_value, "utf-8", nullptr);
-    Py_XDECREF(str_value);
-    str_value = unicode;
-    if (!str_value)
-        throw error_already_set();
-#endif
     return reinterpret_steal<str>(str_value);
 }
 
 inline iterator iter(handle obj) {
     PyObject *result = PyObject_GetIter(obj.ptr());
     if (!result) {
         throw error_already_set();
@@ -2058,22 +2461,30 @@
     return iterator::sentinel();
 }
 template <typename D>
 item_accessor object_api<D>::operator[](handle key) const {
     return {derived(), reinterpret_borrow<object>(key)};
 }
 template <typename D>
+item_accessor object_api<D>::operator[](object &&key) const {
+    return {derived(), std::move(key)};
+}
+template <typename D>
 item_accessor object_api<D>::operator[](const char *key) const {
     return {derived(), pybind11::str(key)};
 }
 template <typename D>
 obj_attr_accessor object_api<D>::attr(handle key) const {
     return {derived(), reinterpret_borrow<object>(key)};
 }
 template <typename D>
+obj_attr_accessor object_api<D>::attr(object &&key) const {
+    return {derived(), std::move(key)};
+}
+template <typename D>
 str_attr_accessor object_api<D>::attr(const char *key) const {
     return {derived(), key};
 }
 template <typename D>
 args_proxy object_api<D>::operator*() const {
     return args_proxy(derived().ptr());
 }
@@ -2121,33 +2532,43 @@
     object object_api<D>::op(object_api const &other) const {                                     \
         object result = reinterpret_steal<object>(fn(derived().ptr(), other.derived().ptr()));    \
         if (!result.ptr())                                                                        \
             throw error_already_set();                                                            \
         return result;                                                                            \
     }
 
+#define PYBIND11_MATH_OPERATOR_BINARY_INPLACE(iop, fn)                                            \
+    template <typename D>                                                                         \
+    object object_api<D>::iop(object_api const &other) {                                          \
+        object result = reinterpret_steal<object>(fn(derived().ptr(), other.derived().ptr()));    \
+        if (!result.ptr())                                                                        \
+            throw error_already_set();                                                            \
+        return result;                                                                            \
+    }
+
 PYBIND11_MATH_OPERATOR_UNARY(operator~, PyNumber_Invert)
 PYBIND11_MATH_OPERATOR_UNARY(operator-, PyNumber_Negative)
 PYBIND11_MATH_OPERATOR_BINARY(operator+, PyNumber_Add)
-PYBIND11_MATH_OPERATOR_BINARY(operator+=, PyNumber_InPlaceAdd)
+PYBIND11_MATH_OPERATOR_BINARY_INPLACE(operator+=, PyNumber_InPlaceAdd)
 PYBIND11_MATH_OPERATOR_BINARY(operator-, PyNumber_Subtract)
-PYBIND11_MATH_OPERATOR_BINARY(operator-=, PyNumber_InPlaceSubtract)
+PYBIND11_MATH_OPERATOR_BINARY_INPLACE(operator-=, PyNumber_InPlaceSubtract)
 PYBIND11_MATH_OPERATOR_BINARY(operator*, PyNumber_Multiply)
-PYBIND11_MATH_OPERATOR_BINARY(operator*=, PyNumber_InPlaceMultiply)
+PYBIND11_MATH_OPERATOR_BINARY_INPLACE(operator*=, PyNumber_InPlaceMultiply)
 PYBIND11_MATH_OPERATOR_BINARY(operator/, PyNumber_TrueDivide)
-PYBIND11_MATH_OPERATOR_BINARY(operator/=, PyNumber_InPlaceTrueDivide)
+PYBIND11_MATH_OPERATOR_BINARY_INPLACE(operator/=, PyNumber_InPlaceTrueDivide)
 PYBIND11_MATH_OPERATOR_BINARY(operator|, PyNumber_Or)
-PYBIND11_MATH_OPERATOR_BINARY(operator|=, PyNumber_InPlaceOr)
+PYBIND11_MATH_OPERATOR_BINARY_INPLACE(operator|=, PyNumber_InPlaceOr)
 PYBIND11_MATH_OPERATOR_BINARY(operator&, PyNumber_And)
-PYBIND11_MATH_OPERATOR_BINARY(operator&=, PyNumber_InPlaceAnd)
+PYBIND11_MATH_OPERATOR_BINARY_INPLACE(operator&=, PyNumber_InPlaceAnd)
 PYBIND11_MATH_OPERATOR_BINARY(operator^, PyNumber_Xor)
-PYBIND11_MATH_OPERATOR_BINARY(operator^=, PyNumber_InPlaceXor)
+PYBIND11_MATH_OPERATOR_BINARY_INPLACE(operator^=, PyNumber_InPlaceXor)
 PYBIND11_MATH_OPERATOR_BINARY(operator<<, PyNumber_Lshift)
-PYBIND11_MATH_OPERATOR_BINARY(operator<<=, PyNumber_InPlaceLshift)
+PYBIND11_MATH_OPERATOR_BINARY_INPLACE(operator<<=, PyNumber_InPlaceLshift)
 PYBIND11_MATH_OPERATOR_BINARY(operator>>, PyNumber_Rshift)
-PYBIND11_MATH_OPERATOR_BINARY(operator>>=, PyNumber_InPlaceRshift)
+PYBIND11_MATH_OPERATOR_BINARY_INPLACE(operator>>=, PyNumber_InPlaceRshift)
 
 #undef PYBIND11_MATH_OPERATOR_UNARY
 #undef PYBIND11_MATH_OPERATOR_BINARY
+#undef PYBIND11_MATH_OPERATOR_BINARY_INPLACE
 
 PYBIND11_NAMESPACE_END(detail)
 PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
```

### Comparing `python_prtree-0.6.0/third/pybind11/include/pybind11/stl/filesystem.h` & `python_prtree-0.6.1/third/pybind11/include/pybind11/stl/filesystem.h`

 * *Files 10% similar despite different names*

```diff
@@ -9,30 +9,36 @@
 #include "../detail/descr.h"
 #include "../cast.h"
 #include "../pytypes.h"
 
 #include <string>
 
 #ifdef __has_include
-#    if defined(PYBIND11_CPP17) && __has_include(<filesystem>) && \
-      PY_VERSION_HEX >= 0x03060000
-#        include <filesystem>
-#        define PYBIND11_HAS_FILESYSTEM 1
+#    if defined(PYBIND11_CPP17)
+#        if __has_include(<filesystem>) && \
+          PY_VERSION_HEX >= 0x03060000
+#            include <filesystem>
+#            define PYBIND11_HAS_FILESYSTEM 1
+#        elif __has_include(<experimental/filesystem>)
+#            include <experimental/filesystem>
+#            define PYBIND11_HAS_EXPERIMENTAL_FILESYSTEM 1
+#        endif
 #    endif
 #endif
 
-#if !defined(PYBIND11_HAS_FILESYSTEM) && !defined(PYBIND11_HAS_FILESYSTEM_IS_OPTIONAL)
+#if !defined(PYBIND11_HAS_FILESYSTEM) && !defined(PYBIND11_HAS_EXPERIMENTAL_FILESYSTEM)           \
+    && !defined(PYBIND11_HAS_FILESYSTEM_IS_OPTIONAL)
 #    error                                                                                        \
-        "#include <filesystem> is not available. (Use -DPYBIND11_HAS_FILESYSTEM_IS_OPTIONAL to ignore.)"
+        "Neither #include <filesystem> nor #include <experimental/filesystem is available. (Use -DPYBIND11_HAS_FILESYSTEM_IS_OPTIONAL to ignore.)"
 #endif
 
 PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 PYBIND11_NAMESPACE_BEGIN(detail)
 
-#if defined(PYBIND11_HAS_FILESYSTEM)
+#if defined(PYBIND11_HAS_FILESYSTEM) || defined(PYBIND11_HAS_EXPERIMENTAL_FILESYSTEM)
 template <typename T>
 struct path_caster {
 
 private:
     static PyObject *unicode_from_fs_native(const std::string &w) {
 #    if !defined(PYPY_VERSION)
         return PyUnicode_DecodeFSDefaultAndSize(w.c_str(), ssize_t(w.size()));
@@ -91,13 +97,20 @@
         }
         return true;
     }
 
     PYBIND11_TYPE_CASTER(T, const_name("os.PathLike"));
 };
 
+#endif // PYBIND11_HAS_FILESYSTEM || defined(PYBIND11_HAS_EXPERIMENTAL_FILESYSTEM)
+
+#if defined(PYBIND11_HAS_FILESYSTEM)
 template <>
 struct type_caster<std::filesystem::path> : public path_caster<std::filesystem::path> {};
-#endif // PYBIND11_HAS_FILESYSTEM
+#elif defined(PYBIND11_HAS_EXPERIMENTAL_FILESYSTEM)
+template <>
+struct type_caster<std::experimental::filesystem::path>
+    : public path_caster<std::experimental::filesystem::path> {};
+#endif
 
 PYBIND11_NAMESPACE_END(detail)
 PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
```

### Comparing `python_prtree-0.6.0/third/pybind11/include/pybind11/stl.h` & `python_prtree-0.6.1/third/pybind11/include/pybind11/stl.h`

 * *Files 3% similar despite different names*

```diff
@@ -9,17 +9,17 @@
 
 #pragma once
 
 #include "pybind11.h"
 #include "detail/common.h"
 
 #include <deque>
-#include <iostream>
 #include <list>
 #include <map>
+#include <ostream>
 #include <set>
 #include <unordered_map>
 #include <unordered_set>
 #include <valarray>
 
 // See `detail/common.h` for implementation of these guards.
 #if defined(PYBIND11_HAS_OPTIONAL)
@@ -41,29 +41,43 @@
 using forwarded_type = conditional_t<std::is_lvalue_reference<T>::value,
                                      remove_reference_t<U> &,
                                      remove_reference_t<U> &&>;
 
 /// Forwards a value U as rvalue or lvalue according to whether T is rvalue or lvalue; typically
 /// used for forwarding a container's elements.
 template <typename T, typename U>
-forwarded_type<T, U> forward_like(U &&u) {
+constexpr forwarded_type<T, U> forward_like(U &&u) {
     return std::forward<detail::forwarded_type<T, U>>(std::forward<U>(u));
 }
 
+// Checks if a container has a STL style reserve method.
+// This will only return true for a `reserve()` with a `void` return.
+template <typename C>
+using has_reserve_method = std::is_same<decltype(std::declval<C>().reserve(0)), void>;
+
 template <typename Type, typename Key>
 struct set_caster {
     using type = Type;
     using key_conv = make_caster<Key>;
 
+private:
+    template <typename T = Type, enable_if_t<has_reserve_method<T>::value, int> = 0>
+    void reserve_maybe(const anyset &s, Type *) {
+        value.reserve(s.size());
+    }
+    void reserve_maybe(const anyset &, void *) {}
+
+public:
     bool load(handle src, bool convert) {
-        if (!isinstance<pybind11::set>(src)) {
+        if (!isinstance<anyset>(src)) {
             return false;
         }
-        auto s = reinterpret_borrow<pybind11::set>(src);
+        auto s = reinterpret_borrow<anyset>(src);
         value.clear();
+        reserve_maybe(s, &value);
         for (auto entry : s) {
             key_conv conv;
             if (!conv.load(entry, convert)) {
                 return false;
             }
             value.insert(cast_op<Key &&>(std::move(conv)));
         }
@@ -74,36 +88,45 @@
     static handle cast(T &&src, return_value_policy policy, handle parent) {
         if (!std::is_lvalue_reference<T>::value) {
             policy = return_value_policy_override<Key>::policy(policy);
         }
         pybind11::set s;
         for (auto &&value : src) {
             auto value_ = reinterpret_steal<object>(
-                key_conv::cast(forward_like<T>(value), policy, parent));
-            if (!value_ || !s.add(value_)) {
+                key_conv::cast(detail::forward_like<T>(value), policy, parent));
+            if (!value_ || !s.add(std::move(value_))) {
                 return handle();
             }
         }
         return s.release();
     }
 
-    PYBIND11_TYPE_CASTER(type, const_name("Set[") + key_conv::name + const_name("]"));
+    PYBIND11_TYPE_CASTER(type, const_name("set[") + key_conv::name + const_name("]"));
 };
 
 template <typename Type, typename Key, typename Value>
 struct map_caster {
     using key_conv = make_caster<Key>;
     using value_conv = make_caster<Value>;
 
+private:
+    template <typename T = Type, enable_if_t<has_reserve_method<T>::value, int> = 0>
+    void reserve_maybe(const dict &d, Type *) {
+        value.reserve(d.size());
+    }
+    void reserve_maybe(const dict &, void *) {}
+
+public:
     bool load(handle src, bool convert) {
         if (!isinstance<dict>(src)) {
             return false;
         }
         auto d = reinterpret_borrow<dict>(src);
         value.clear();
+        reserve_maybe(d, &value);
         for (auto it : d) {
             key_conv kconv;
             value_conv vconv;
             if (!kconv.load(it.first.ptr(), convert) || !vconv.load(it.second.ptr(), convert)) {
                 return false;
             }
             value.emplace(cast_op<Key &&>(std::move(kconv)), cast_op<Value &&>(std::move(vconv)));
@@ -118,55 +141,53 @@
         return_value_policy policy_value = policy;
         if (!std::is_lvalue_reference<T>::value) {
             policy_key = return_value_policy_override<Key>::policy(policy_key);
             policy_value = return_value_policy_override<Value>::policy(policy_value);
         }
         for (auto &&kv : src) {
             auto key = reinterpret_steal<object>(
-                key_conv::cast(forward_like<T>(kv.first), policy_key, parent));
+                key_conv::cast(detail::forward_like<T>(kv.first), policy_key, parent));
             auto value = reinterpret_steal<object>(
-                value_conv::cast(forward_like<T>(kv.second), policy_value, parent));
+                value_conv::cast(detail::forward_like<T>(kv.second), policy_value, parent));
             if (!key || !value) {
                 return handle();
             }
-            d[key] = value;
+            d[std::move(key)] = std::move(value);
         }
         return d.release();
     }
 
     PYBIND11_TYPE_CASTER(Type,
-                         const_name("Dict[") + key_conv::name + const_name(", ") + value_conv::name
+                         const_name("dict[") + key_conv::name + const_name(", ") + value_conv::name
                              + const_name("]"));
 };
 
 template <typename Type, typename Value>
 struct list_caster {
     using value_conv = make_caster<Value>;
 
     bool load(handle src, bool convert) {
         if (!isinstance<sequence>(src) || isinstance<bytes>(src) || isinstance<str>(src)) {
             return false;
         }
         auto s = reinterpret_borrow<sequence>(src);
         value.clear();
         reserve_maybe(s, &value);
-        for (auto it : s) {
+        for (const auto &it : s) {
             value_conv conv;
             if (!conv.load(it, convert)) {
                 return false;
             }
             value.push_back(cast_op<Value &&>(std::move(conv)));
         }
         return true;
     }
 
 private:
-    template <
-        typename T = Type,
-        enable_if_t<std::is_same<decltype(std::declval<T>().reserve(0)), void>::value, int> = 0>
+    template <typename T = Type, enable_if_t<has_reserve_method<T>::value, int> = 0>
     void reserve_maybe(const sequence &s, Type *) {
         value.reserve(s.size());
     }
     void reserve_maybe(const sequence &, void *) {}
 
 public:
     template <typename T>
@@ -174,24 +195,24 @@
         if (!std::is_lvalue_reference<T>::value) {
             policy = return_value_policy_override<Value>::policy(policy);
         }
         list l(src.size());
         ssize_t index = 0;
         for (auto &&value : src) {
             auto value_ = reinterpret_steal<object>(
-                value_conv::cast(forward_like<T>(value), policy, parent));
+                value_conv::cast(detail::forward_like<T>(value), policy, parent));
             if (!value_) {
                 return handle();
             }
             PyList_SET_ITEM(l.ptr(), index++, value_.release().ptr()); // steals a reference
         }
         return l.release();
     }
 
-    PYBIND11_TYPE_CASTER(Type, const_name("List[") + value_conv::name + const_name("]"));
+    PYBIND11_TYPE_CASTER(Type, const_name("list[") + value_conv::name + const_name("]"));
 };
 
 template <typename Type, typename Alloc>
 struct type_caster<std::vector<Type, Alloc>> : list_caster<std::vector<Type, Alloc>, Type> {};
 
 template <typename Type, typename Alloc>
 struct type_caster<std::deque<Type, Alloc>> : list_caster<std::deque<Type, Alloc>, Type> {};
@@ -222,15 +243,15 @@
             return false;
         }
         auto l = reinterpret_borrow<sequence>(src);
         if (!require_size(l.size())) {
             return false;
         }
         size_t ctr = 0;
-        for (auto it : l) {
+        for (const auto &it : l) {
             value_conv conv;
             if (!conv.load(it, convert)) {
                 return false;
             }
             value[ctr++] = cast_op<Value &&>(std::move(conv));
         }
         return true;
@@ -238,29 +259,29 @@
 
     template <typename T>
     static handle cast(T &&src, return_value_policy policy, handle parent) {
         list l(src.size());
         ssize_t index = 0;
         for (auto &&value : src) {
             auto value_ = reinterpret_steal<object>(
-                value_conv::cast(forward_like<T>(value), policy, parent));
+                value_conv::cast(detail::forward_like<T>(value), policy, parent));
             if (!value_) {
                 return handle();
             }
             PyList_SET_ITEM(l.ptr(), index++, value_.release().ptr()); // steals a reference
         }
         return l.release();
     }
 
     PYBIND11_TYPE_CASTER(ArrayType,
-                         const_name("List[") + value_conv::name
+                         const_name<Resizable>(const_name(""), const_name("Annotated["))
+                             + const_name("list[") + value_conv::name + const_name("]")
                              + const_name<Resizable>(const_name(""),
-                                                     const_name("[") + const_name<Size>()
-                                                         + const_name("]"))
-                             + const_name("]"));
+                                                     const_name(", FixedSize(")
+                                                         + const_name<Size>() + const_name(")]")));
 };
 
 template <typename Type, size_t Size>
 struct type_caster<std::array<Type, Size>>
     : array_caster<std::array<Type, Size>, Type, false, Size> {};
 
 template <typename Type>
@@ -286,19 +307,20 @@
 template <typename Type, typename Value = typename Type::value_type>
 struct optional_caster {
     using value_conv = make_caster<Value>;
 
     template <typename T>
     static handle cast(T &&src, return_value_policy policy, handle parent) {
         if (!src) {
-            return none().inc_ref();
+            return none().release();
         }
         if (!std::is_lvalue_reference<T>::value) {
             policy = return_value_policy_override<Value>::policy(policy);
         }
+        // NOLINTNEXTLINE(bugprone-unchecked-optional-access)
         return value_conv::cast(*std::forward<T>(src), policy, parent);
     }
 
     bool load(handle src, bool convert) {
         if (!src) {
             return false;
         }
@@ -368,15 +390,15 @@
 struct variant_caster<V<Ts...>> {
     static_assert(sizeof...(Ts) > 0, "Variant must consist of at least one alternative.");
 
     template <typename U, typename... Us>
     bool load_alternative(handle src, bool convert, type_list<U, Us...>) {
         auto caster = make_caster<U>();
         if (caster.load(src, convert)) {
-            value = cast_op<U>(caster);
+            value = cast_op<U>(std::move(caster));
             return true;
         }
         return load_alternative(src, convert, type_list<Us...>{});
     }
 
     bool load_alternative(handle, bool, type_list<>) { return false; }
 
@@ -395,21 +417,25 @@
     static handle cast(Variant &&src, return_value_policy policy, handle parent) {
         return visit_helper<V>::call(variant_caster_visitor{policy, parent},
                                      std::forward<Variant>(src));
     }
 
     using Type = V<Ts...>;
     PYBIND11_TYPE_CASTER(Type,
-                         const_name("Union[") + detail::concat(make_caster<Ts>::name...)
+                         const_name("Union[")
+                             + ::pybind11::detail::concat(make_caster<Ts>::name...)
                              + const_name("]"));
 };
 
 #if defined(PYBIND11_HAS_VARIANT)
 template <typename... Ts>
 struct type_caster<std::variant<Ts...>> : variant_caster<std::variant<Ts...>> {};
+
+template <>
+struct type_caster<std::monostate> : public void_caster<std::monostate> {};
 #endif
 
 PYBIND11_NAMESPACE_END(detail)
 
 inline std::ostream &operator<<(std::ostream &os, const handle &obj) {
 #ifdef PYBIND11_HAS_STRING_VIEW
     os << str(obj).cast<std::string_view>();
```

### Comparing `python_prtree-0.6.0/third/pybind11/include/pybind11/stl_bind.h` & `python_prtree-0.6.1/third/pybind11/include/pybind11/stl_bind.h`

 * *Files 6% similar despite different names*

```diff
@@ -6,18 +6,21 @@
     All rights reserved. Use of this source code is governed by a
     BSD-style license that can be found in the LICENSE file.
 */
 
 #pragma once
 
 #include "detail/common.h"
+#include "detail/type_caster_base.h"
+#include "cast.h"
 #include "operators.h"
 
 #include <algorithm>
 #include <sstream>
+#include <type_traits>
 
 PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 PYBIND11_NAMESPACE_BEGIN(detail)
 
 /* SFINAE helper class used by 'is_comparable */
 template <typename T>
 struct container_traits {
@@ -54,17 +57,19 @@
     T,
     enable_if_t<container_traits<T>::is_element && container_traits<T>::is_comparable>>
     : std::true_type {};
 
 /* For a vector/map data structure, recursively check the value type
    (which is std::pair for maps) */
 template <typename T>
-struct is_comparable<T, enable_if_t<container_traits<T>::is_vector>> {
-    static constexpr const bool value = is_comparable<typename T::value_type>::value;
-};
+struct is_comparable<T, enable_if_t<container_traits<T>::is_vector>>
+    : is_comparable<typename recursive_container_traits<T>::type_to_check_recursively> {};
+
+template <>
+struct is_comparable<recursive_bottom> : std::true_type {};
 
 /* For pairs, recursively check the two data types */
 template <typename T>
 struct is_comparable<T, enable_if_t<container_traits<T>::is_pair>> {
     static constexpr const bool value = is_comparable<typename T::first_type>::value
                                         && is_comparable<typename T::second_type>::value;
 };
@@ -228,15 +233,15 @@
         i = wrap_i(i, v.size());
         v[(SizeType) i] = t;
     });
 
     /// Slicing protocol
     cl.def(
         "__getitem__",
-        [](const Vector &v, slice slice) -> Vector * {
+        [](const Vector &v, const slice &slice) -> Vector * {
             size_t start = 0, stop = 0, step = 0, slicelength = 0;
 
             if (!slice.compute(v.size(), &start, &stop, &step, &slicelength)) {
                 throw error_already_set();
             }
 
             auto *seq = new Vector();
@@ -249,15 +254,15 @@
             return seq;
         },
         arg("s"),
         "Retrieve list elements using a slice object");
 
     cl.def(
         "__setitem__",
-        [](Vector &v, slice slice, const Vector &value) {
+        [](Vector &v, const slice &slice, const Vector &value) {
             size_t start = 0, stop = 0, step = 0, slicelength = 0;
             if (!slice.compute(v.size(), &start, &stop, &step, &slicelength)) {
                 throw error_already_set();
             }
 
             if (slicelength != value.size()) {
                 throw std::runtime_error(
@@ -277,15 +282,15 @@
             i = wrap_i(i, v.size());
             v.erase(v.begin() + i);
         },
         "Delete the list elements at index ``i``");
 
     cl.def(
         "__delitem__",
-        [](Vector &v, slice slice) {
+        [](Vector &v, const slice &slice) {
             size_t start = 0, stop = 0, step = 0, slicelength = 0;
 
             if (!slice.compute(v.size(), &start, &stop, &step, &slicelength)) {
                 throw error_already_set();
             }
 
             if (step == 1 && false) {
@@ -348,21 +353,25 @@
 template <typename Vector, typename Class_>
 void vector_accessor(enable_if_t<vector_needs_copy<Vector>::value, Class_> &cl) {
     using T = typename Vector::value_type;
     using SizeType = typename Vector::size_type;
     using DiffType = typename Vector::difference_type;
     using ItType = typename Vector::iterator;
     cl.def("__getitem__", [](const Vector &v, DiffType i) -> T {
-        if (i < 0 && (i += v.size()) < 0) {
-            throw index_error();
+        if (i < 0) {
+            i += v.size();
+            if (i < 0) {
+                throw index_error();
+            }
         }
-        if ((SizeType) i >= v.size()) {
+        auto i_st = static_cast<SizeType>(i);
+        if (i_st >= v.size()) {
             throw index_error();
         }
-        return v[(SizeType) i];
+        return v[i_st];
     });
 
     cl.def(
         "__iter__",
         [](Vector &v) {
             return make_iterator<return_value_policy::copy, ItType, ItType, T>(v.begin(), v.end());
         },
@@ -512,15 +521,15 @@
     detail::vector_accessor<Vector, Class_>(cl);
 
     cl.def(
         "__bool__",
         [](const Vector &v) -> bool { return !v.empty(); },
         "Check whether the list is nonempty");
 
-    cl.def("__len__", &Vector::size);
+    cl.def("__len__", [](const Vector &vec) { return vec.size(); });
 
 #if 0
     // C++ style functions deprecated, leaving it here as an example
     cl.def(init<size_type>());
 
     cl.def("resize",
          (void (Vector::*) (size_type count)) & Vector::resize,
@@ -632,57 +641,115 @@
             }
             s << '}';
             return s.str();
         },
         "Return the canonical string representation of this map.");
 }
 
-template <typename Map>
 struct keys_view {
+    virtual size_t len() = 0;
+    virtual iterator iter() = 0;
+    virtual bool contains(const handle &k) = 0;
+    virtual ~keys_view() = default;
+};
+
+struct values_view {
+    virtual size_t len() = 0;
+    virtual iterator iter() = 0;
+    virtual ~values_view() = default;
+};
+
+struct items_view {
+    virtual size_t len() = 0;
+    virtual iterator iter() = 0;
+    virtual ~items_view() = default;
+};
+
+template <typename Map>
+struct KeysViewImpl : public detail::keys_view {
+    explicit KeysViewImpl(Map &map) : map(map) {}
+    size_t len() override { return map.size(); }
+    iterator iter() override { return make_key_iterator(map.begin(), map.end()); }
+    bool contains(const handle &k) override {
+        try {
+            return map.find(k.template cast<typename Map::key_type>()) != map.end();
+        } catch (const cast_error &) {
+            return false;
+        }
+    }
     Map &map;
 };
 
 template <typename Map>
-struct values_view {
+struct ValuesViewImpl : public detail::values_view {
+    explicit ValuesViewImpl(Map &map) : map(map) {}
+    size_t len() override { return map.size(); }
+    iterator iter() override { return make_value_iterator(map.begin(), map.end()); }
     Map &map;
 };
 
 template <typename Map>
-struct items_view {
+struct ItemsViewImpl : public detail::items_view {
+    explicit ItemsViewImpl(Map &map) : map(map) {}
+    size_t len() override { return map.size(); }
+    iterator iter() override { return make_iterator(map.begin(), map.end()); }
     Map &map;
 };
 
 PYBIND11_NAMESPACE_END(detail)
 
 template <typename Map, typename holder_type = std::unique_ptr<Map>, typename... Args>
 class_<Map, holder_type> bind_map(handle scope, const std::string &name, Args &&...args) {
     using KeyType = typename Map::key_type;
     using MappedType = typename Map::mapped_type;
-    using KeysView = detail::keys_view<Map>;
-    using ValuesView = detail::values_view<Map>;
-    using ItemsView = detail::items_view<Map>;
+    using KeysView = detail::keys_view;
+    using ValuesView = detail::values_view;
+    using ItemsView = detail::items_view;
     using Class_ = class_<Map, holder_type>;
 
     // If either type is a non-module-local bound type then make the map binding non-local as well;
     // otherwise (e.g. both types are either module-local or converting) the map will be
     // module-local.
     auto *tinfo = detail::get_type_info(typeid(MappedType));
     bool local = !tinfo || tinfo->module_local;
     if (local) {
         tinfo = detail::get_type_info(typeid(KeyType));
         local = !tinfo || tinfo->module_local;
     }
 
     Class_ cl(scope, name.c_str(), pybind11::module_local(local), std::forward<Args>(args)...);
-    class_<KeysView> keys_view(
-        scope, ("KeysView[" + name + "]").c_str(), pybind11::module_local(local));
-    class_<ValuesView> values_view(
-        scope, ("ValuesView[" + name + "]").c_str(), pybind11::module_local(local));
-    class_<ItemsView> items_view(
-        scope, ("ItemsView[" + name + "]").c_str(), pybind11::module_local(local));
+
+    // Wrap KeysView if it wasn't already wrapped
+    if (!detail::get_type_info(typeid(KeysView))) {
+        class_<KeysView> keys_view(scope, "KeysView", pybind11::module_local(local));
+        keys_view.def("__len__", &KeysView::len);
+        keys_view.def("__iter__",
+                      &KeysView::iter,
+                      keep_alive<0, 1>() /* Essential: keep view alive while iterator exists */
+        );
+        keys_view.def("__contains__", &KeysView::contains);
+    }
+    // Similarly for ValuesView:
+    if (!detail::get_type_info(typeid(ValuesView))) {
+        class_<ValuesView> values_view(scope, "ValuesView", pybind11::module_local(local));
+        values_view.def("__len__", &ValuesView::len);
+        values_view.def("__iter__",
+                        &ValuesView::iter,
+                        keep_alive<0, 1>() /* Essential: keep view alive while iterator exists */
+        );
+    }
+    // Similarly for ItemsView:
+    if (!detail::get_type_info(typeid(ItemsView))) {
+        class_<ItemsView> items_view(scope, "ItemsView", pybind11::module_local(local));
+        items_view.def("__len__", &ItemsView::len);
+        items_view.def("__iter__",
+                       &ItemsView::iter,
+                       keep_alive<0, 1>() /* Essential: keep view alive while iterator exists */
+        );
+    }
 
     cl.def(init<>());
 
     // Register stream insertion operator (if possible)
     detail::map_if_insertion_operator<Map, Class_>(cl, name);
 
     cl.def(
@@ -694,27 +761,27 @@
         "__iter__",
         [](Map &m) { return make_key_iterator(m.begin(), m.end()); },
         keep_alive<0, 1>() /* Essential: keep map alive while iterator exists */
     );
 
     cl.def(
         "keys",
-        [](Map &m) { return KeysView{m}; },
+        [](Map &m) { return std::unique_ptr<KeysView>(new detail::KeysViewImpl<Map>(m)); },
         keep_alive<0, 1>() /* Essential: keep map alive while view exists */
     );
 
     cl.def(
         "values",
-        [](Map &m) { return ValuesView{m}; },
+        [](Map &m) { return std::unique_ptr<ValuesView>(new detail::ValuesViewImpl<Map>(m)); },
         keep_alive<0, 1>() /* Essential: keep map alive while view exists */
     );
 
     cl.def(
         "items",
-        [](Map &m) { return ItemsView{m}; },
+        [](Map &m) { return std::unique_ptr<ItemsView>(new detail::ItemsViewImpl<Map>(m)); },
         keep_alive<0, 1>() /* Essential: keep map alive while view exists */
     );
 
     cl.def(
         "__getitem__",
         [](Map &m, const KeyType &k) -> MappedType & {
             auto it = m.find(k);
@@ -743,43 +810,14 @@
         auto it = m.find(k);
         if (it == m.end()) {
             throw key_error();
         }
         m.erase(it);
     });
 
-    cl.def("__len__", &Map::size);
-
-    keys_view.def("__len__", [](KeysView &view) { return view.map.size(); });
-    keys_view.def(
-        "__iter__",
-        [](KeysView &view) { return make_key_iterator(view.map.begin(), view.map.end()); },
-        keep_alive<0, 1>() /* Essential: keep view alive while iterator exists */
-    );
-    keys_view.def("__contains__", [](KeysView &view, const KeyType &k) -> bool {
-        auto it = view.map.find(k);
-        if (it == view.map.end()) {
-            return false;
-        }
-        return true;
-    });
-    // Fallback for when the object is not of the key type
-    keys_view.def("__contains__", [](KeysView &, const object &) -> bool { return false; });
-
-    values_view.def("__len__", [](ValuesView &view) { return view.map.size(); });
-    values_view.def(
-        "__iter__",
-        [](ValuesView &view) { return make_value_iterator(view.map.begin(), view.map.end()); },
-        keep_alive<0, 1>() /* Essential: keep view alive while iterator exists */
-    );
-
-    items_view.def("__len__", [](ItemsView &view) { return view.map.size(); });
-    items_view.def(
-        "__iter__",
-        [](ItemsView &view) { return make_iterator(view.map.begin(), view.map.end()); },
-        keep_alive<0, 1>() /* Essential: keep view alive while iterator exists */
-    );
+    // Always use a lambda in case of `using` declaration
+    cl.def("__len__", [](const Map &m) { return m.size(); });
 
     return cl;
 }
 
 PYBIND11_NAMESPACE_END(PYBIND11_NAMESPACE)
```

### Comparing `python_prtree-0.6.0/third/pybind11/noxfile.py` & `python_prtree-0.6.1/third/pybind11/noxfile.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,22 +1,37 @@
+import os
+
 import nox
 
 nox.needs_version = ">=2022.1.7"
 nox.options.sessions = ["lint", "tests", "tests_packaging"]
 
-PYTHON_VERSIONS = ["2.7", "3.5", "3.6", "3.7", "3.8", "3.9", "3.10", "3.11"]
+PYTHON_VERSIONS = [
+    "3.6",
+    "3.7",
+    "3.8",
+    "3.9",
+    "3.10",
+    "3.11",
+    "pypy3.7",
+    "pypy3.8",
+    "pypy3.9",
+]
+
+if os.environ.get("CI", None):
+    nox.options.error_on_missing_interpreters = True
 
 
 @nox.session(reuse_venv=True)
 def lint(session: nox.Session) -> None:
     """
     Lint the codebase (except for clang-format/tidy).
     """
     session.install("pre-commit")
-    session.run("pre-commit", "run", "-a")
+    session.run("pre-commit", "run", "-a", *session.posargs)
 
 
 @nox.session(python=PYTHON_VERSIONS)
 def tests(session: nox.Session) -> None:
     """
     Run the tests (requires a compiler).
     """
@@ -38,32 +53,32 @@
 
 @nox.session
 def tests_packaging(session: nox.Session) -> None:
     """
     Run the packaging tests.
     """
 
-    session.install("-r", "tests/requirements.txt", "--prefer-binary")
-    session.run("pytest", "tests/extra_python_package")
+    session.install("-r", "tests/requirements.txt")
+    session.run("pytest", "tests/extra_python_package", *session.posargs)
 
 
 @nox.session(reuse_venv=True)
 def docs(session: nox.Session) -> None:
     """
     Build the docs. Pass "serve" to serve.
     """
 
     session.install("-r", "docs/requirements.txt")
     session.chdir("docs")
 
     if "pdf" in session.posargs:
-        session.run("sphinx-build", "-b", "latexpdf", ".", "_build")
+        session.run("sphinx-build", "-M", "latexpdf", ".", "_build")
         return
 
-    session.run("sphinx-build", "-b", "html", ".", "_build")
+    session.run("sphinx-build", "-M", "html", ".", "_build")
 
     if "serve" in session.posargs:
         session.log("Launching docs at http://localhost:8000/ - use Ctrl-C to quit")
         session.run("python", "-m", "http.server", "8000", "-d", "_build/html")
     elif session.posargs:
         session.error("Unsupported argument to docs")
```

### Comparing `python_prtree-0.6.0/third/pybind11/pybind11/__main__.py` & `python_prtree-0.6.1/third/pybind11/pybind11/__main__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,19 +1,18 @@
-# -*- coding: utf-8 -*-
-from __future__ import print_function
+# pylint: disable=missing-function-docstring
 
 import argparse
 import sys
 import sysconfig
 
-from .commands import get_cmake_dir, get_include
+from ._version import __version__
+from .commands import get_cmake_dir, get_include, get_pkgconfig_dir
 
 
-def print_includes():
-    # type: () -> None
+def print_includes() -> None:
     dirs = [
         sysconfig.get_path("include"),
         sysconfig.get_path("platinclude"),
         get_include(),
     ]
 
     # Make unique but preserve order
@@ -21,32 +20,43 @@
     for d in dirs:
         if d and d not in unique_dirs:
             unique_dirs.append(d)
 
     print(" ".join("-I" + d for d in unique_dirs))
 
 
-def main():
-    # type: () -> None
-
+def main() -> None:
     parser = argparse.ArgumentParser()
     parser.add_argument(
+        "--version",
+        action="version",
+        version=__version__,
+        help="Print the version and exit.",
+    )
+    parser.add_argument(
         "--includes",
         action="store_true",
         help="Include flags for both pybind11 and Python headers.",
     )
     parser.add_argument(
         "--cmakedir",
         action="store_true",
         help="Print the CMake module directory, ideal for setting -Dpybind11_ROOT in CMake.",
     )
+    parser.add_argument(
+        "--pkgconfigdir",
+        action="store_true",
+        help="Print the pkgconfig directory, ideal for setting $PKG_CONFIG_PATH.",
+    )
     args = parser.parse_args()
     if not sys.argv[1:]:
         parser.print_help()
     if args.includes:
         print_includes()
     if args.cmakedir:
         print(get_cmake_dir())
+    if args.pkgconfigdir:
+        print(get_pkgconfig_dir())
 
 
 if __name__ == "__main__":
     main()
```

### Comparing `python_prtree-0.6.0/third/pybind11/pybind11/setup_helpers.py` & `python_prtree-0.6.1/third/pybind11/pybind11/setup_helpers.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,9 +1,7 @@
-# -*- coding: utf-8 -*-
-
 """
 This module provides helpers for C++11+ projects using pybind11.
 
 LICENSE:
 
 Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>, All rights reserved.
 
@@ -45,27 +43,42 @@
 import shlex
 import shutil
 import sys
 import sysconfig
 import tempfile
 import threading
 import warnings
+from functools import lru_cache
+from pathlib import Path
+from typing import (
+    Any,
+    Callable,
+    Dict,
+    Iterable,
+    Iterator,
+    List,
+    Optional,
+    Tuple,
+    TypeVar,
+    Union,
+)
 
 try:
     from setuptools import Extension as _Extension
     from setuptools.command.build_ext import build_ext as _build_ext
 except ImportError:
-    from distutils.command.build_ext import build_ext as _build_ext
-    from distutils.extension import Extension as _Extension
+    from distutils.command.build_ext import (  # type: ignore[assignment]
+        build_ext as _build_ext,
+    )
+    from distutils.extension import Extension as _Extension  # type: ignore[assignment]
 
 import distutils.ccompiler
 import distutils.errors
 
 WIN = sys.platform.startswith("win32") and "mingw" not in sysconfig.get_platform()
-PY2 = sys.version_info[0] < 3
 MACOS = sys.platform.startswith("darwin")
 STD_TMPL = "/std:c++{}" if WIN else "-std=c++{}"
 
 
 # It is recommended to use PEP 518 builds if using this module. However, this
 # file explicitly supports being copied into a user's project directory
 # standalone, and pulling pybind11 with the deprecated setup_requires feature.
@@ -91,91 +104,80 @@
     ``build_ext``, which will search for the highest supported extension for
     you if the ``cxx_std`` property is not set. Do not set the ``cxx_std``
     property more than once, as flags are added when you set it. Set the
     property to None to disable the addition of C++ standard flags.
 
     If you want to add pybind11 headers manually, for example for an exact
     git checkout, then set ``include_pybind11=False``.
-
-    Warning: do not use property-based access to the instance on Python 2 -
-    this is an ugly old-style class due to Distutils.
     """
 
     # flags are prepended, so that they can be further overridden, e.g. by
     # ``extra_compile_args=["-g"]``.
 
-    def _add_cflags(self, flags):
+    def _add_cflags(self, flags: List[str]) -> None:
         self.extra_compile_args[:0] = flags
 
-    def _add_ldflags(self, flags):
+    def _add_ldflags(self, flags: List[str]) -> None:
         self.extra_link_args[:0] = flags
 
-    def __init__(self, *args, **kwargs):
-
+    def __init__(self, *args: Any, **kwargs: Any) -> None:
         self._cxx_level = 0
         cxx_std = kwargs.pop("cxx_std", 0)
 
         if "language" not in kwargs:
             kwargs["language"] = "c++"
 
         include_pybind11 = kwargs.pop("include_pybind11", True)
 
-        # Can't use super here because distutils has old-style classes in
-        # Python 2!
-        _Extension.__init__(self, *args, **kwargs)
+        super().__init__(*args, **kwargs)
 
         # Include the installed package pybind11 headers
         if include_pybind11:
             # If using setup_requires, this fails the first time - that's okay
             try:
                 import pybind11
 
                 pyinc = pybind11.get_include()
 
                 if pyinc not in self.include_dirs:
                     self.include_dirs.append(pyinc)
-            except ImportError:
+            except ModuleNotFoundError:
                 pass
 
-        # Have to use the accessor manually to support Python 2 distutils
-        Pybind11Extension.cxx_std.__set__(self, cxx_std)
+        self.cxx_std = cxx_std
 
         cflags = []
-        ldflags = []
         if WIN:
             cflags += ["/EHsc", "/bigobj"]
         else:
             cflags += ["-fvisibility=hidden"]
             env_cflags = os.environ.get("CFLAGS", "")
             env_cppflags = os.environ.get("CPPFLAGS", "")
             c_cpp_flags = shlex.split(env_cflags) + shlex.split(env_cppflags)
             if not any(opt.startswith("-g") for opt in c_cpp_flags):
                 cflags += ["-g0"]
-            if MACOS:
-                cflags += ["-stdlib=libc++"]
-                ldflags += ["-stdlib=libc++"]
         self._add_cflags(cflags)
-        self._add_ldflags(ldflags)
 
     @property
-    def cxx_std(self):
+    def cxx_std(self) -> int:
         """
-        The CXX standard level. If set, will add the required flags. If left
-        at 0, it will trigger an automatic search when pybind11's build_ext
-        is used. If None, will have no effect.  Besides just the flags, this
-        may add a register warning/error fix for Python 2 or macos-min 10.9
-        or 10.14.
+        The CXX standard level. If set, will add the required flags. If left at
+        0, it will trigger an automatic search when pybind11's build_ext is
+        used. If None, will have no effect.  Besides just the flags, this may
+        add a macos-min 10.9 or 10.14 flag if MACOSX_DEPLOYMENT_TARGET is
+        unset.
         """
         return self._cxx_level
 
     @cxx_std.setter
-    def cxx_std(self, level):
-
+    def cxx_std(self, level: int) -> None:
         if self._cxx_level:
-            warnings.warn("You cannot safely change the cxx_level after setting it!")
+            warnings.warn(
+                "You cannot safely change the cxx_level after setting it!", stacklevel=2
+            )
 
         # MSVC 2015 Update 3 and later only have 14 (and later 17) modes, so
         # force a valid flag here.
         if WIN and level == 11:
             level = 14
 
         self._cxx_level = level
@@ -191,39 +193,28 @@
             # (10.12 or 10.13) can be set manually via environment variable if
             # you are careful in your feature usage, but 10.14 is the safest
             # setting for general use. However, never set higher than the
             # current macOS version!
             current_macos = tuple(int(x) for x in platform.mac_ver()[0].split(".")[:2])
             desired_macos = (10, 9) if level < 17 else (10, 14)
             macos_string = ".".join(str(x) for x in min(current_macos, desired_macos))
-            macosx_min = "-mmacosx-version-min=" + macos_string
+            macosx_min = f"-mmacosx-version-min={macos_string}"
             cflags += [macosx_min]
             ldflags += [macosx_min]
 
-        if PY2:
-            if WIN:
-                # Will be ignored on MSVC 2015, where C++17 is not supported so
-                # this flag is not valid.
-                cflags += ["/wd5033"]
-            elif level >= 17:
-                cflags += ["-Wno-register"]
-            elif level >= 14:
-                cflags += ["-Wno-deprecated-register"]
-
         self._add_cflags(cflags)
         self._add_ldflags(ldflags)
 
 
 # Just in case someone clever tries to multithread
 tmp_chdir_lock = threading.Lock()
-cpp_cache_lock = threading.Lock()
 
 
 @contextlib.contextmanager
-def tmp_chdir():
+def tmp_chdir() -> Iterator[str]:
     "Prepare and enter a temporary directory, cleanup when done"
 
     # Threadsafe
     with tmp_chdir_lock:
         olddir = os.getcwd()
         try:
             tmpdir = tempfile.mkdtemp()
@@ -231,149 +222,161 @@
             yield tmpdir
         finally:
             os.chdir(olddir)
             shutil.rmtree(tmpdir)
 
 
 # cf http://bugs.python.org/issue26689
-def has_flag(compiler, flag):
+def has_flag(compiler: Any, flag: str) -> bool:
     """
     Return the flag if a flag name is supported on the
     specified compiler, otherwise None (can be used as a boolean).
     If multiple flags are passed, return the first that matches.
     """
 
     with tmp_chdir():
-        fname = "flagcheck.cpp"
-        with open(fname, "w") as f:
-            # Don't trigger -Wunused-parameter.
-            f.write("int main (int, char **) { return 0; }")
+        fname = Path("flagcheck.cpp")
+        # Don't trigger -Wunused-parameter.
+        fname.write_text("int main (int, char **) { return 0; }", encoding="utf-8")
 
         try:
-            compiler.compile([fname], extra_postargs=[flag])
+            compiler.compile([str(fname)], extra_postargs=[flag])
         except distutils.errors.CompileError:
             return False
         return True
 
 
 # Every call will cache the result
 cpp_flag_cache = None
 
 
-def auto_cpp_level(compiler):
+@lru_cache()
+def auto_cpp_level(compiler: Any) -> Union[str, int]:
     """
     Return the max supported C++ std level (17, 14, or 11). Returns latest on Windows.
     """
 
     if WIN:
         return "latest"
 
-    global cpp_flag_cache
-
-    # If this has been previously calculated with the same args, return that
-    with cpp_cache_lock:
-        if cpp_flag_cache:
-            return cpp_flag_cache
-
     levels = [17, 14, 11]
 
     for level in levels:
         if has_flag(compiler, STD_TMPL.format(level)):
-            with cpp_cache_lock:
-                cpp_flag_cache = level
             return level
 
     msg = "Unsupported compiler -- at least C++11 support is needed!"
     raise RuntimeError(msg)
 
 
 class build_ext(_build_ext):  # noqa: N801
     """
     Customized build_ext that allows an auto-search for the highest supported
     C++ level for Pybind11Extension. This is only needed for the auto-search
     for now, and is completely optional otherwise.
     """
 
-    def build_extensions(self):
+    def build_extensions(self) -> None:
         """
         Build extensions, injecting C++ std for Pybind11Extension if needed.
         """
 
         for ext in self.extensions:
             if hasattr(ext, "_cxx_level") and ext._cxx_level == 0:
-                # Python 2 syntax - old-style distutils class
-                ext.__class__.cxx_std.__set__(ext, auto_cpp_level(self.compiler))
+                ext.cxx_std = auto_cpp_level(self.compiler)
 
-        # Python 2 doesn't allow super here, since distutils uses old-style
-        # classes!
-        _build_ext.build_extensions(self)
+        super().build_extensions()
 
 
-def intree_extensions(paths, package_dir=None):
+def intree_extensions(
+    paths: Iterable[str], package_dir: Optional[Dict[str, str]] = None
+) -> List[Pybind11Extension]:
     """
     Generate Pybind11Extensions from source files directly located in a Python
     source tree.
 
     ``package_dir`` behaves as in ``setuptools.setup``.  If unset, the Python
     package root parent is determined as the first parent directory that does
     not contain an ``__init__.py`` file.
     """
     exts = []
-    for path in paths:
-        if package_dir is None:
+
+    if package_dir is None:
+        for path in paths:
             parent, _ = os.path.split(path)
             while os.path.exists(os.path.join(parent, "__init__.py")):
                 parent, _ = os.path.split(parent)
             relname, _ = os.path.splitext(os.path.relpath(path, parent))
             qualified_name = relname.replace(os.path.sep, ".")
             exts.append(Pybind11Extension(qualified_name, [path]))
+        return exts
+
+    for path in paths:
+        for prefix, parent in package_dir.items():
+            if path.startswith(parent):
+                relname, _ = os.path.splitext(os.path.relpath(path, parent))
+                qualified_name = relname.replace(os.path.sep, ".")
+                if prefix:
+                    qualified_name = prefix + "." + qualified_name
+                exts.append(Pybind11Extension(qualified_name, [path]))
+                break
         else:
-            found = False
-            for prefix, parent in package_dir.items():
-                if path.startswith(parent):
-                    found = True
-                    relname, _ = os.path.splitext(os.path.relpath(path, parent))
-                    qualified_name = relname.replace(os.path.sep, ".")
-                    if prefix:
-                        qualified_name = prefix + "." + qualified_name
-                    exts.append(Pybind11Extension(qualified_name, [path]))
-            if not found:
-                raise ValueError(
-                    "path {} is not a child of any of the directories listed "
-                    "in 'package_dir' ({})".format(path, package_dir)
-                )
+            msg = (
+                f"path {path} is not a child of any of the directories listed "
+                f"in 'package_dir' ({package_dir})"
+            )
+            raise ValueError(msg)
+
     return exts
 
 
-def naive_recompile(obj, src):
+def naive_recompile(obj: str, src: str) -> bool:
     """
     This will recompile only if the source file changes. It does not check
     header files, so a more advanced function or Ccache is better if you have
     editable header files in your package.
     """
     return os.stat(obj).st_mtime < os.stat(src).st_mtime
 
 
-def no_recompile(obg, src):
+def no_recompile(obg: str, src: str) -> bool:  # noqa: ARG001
     """
     This is the safest but slowest choice (and is the default) - will always
     recompile sources.
     """
     return True
 
 
+S = TypeVar("S", bound="ParallelCompile")
+
+CCompilerMethod = Callable[
+    [
+        distutils.ccompiler.CCompiler,
+        List[str],
+        Optional[str],
+        Optional[Union[Tuple[str], Tuple[str, Optional[str]]]],
+        Optional[List[str]],
+        bool,
+        Optional[List[str]],
+        Optional[List[str]],
+        Optional[List[str]],
+    ],
+    List[str],
+]
+
+
 # Optional parallel compile utility
 # inspired by: http://stackoverflow.com/questions/11013851/speeding-up-build-process-with-distutils
 # and: https://github.com/tbenthompson/cppimport/blob/stable/cppimport/build_module.py
 # and NumPy's parallel distutils module:
 #              https://github.com/numpy/numpy/blob/master/numpy/distutils/ccompiler.py
-class ParallelCompile(object):
+class ParallelCompile:
     """
     Make a parallel compile function. Inspired by
-    numpy.distutils.ccompiler.CCompiler_compile and cppimport.
+    numpy.distutils.ccompiler.CCompiler.compile and cppimport.
 
     This takes several arguments that allow you to customize the compile
     function created:
 
     envvar:
         Set an environment variable to control the compilation threads, like
         NPY_NUM_BUILD_JOBS
@@ -400,59 +403,64 @@
     function can be provided via needs_recompile.  If the output has not yet
     been generated, the compile will always run, and this function is not
     called.
     """
 
     __slots__ = ("envvar", "default", "max", "_old", "needs_recompile")
 
-    def __init__(self, envvar=None, default=0, max=0, needs_recompile=no_recompile):
+    def __init__(
+        self,
+        envvar: Optional[str] = None,
+        default: int = 0,
+        max: int = 0,  # pylint: disable=redefined-builtin
+        needs_recompile: Callable[[str, str], bool] = no_recompile,
+    ) -> None:
         self.envvar = envvar
         self.default = default
         self.max = max
         self.needs_recompile = needs_recompile
-        self._old = []
+        self._old: List[CCompilerMethod] = []
 
-    def function(self):
+    def function(self) -> CCompilerMethod:
         """
         Builds a function object usable as distutils.ccompiler.CCompiler.compile.
         """
 
         def compile_function(
-            compiler,
-            sources,
-            output_dir=None,
-            macros=None,
-            include_dirs=None,
-            debug=0,
-            extra_preargs=None,
-            extra_postargs=None,
-            depends=None,
-        ):
-
+            compiler: distutils.ccompiler.CCompiler,
+            sources: List[str],
+            output_dir: Optional[str] = None,
+            macros: Optional[Union[Tuple[str], Tuple[str, Optional[str]]]] = None,
+            include_dirs: Optional[List[str]] = None,
+            debug: bool = False,
+            extra_preargs: Optional[List[str]] = None,
+            extra_postargs: Optional[List[str]] = None,
+            depends: Optional[List[str]] = None,
+        ) -> Any:
             # These lines are directly from distutils.ccompiler.CCompiler
-            macros, objects, extra_postargs, pp_opts, build = compiler._setup_compile(
+            macros, objects, extra_postargs, pp_opts, build = compiler._setup_compile(  # type: ignore[attr-defined]
                 output_dir, macros, include_dirs, sources, depends, extra_postargs
             )
-            cc_args = compiler._get_cc_args(pp_opts, debug, extra_preargs)
+            cc_args = compiler._get_cc_args(pp_opts, debug, extra_preargs)  # type: ignore[attr-defined]
 
             # The number of threads; start with default.
             threads = self.default
 
             # Determine the number of compilation threads, unless set by an environment variable.
             if self.envvar is not None:
                 threads = int(os.environ.get(self.envvar, self.default))
 
-            def _single_compile(obj):
+            def _single_compile(obj: Any) -> None:
                 try:
                     src, ext = build[obj]
                 except KeyError:
                     return
 
                 if not os.path.exists(obj) or self.needs_recompile(obj, src):
-                    compiler._compile(obj, src, ext, cc_args, extra_postargs, pp_opts)
+                    compiler._compile(obj, src, ext, cc_args, extra_postargs, pp_opts)  # type: ignore[attr-defined]
 
             try:
                 # Importing .synchronize checks for platforms that have some multiprocessing
                 # capabilities but lack semaphores, such as AWS Lambda and Android Termux.
                 import multiprocessing.synchronize
                 from multiprocessing.pool import ThreadPool
             except ImportError:
@@ -462,33 +470,31 @@
                 try:
                     threads = multiprocessing.cpu_count()
                     threads = self.max if self.max and self.max < threads else threads
                 except NotImplementedError:
                     threads = 1
 
             if threads > 1:
-                pool = ThreadPool(threads)
-                # In Python 2, ThreadPool can't be used as a context manager.
-                # Once we are no longer supporting it, this can be 'with pool:'
-                try:
+                with ThreadPool(threads) as pool:
                     for _ in pool.imap_unordered(_single_compile, objects):
                         pass
-                finally:
-                    pool.terminate()
             else:
                 for ob in objects:
                     _single_compile(ob)
 
             return objects
 
         return compile_function
 
-    def install(self):
-        distutils.ccompiler.CCompiler.compile = self.function()
+    def install(self: S) -> S:
+        """
+        Installs the compile function into distutils.ccompiler.CCompiler.compile.
+        """
+        distutils.ccompiler.CCompiler.compile = self.function()  # type: ignore[assignment]
         return self
 
-    def __enter__(self):
+    def __enter__(self: S) -> S:
         self._old.append(distutils.ccompiler.CCompiler.compile)
         return self.install()
 
-    def __exit__(self, *args):
-        distutils.ccompiler.CCompiler.compile = self._old.pop()
+    def __exit__(self, *args: Any) -> None:
+        distutils.ccompiler.CCompiler.compile = self._old.pop()  # type: ignore[assignment]
```

### Comparing `python_prtree-0.6.0/third/pybind11/setup.py` & `python_prtree-0.6.1/third/pybind11/setup.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,165 +1,150 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
+#!/usr/bin/env python3
 
 # Setup script for PyPI; use CMakeFile.txt to build extension modules
 
 import contextlib
-import io
 import os
 import re
 import shutil
 import string
 import subprocess
 import sys
-import tempfile
+from pathlib import Path
+from tempfile import TemporaryDirectory
+from typing import Dict, Iterator, List, Union
 
 import setuptools.command.sdist
 
-DIR = os.path.abspath(os.path.dirname(__file__))
+DIR = Path(__file__).parent.absolute()
 VERSION_REGEX = re.compile(
     r"^\s*#\s*define\s+PYBIND11_VERSION_([A-Z]+)\s+(.*)$", re.MULTILINE
 )
+VERSION_FILE = Path("pybind11/_version.py")
+COMMON_FILE = Path("include/pybind11/detail/common.h")
 
 
-def build_expected_version_hex(matches):
+def build_expected_version_hex(matches: Dict[str, str]) -> str:
     patch_level_serial = matches["PATCH"]
     serial = None
-    try:
-        major = int(matches["MAJOR"])
-        minor = int(matches["MINOR"])
-        flds = patch_level_serial.split(".")
-        if flds:
-            patch = int(flds[0])
-            level = None
-            if len(flds) == 1:
-                level = "0"
-                serial = 0
-            elif len(flds) == 2:
-                level_serial = flds[1]
-                for level in ("a", "b", "c", "dev"):
-                    if level_serial.startswith(level):
-                        serial = int(level_serial[len(level) :])
-                        break
-    except ValueError:
-        pass
+    major = int(matches["MAJOR"])
+    minor = int(matches["MINOR"])
+    flds = patch_level_serial.split(".")
+    if flds:
+        patch = int(flds[0])
+        if len(flds) == 1:
+            level = "0"
+            serial = 0
+        elif len(flds) == 2:
+            level_serial = flds[1]
+            for level in ("a", "b", "c", "dev"):
+                if level_serial.startswith(level):
+                    serial = int(level_serial[len(level) :])
+                    break
     if serial is None:
-        msg = 'Invalid PYBIND11_VERSION_PATCH: "{}"'.format(patch_level_serial)
+        msg = f'Invalid PYBIND11_VERSION_PATCH: "{patch_level_serial}"'
         raise RuntimeError(msg)
-    return (
-        "0x"
-        + "{:02x}{:02x}{:02x}{}{:x}".format(
-            major, minor, patch, level[:1], serial
-        ).upper()
-    )
+    version_hex_str = f"{major:02x}{minor:02x}{patch:02x}{level[:1]}{serial:x}"
+    return f"0x{version_hex_str.upper()}"
 
 
 # PYBIND11_GLOBAL_SDIST will build a different sdist, with the python-headers
 # files, and the sys.prefix files (CMake and headers).
 
 global_sdist = os.environ.get("PYBIND11_GLOBAL_SDIST", False)
 
-setup_py = "tools/setup_global.py.in" if global_sdist else "tools/setup_main.py.in"
+setup_py = Path(
+    "tools/setup_global.py.in" if global_sdist else "tools/setup_main.py.in"
+)
 extra_cmd = 'cmdclass["sdist"] = SDist\n'
 
 to_src = (
-    ("pyproject.toml", "tools/pyproject.toml"),
-    ("setup.py", setup_py),
+    (Path("pyproject.toml"), Path("tools/pyproject.toml")),
+    (Path("setup.py"), setup_py),
 )
 
+
 # Read the listed version
-with open("pybind11/_version.py") as f:
-    code = compile(f.read(), "pybind11/_version.py", "exec")
-loc = {}
+loc: Dict[str, str] = {}
+code = compile(VERSION_FILE.read_text(encoding="utf-8"), "pybind11/_version.py", "exec")
 exec(code, loc)
 version = loc["__version__"]
 
 # Verify that the version matches the one in C++
-with io.open("include/pybind11/detail/common.h", encoding="utf8") as f:
-    matches = dict(VERSION_REGEX.findall(f.read()))
+matches = dict(VERSION_REGEX.findall(COMMON_FILE.read_text(encoding="utf8")))
 cpp_version = "{MAJOR}.{MINOR}.{PATCH}".format(**matches)
 if version != cpp_version:
-    msg = "Python version {} does not match C++ version {}!".format(
-        version, cpp_version
-    )
+    msg = f"Python version {version} does not match C++ version {cpp_version}!"
     raise RuntimeError(msg)
 
 version_hex = matches.get("HEX", "MISSING")
-expected_version_hex = build_expected_version_hex(matches)
-if version_hex != expected_version_hex:
-    msg = "PYBIND11_VERSION_HEX {} does not match expected value {}!".format(
-        version_hex,
-        expected_version_hex,
-    )
+exp_version_hex = build_expected_version_hex(matches)
+if version_hex != exp_version_hex:
+    msg = f"PYBIND11_VERSION_HEX {version_hex} does not match expected value {exp_version_hex}!"
     raise RuntimeError(msg)
 
 
-def get_and_replace(filename, binary=False, **opts):
-    with open(filename, "rb" if binary else "r") as f:
-        contents = f.read()
-    # Replacement has to be done on text in Python 3 (both work in Python 2)
+# TODO: use literals & overload (typing extensions or Python 3.8)
+def get_and_replace(
+    filename: Path, binary: bool = False, **opts: str
+) -> Union[bytes, str]:
     if binary:
+        contents = filename.read_bytes()
         return string.Template(contents.decode()).substitute(opts).encode()
-    else:
-        return string.Template(contents).substitute(opts)
+
+    return string.Template(filename.read_text()).substitute(opts)
 
 
 # Use our input files instead when making the SDist (and anything that depends
 # on it, like a wheel)
 class SDist(setuptools.command.sdist.sdist):
-    def make_release_tree(self, base_dir, files):
-        setuptools.command.sdist.sdist.make_release_tree(self, base_dir, files)
+    def make_release_tree(self, base_dir: str, files: List[str]) -> None:
+        super().make_release_tree(base_dir, files)
 
         for to, src in to_src:
             txt = get_and_replace(src, binary=True, version=version, extra_cmd="")
 
-            dest = os.path.join(base_dir, to)
+            dest = Path(base_dir) / to
 
             # This is normally linked, so unlink before writing!
-            os.unlink(dest)
-            with open(dest, "wb") as f:
-                f.write(txt)
-
-
-# Backport from Python 3
-@contextlib.contextmanager
-def TemporaryDirectory():  # noqa: N802
-    "Prepare a temporary directory, cleanup when done"
-    try:
-        tmpdir = tempfile.mkdtemp()
-        yield tmpdir
-    finally:
-        shutil.rmtree(tmpdir)
+            dest.unlink()
+            dest.write_bytes(txt)  # type: ignore[arg-type]
 
 
 # Remove the CMake install directory when done
 @contextlib.contextmanager
-def remove_output(*sources):
+def remove_output(*sources: str) -> Iterator[None]:
     try:
         yield
     finally:
         for src in sources:
             shutil.rmtree(src)
 
 
 with remove_output("pybind11/include", "pybind11/share"):
     # Generate the files if they are not present.
     with TemporaryDirectory() as tmpdir:
         cmd = ["cmake", "-S", ".", "-B", tmpdir] + [
             "-DCMAKE_INSTALL_PREFIX=pybind11",
             "-DBUILD_TESTING=OFF",
             "-DPYBIND11_NOPYTHON=ON",
+            "-Dprefix_for_pc_file=${pcfiledir}/../../",
         ]
         if "CMAKE_ARGS" in os.environ:
             fcommand = [
                 c
                 for c in os.environ["CMAKE_ARGS"].split()
                 if "DCMAKE_INSTALL_PREFIX" not in c
             ]
             cmd += fcommand
-        cmake_opts = dict(cwd=DIR, stdout=sys.stdout, stderr=sys.stderr)
-        subprocess.check_call(cmd, **cmake_opts)
-        subprocess.check_call(["cmake", "--install", tmpdir], **cmake_opts)
+        subprocess.run(cmd, check=True, cwd=DIR, stdout=sys.stdout, stderr=sys.stderr)
+        subprocess.run(
+            ["cmake", "--install", tmpdir],
+            check=True,
+            cwd=DIR,
+            stdout=sys.stdout,
+            stderr=sys.stderr,
+        )
 
     txt = get_and_replace(setup_py, version=version, extra_cmd=extra_cmd)
     code = compile(txt, setup_py, "exec")
     exec(code, {"SDist": SDist})
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/CMakeLists.txt` & `python_prtree-0.6.1/third/pybind11/tests/CMakeLists.txt`

 * *Files 6% similar despite different names*

```diff
@@ -1,28 +1,25 @@
 # CMakeLists.txt -- Build system for the pybind11 test suite
 #
 # Copyright (c) 2015 Wenzel Jakob <wenzel@inf.ethz.ch>
 #
 # All rights reserved. Use of this source code is governed by a
 # BSD-style license that can be found in the LICENSE file.
 
-cmake_minimum_required(VERSION 3.4)
+cmake_minimum_required(VERSION 3.5)
 
-# The `cmake_minimum_required(VERSION 3.4...3.18)` syntax does not work with
+# The `cmake_minimum_required(VERSION 3.5...3.27)` syntax does not work with
 # some versions of VS that have a patched CMake 3.11. This forces us to emulate
 # the behavior using the following workaround:
-if(${CMAKE_VERSION} VERSION_LESS 3.21)
+if(${CMAKE_VERSION} VERSION_LESS 3.27)
   cmake_policy(VERSION ${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION})
 else()
-  cmake_policy(VERSION 3.21)
+  cmake_policy(VERSION 3.27)
 endif()
 
-# Only needed for CMake < 3.5 support
-include(CMakeParseArguments)
-
 # Filter out items; print an optional message if any items filtered. This ignores extensions.
 #
 # Usage:
 #   pybind11_filter_tests(LISTNAME file1.cpp file2.cpp ... MESSAGE "")
 #
 macro(pybind11_filter_tests LISTNAME)
   cmake_parse_arguments(ARG "" "MESSAGE" "" ${ARGN})
@@ -124,15 +121,16 @@
     test_class
     test_const_name
     test_constants_and_functions
     test_copy_move
     test_custom_type_casters
     test_custom_type_setup
     test_docstring_options
-    test_eigen
+    test_eigen_matrix
+    test_eigen_tensor
     test_enum
     test_eval
     test_exceptions
     test_factory_constructors
     test_gil_scoped
     test_iostream
     test_kwargs_and_defaults
@@ -142,52 +140,52 @@
     test_multiple_inheritance
     test_numpy_array
     test_numpy_dtypes
     test_numpy_vectorize
     test_opaque_types
     test_operator_overloading
     test_pickling
+    test_python_multiple_inheritance
     test_pytypes
     test_sequences_and_iterators
     test_smart_ptr
     test_stl
     test_stl_binders
     test_tagbased_polymorphic
     test_thread
+    test_type_caster_pyobject_ptr
     test_union
+    test_unnamed_namespace_a
+    test_unnamed_namespace_b
+    test_vector_unique_ptr_member
     test_virtual_functions)
 
 # Invoking cmake with something like:
 #     cmake -DPYBIND11_TEST_OVERRIDE="test_callbacks.cpp;test_pickling.cpp" ..
 # lets you override the tests that get compiled and run.  You can restore to all tests with:
 #     cmake -DPYBIND11_TEST_OVERRIDE= ..
 if(PYBIND11_TEST_OVERRIDE)
   # Instead of doing a direct override here, we iterate over the overrides without extension and
   # match them against entries from the PYBIND11_TEST_FILES, anything that not matches goes into the filter list.
   string(REGEX REPLACE "\\.[^.;]*;" ";" TEST_OVERRIDE_NO_EXT "${PYBIND11_TEST_OVERRIDE};")
   string(REGEX REPLACE "\\.[^.;]*;" ";" TEST_FILES_NO_EXT "${PYBIND11_TEST_FILES};")
   # This allows the override to be done with extensions, preserving backwards compatibility.
   foreach(test_name ${TEST_FILES_NO_EXT})
     if(NOT ${test_name} IN_LIST TEST_OVERRIDE_NO_EXT
-    )# If not in the whitelist, add to be filtered out.
+    )# If not in the allowlist, add to be filtered out.
       list(APPEND PYBIND11_TEST_FILTER ${test_name})
     endif()
   endforeach()
 endif()
 
 # You can also filter tests:
 if(PYBIND11_TEST_FILTER)
   pybind11_filter_tests(PYBIND11_TEST_FILES ${PYBIND11_TEST_FILTER})
 endif()
 
-if(PYTHON_VERSION VERSION_LESS 3.5)
-  pybind11_filter_tests(PYBIND11_TEST_FILES test_async.cpp MESSAGE
-                        "Skipping test_async on Python 2")
-endif()
-
 # Skip tests for CUDA check:
 # /pybind11/tests/test_constants_and_functions.cpp(125):
 #   error: incompatible exception specifications
 if(PYBIND11_CUDA_TESTS)
   pybind11_filter_tests(
     PYBIND11_TEST_FILES test_constants_and_functions.cpp MESSAGE
     "Skipping test_constants_and_functions due to incompatible exception specifications")
@@ -216,14 +214,15 @@
 # Contains the set of test files that require pybind11_cross_module_tests to be
 # built; if none of these are built (i.e. because TEST_OVERRIDE is used and
 # doesn't include them) the second module doesn't get built.
 tests_extra_targets("test_exceptions.py;test_local_bindings.py;test_stl.py;test_stl_binders.py"
                     "pybind11_cross_module_tests")
 
 # And add additional targets for other tests.
+tests_extra_targets("test_exceptions.py" "cross_module_interleaved_error_already_set")
 tests_extra_targets("test_gil_scoped.py" "cross_module_gil_utils")
 
 set(PYBIND11_EIGEN_REPO
     "https://gitlab.com/libeigen/eigen.git"
     CACHE STRING "Eigen repository to use for tests")
 # Always use a hash for reconfigure speed and security reasons
 # Include the version number for pretty printing (keep in sync)
@@ -233,15 +232,18 @@
 
 list(GET PYBIND11_EIGEN_VERSION_AND_HASH 0 PYBIND11_EIGEN_VERSION_STRING)
 list(GET PYBIND11_EIGEN_VERSION_AND_HASH 1 PYBIND11_EIGEN_VERSION_HASH)
 
 # Check if Eigen is available; if not, remove from PYBIND11_TEST_FILES (but
 # keep it in PYBIND11_PYTEST_FILES, so that we get the "eigen is not installed"
 # skip message).
-list(FIND PYBIND11_TEST_FILES test_eigen.cpp PYBIND11_TEST_FILES_EIGEN_I)
+list(FIND PYBIND11_TEST_FILES test_eigen_matrix.cpp PYBIND11_TEST_FILES_EIGEN_I)
+if(PYBIND11_TEST_FILES_EIGEN_I EQUAL -1)
+  list(FIND PYBIND11_TEST_FILES test_eigen_tensor.cpp PYBIND11_TEST_FILES_EIGEN_I)
+endif()
 if(PYBIND11_TEST_FILES_EIGEN_I GREATER -1)
   # Try loading via newer Eigen's Eigen3Config first (bypassing tools/FindEigen3.cmake).
   # Eigen 3.3.1+ exports a cmake 3.0+ target for handling dependency requirements, but also
   # produces a fatal error if loaded from a pre-3.0 cmake.
   if(DOWNLOAD_EIGEN)
     if(CMAKE_VERSION VERSION_LESS 3.11)
       message(FATAL_ERROR "CMake 3.11+ required when using DOWNLOAD_EIGEN")
@@ -288,21 +290,42 @@
     # Eigen 3.3.1+ cmake sets EIGEN3_VERSION_STRING (and hard codes the version when installed
     # rather than looking it up in the cmake script); older versions, and the
     # tools/FindEigen3.cmake, set EIGEN3_VERSION instead.
     if(NOT EIGEN3_VERSION AND EIGEN3_VERSION_STRING)
       set(EIGEN3_VERSION ${EIGEN3_VERSION_STRING})
     endif()
     message(STATUS "Building tests with Eigen v${EIGEN3_VERSION}")
+
+    if(NOT (CMAKE_CXX_COMPILER_ID STREQUAL "GNU" AND CMAKE_CXX_COMPILER_VERSION VERSION_LESS 5.0))
+      tests_extra_targets("test_eigen_tensor.py" "eigen_tensor_avoid_stl_array")
+    endif()
+
   else()
-    list(REMOVE_AT PYBIND11_TEST_FILES ${PYBIND11_TEST_FILES_EIGEN_I})
+    list(FIND PYBIND11_TEST_FILES test_eigen_matrix.cpp PYBIND11_TEST_FILES_EIGEN_I)
+    if(PYBIND11_TEST_FILES_EIGEN_I GREATER -1)
+      list(REMOVE_AT PYBIND11_TEST_FILES ${PYBIND11_TEST_FILES_EIGEN_I})
+    endif()
+
+    list(FIND PYBIND11_TEST_FILES test_eigen_tensor.cpp PYBIND11_TEST_FILES_EIGEN_I)
+    if(PYBIND11_TEST_FILES_EIGEN_I GREATER -1)
+      list(REMOVE_AT PYBIND11_TEST_FILES ${PYBIND11_TEST_FILES_EIGEN_I})
+    endif()
     message(
       STATUS "Building tests WITHOUT Eigen, use -DDOWNLOAD_EIGEN=ON on CMake 3.11+ to download")
   endif()
 endif()
 
+# Some code doesn't support gcc 4
+if(CMAKE_CXX_COMPILER_ID STREQUAL "GNU" AND CMAKE_CXX_COMPILER_VERSION VERSION_LESS 5.0)
+  list(FIND PYBIND11_TEST_FILES test_eigen_tensor.cpp PYBIND11_TEST_FILES_EIGEN_I)
+  if(PYBIND11_TEST_FILES_EIGEN_I GREATER -1)
+    list(REMOVE_AT PYBIND11_TEST_FILES ${PYBIND11_TEST_FILES_EIGEN_I})
+  endif()
+endif()
+
 # Optional dependency for some tests (boost::variant is only supported with version >= 1.56)
 find_package(Boost 1.56)
 
 if(Boost_FOUND)
   if(NOT TARGET Boost::headers)
     add_library(Boost::headers IMPORTED INTERFACE)
     if(TARGET Boost::boost)
@@ -352,15 +375,15 @@
   message(WARNING "Unknown C++17 compiler - not passing -lstdc++fs")
   set(STD_FS_LIB "")
 endif()
 
 # Compile with compiler warnings turned on
 function(pybind11_enable_warnings target_name)
   if(MSVC)
-    target_compile_options(${target_name} PRIVATE /W4)
+    target_compile_options(${target_name} PRIVATE /W4 /wd4189)
   elseif(CMAKE_CXX_COMPILER_ID MATCHES "(GNU|Intel|Clang)" AND NOT PYBIND11_CUDA_TESTS)
     target_compile_options(
       ${target_name}
       PRIVATE -Wall
               -Wextra
               -Wconversion
               -Wcast-qual
@@ -384,25 +407,14 @@
         ${target_name}
         PRIVATE
           -Werror-all
           # "Inlining inhibited by limit max-size", "Inlining inhibited by limit max-total-size"
           -diag-disable 11074,11076)
     endif()
   endif()
-
-  # Needs to be re-added since the ordering requires these to be after the ones above
-  if(CMAKE_CXX_STANDARD
-     AND CMAKE_CXX_COMPILER_ID MATCHES "Clang"
-     AND PYTHON_VERSION VERSION_LESS 3.0)
-    if(CMAKE_CXX_STANDARD LESS 17)
-      target_compile_options(${target_name} PUBLIC -Wno-deprecated-register)
-    else()
-      target_compile_options(${target_name} PUBLIC -Wno-register)
-    endif()
-  endif()
 endfunction()
 
 set(test_targets pybind11_tests)
 
 # Check if any tests need extra targets by iterating through the mappings registered.
 foreach(i ${PYBIND11_TEST_EXTRA_TARGETS})
   foreach(needle ${PYBIND11_TEST_EXTRA_TARGETS_NEEDLES_${i}})
@@ -504,19 +516,23 @@
 string(REPLACE "test_" "${CMAKE_CURRENT_SOURCE_DIR}/test_" PYBIND11_ABS_PYTEST_FILES
                "${PYBIND11_PYTEST_FILES}")
 
 set(PYBIND11_TEST_PREFIX_COMMAND
     ""
     CACHE STRING "Put this before pytest, use for checkers and such")
 
+set(PYBIND11_PYTEST_ARGS
+    ""
+    CACHE STRING "Extra arguments for pytest")
+
 # A single command to compile and run the tests
 add_custom_target(
   pytest
   COMMAND ${PYBIND11_TEST_PREFIX_COMMAND} ${PYTHON_EXECUTABLE} -m pytest
-          ${PYBIND11_ABS_PYTEST_FILES}
+          ${PYBIND11_ABS_PYTEST_FILES} ${PYBIND11_PYTEST_ARGS}
   DEPENDS ${test_targets}
   WORKING_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}"
   USES_TERMINAL)
 
 if(PYBIND11_TEST_OVERRIDE)
   add_custom_command(
     TARGET pytest
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/constructor_stats.h` & `python_prtree-0.6.1/third/pybind11/tests/constructor_stats.h`

 * *Files 0% similar despite different names*

```diff
@@ -111,15 +111,15 @@
     }
 
     static void gc() {
         // Force garbage collection to ensure any pending destructors are invoked:
 #if defined(PYPY_VERSION)
         PyObject *globals = PyEval_GetGlobals();
         PyObject *result = PyRun_String("import gc\n"
-                                        "for i in range(2):"
+                                        "for i in range(2):\n"
                                         "    gc.collect()\n",
                                         Py_file_input,
                                         globals,
                                         globals);
         if (result == nullptr)
             throw py::error_already_set();
         Py_DECREF(result);
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/env.py` & `python_prtree-0.6.1/third/pybind11/tests/env.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,33 +1,27 @@
-# -*- coding: utf-8 -*-
 import platform
 import sys
 
 import pytest
 
 LINUX = sys.platform.startswith("linux")
 MACOS = sys.platform.startswith("darwin")
 WIN = sys.platform.startswith("win32") or sys.platform.startswith("cygwin")
 
 CPYTHON = platform.python_implementation() == "CPython"
 PYPY = platform.python_implementation() == "PyPy"
 
-PY2 = sys.version_info.major == 2
-
-PY = sys.version_info
-
 
 def deprecated_call():
     """
     pytest.deprecated_call() seems broken in pytest<3.9.x; concretely, it
     doesn't work on CPython 3.8.0 with pytest==3.3.2 on Ubuntu 18.04 (#2922).
 
     This is a narrowed reimplementation of the following PR :(
     https://github.com/pytest-dev/pytest/pull/4104
     """
     # TODO: Remove this when testing requires pytest>=3.9.
     pieces = pytest.__version__.split(".")
     pytest_major_minor = (int(pieces[0]), int(pieces[1]))
     if pytest_major_minor < (3, 9):
         return pytest.warns((DeprecationWarning, PendingDeprecationWarning))
-    else:
-        return pytest.deprecated_call()
+    return pytest.deprecated_call()
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/extra_python_package/test_files.py` & `python_prtree-0.6.1/third/pybind11/tests/extra_python_package/test_files.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,271 +1,285 @@
-# -*- coding: utf-8 -*-
 import contextlib
 import os
 import string
 import subprocess
 import sys
 import tarfile
 import zipfile
 
 # These tests must be run explicitly
 # They require CMake 3.15+ (--install)
 
 DIR = os.path.abspath(os.path.dirname(__file__))
 MAIN_DIR = os.path.dirname(os.path.dirname(DIR))
 
+PKGCONFIG = """\
+prefix=${{pcfiledir}}/../../
+includedir=${{prefix}}/include
+
+Name: pybind11
+Description: Seamless operability between C++11 and Python
+Version: {VERSION}
+Cflags: -I${{includedir}}
+"""
+
 
 main_headers = {
     "include/pybind11/attr.h",
     "include/pybind11/buffer_info.h",
     "include/pybind11/cast.h",
     "include/pybind11/chrono.h",
     "include/pybind11/common.h",
     "include/pybind11/complex.h",
     "include/pybind11/eigen.h",
     "include/pybind11/embed.h",
     "include/pybind11/eval.h",
     "include/pybind11/functional.h",
     "include/pybind11/gil.h",
+    "include/pybind11/gil_safe_call_once.h",
     "include/pybind11/iostream.h",
     "include/pybind11/numpy.h",
     "include/pybind11/operators.h",
     "include/pybind11/options.h",
     "include/pybind11/pybind11.h",
     "include/pybind11/pytypes.h",
     "include/pybind11/stl.h",
     "include/pybind11/stl_bind.h",
+    "include/pybind11/type_caster_pyobject_ptr.h",
+    "include/pybind11/typing.h",
 }
 
 detail_headers = {
     "include/pybind11/detail/class.h",
     "include/pybind11/detail/common.h",
     "include/pybind11/detail/descr.h",
     "include/pybind11/detail/init.h",
     "include/pybind11/detail/internals.h",
     "include/pybind11/detail/type_caster_base.h",
     "include/pybind11/detail/typeid.h",
 }
 
+eigen_headers = {
+    "include/pybind11/eigen/common.h",
+    "include/pybind11/eigen/matrix.h",
+    "include/pybind11/eigen/tensor.h",
+}
+
 stl_headers = {
     "include/pybind11/stl/filesystem.h",
 }
 
 cmake_files = {
     "share/cmake/pybind11/FindPythonLibsNew.cmake",
     "share/cmake/pybind11/pybind11Common.cmake",
     "share/cmake/pybind11/pybind11Config.cmake",
     "share/cmake/pybind11/pybind11ConfigVersion.cmake",
     "share/cmake/pybind11/pybind11NewTools.cmake",
     "share/cmake/pybind11/pybind11Targets.cmake",
     "share/cmake/pybind11/pybind11Tools.cmake",
 }
 
+pkgconfig_files = {
+    "share/pkgconfig/pybind11.pc",
+}
+
 py_files = {
     "__init__.py",
     "__main__.py",
     "_version.py",
-    "_version.pyi",
     "commands.py",
     "py.typed",
     "setup_helpers.py",
-    "setup_helpers.pyi",
 }
 
-headers = main_headers | detail_headers | stl_headers
-src_files = headers | cmake_files
+headers = main_headers | detail_headers | eigen_headers | stl_headers
+src_files = headers | cmake_files | pkgconfig_files
 all_files = src_files | py_files
 
 
 sdist_files = {
     "pybind11",
     "pybind11/include",
     "pybind11/include/pybind11",
     "pybind11/include/pybind11/detail",
+    "pybind11/include/pybind11/eigen",
     "pybind11/include/pybind11/stl",
     "pybind11/share",
     "pybind11/share/cmake",
     "pybind11/share/cmake/pybind11",
+    "pybind11/share/pkgconfig",
     "pyproject.toml",
     "setup.cfg",
     "setup.py",
     "LICENSE",
     "MANIFEST.in",
     "README.rst",
     "PKG-INFO",
+    "SECURITY.md",
 }
 
 local_sdist_files = {
     ".egg-info",
     ".egg-info/PKG-INFO",
     ".egg-info/SOURCES.txt",
     ".egg-info/dependency_links.txt",
     ".egg-info/not-zip-safe",
     ".egg-info/top_level.txt",
 }
 
 
-def test_build_sdist(monkeypatch, tmpdir):
+def read_tz_file(tar: tarfile.TarFile, name: str) -> bytes:
+    start = tar.getnames()[0] + "/"
+    inner_file = tar.extractfile(tar.getmember(f"{start}{name}"))
+    assert inner_file
+    with contextlib.closing(inner_file) as f:
+        return f.read()
 
+
+def normalize_line_endings(value: bytes) -> bytes:
+    return value.replace(os.linesep.encode("utf-8"), b"\n")
+
+
+def test_build_sdist(monkeypatch, tmpdir):
     monkeypatch.chdir(MAIN_DIR)
 
-    out = subprocess.check_output(
-        [
-            sys.executable,
-            "setup.py",
-            "sdist",
-            "--formats=tar",
-            "--dist-dir",
-            str(tmpdir),
-        ]
+    subprocess.run(
+        [sys.executable, "-m", "build", "--sdist", f"--outdir={tmpdir}"], check=True
     )
-    if hasattr(out, "decode"):
-        out = out.decode()
 
-    (sdist,) = tmpdir.visit("*.tar")
+    (sdist,) = tmpdir.visit("*.tar.gz")
 
-    with tarfile.open(str(sdist)) as tar:
+    with tarfile.open(str(sdist), "r:gz") as tar:
         start = tar.getnames()[0] + "/"
         version = start[9:-1]
         simpler = {n.split("/", 1)[-1] for n in tar.getnames()[1:]}
 
-        with contextlib.closing(
-            tar.extractfile(tar.getmember(start + "setup.py"))
-        ) as f:
-            setup_py = f.read()
-
-        with contextlib.closing(
-            tar.extractfile(tar.getmember(start + "pyproject.toml"))
-        ) as f:
-            pyproject_toml = f.read()
-
-        with contextlib.closing(
-            tar.extractfile(
-                tar.getmember(
-                    start + "pybind11/share/cmake/pybind11/pybind11Config.cmake"
-                )
-            )
-        ) as f:
-            contents = f.read().decode("utf8")
-        assert 'set(pybind11_INCLUDE_DIR "${PACKAGE_PREFIX_DIR}/include")' in contents
+        setup_py = read_tz_file(tar, "setup.py")
+        pyproject_toml = read_tz_file(tar, "pyproject.toml")
+        pkgconfig = read_tz_file(tar, "pybind11/share/pkgconfig/pybind11.pc")
+        cmake_cfg = read_tz_file(
+            tar, "pybind11/share/cmake/pybind11/pybind11Config.cmake"
+        )
+
+    assert (
+        'set(pybind11_INCLUDE_DIR "${PACKAGE_PREFIX_DIR}/include")'
+        in cmake_cfg.decode("utf-8")
+    )
 
-    files = {"pybind11/{}".format(n) for n in all_files}
+    files = {f"pybind11/{n}" for n in all_files}
     files |= sdist_files
-    files |= {"pybind11{}".format(n) for n in local_sdist_files}
+    files |= {f"pybind11{n}" for n in local_sdist_files}
     files.add("pybind11.egg-info/entry_points.txt")
     files.add("pybind11.egg-info/requires.txt")
     assert simpler == files
 
     with open(os.path.join(MAIN_DIR, "tools", "setup_main.py.in"), "rb") as f:
         contents = (
-            string.Template(f.read().decode())
+            string.Template(f.read().decode("utf-8"))
             .substitute(version=version, extra_cmd="")
-            .encode()
+            .encode("utf-8")
         )
     assert setup_py == contents
 
     with open(os.path.join(MAIN_DIR, "tools", "pyproject.toml"), "rb") as f:
         contents = f.read()
     assert pyproject_toml == contents
 
+    simple_version = ".".join(version.split(".")[:3])
+    pkgconfig_expected = PKGCONFIG.format(VERSION=simple_version).encode("utf-8")
+    assert normalize_line_endings(pkgconfig) == pkgconfig_expected
 
-def test_build_global_dist(monkeypatch, tmpdir):
 
+def test_build_global_dist(monkeypatch, tmpdir):
     monkeypatch.chdir(MAIN_DIR)
     monkeypatch.setenv("PYBIND11_GLOBAL_SDIST", "1")
-
-    out = subprocess.check_output(
-        [
-            sys.executable,
-            "setup.py",
-            "sdist",
-            "--formats=tar",
-            "--dist-dir",
-            str(tmpdir),
-        ]
+    subprocess.run(
+        [sys.executable, "-m", "build", "--sdist", "--outdir", str(tmpdir)], check=True
     )
-    if hasattr(out, "decode"):
-        out = out.decode()
 
-    (sdist,) = tmpdir.visit("*.tar")
+    (sdist,) = tmpdir.visit("*.tar.gz")
 
-    with tarfile.open(str(sdist)) as tar:
+    with tarfile.open(str(sdist), "r:gz") as tar:
         start = tar.getnames()[0] + "/"
         version = start[16:-1]
         simpler = {n.split("/", 1)[-1] for n in tar.getnames()[1:]}
 
-        with contextlib.closing(
-            tar.extractfile(tar.getmember(start + "setup.py"))
-        ) as f:
-            setup_py = f.read()
-
-        with contextlib.closing(
-            tar.extractfile(tar.getmember(start + "pyproject.toml"))
-        ) as f:
-            pyproject_toml = f.read()
+        setup_py = read_tz_file(tar, "setup.py")
+        pyproject_toml = read_tz_file(tar, "pyproject.toml")
+        pkgconfig = read_tz_file(tar, "pybind11/share/pkgconfig/pybind11.pc")
+        cmake_cfg = read_tz_file(
+            tar, "pybind11/share/cmake/pybind11/pybind11Config.cmake"
+        )
+
+    assert (
+        'set(pybind11_INCLUDE_DIR "${PACKAGE_PREFIX_DIR}/include")'
+        in cmake_cfg.decode("utf-8")
+    )
 
-    files = {"pybind11/{}".format(n) for n in all_files}
+    files = {f"pybind11/{n}" for n in all_files}
     files |= sdist_files
-    files |= {"pybind11_global{}".format(n) for n in local_sdist_files}
+    files |= {f"pybind11_global{n}" for n in local_sdist_files}
     assert simpler == files
 
     with open(os.path.join(MAIN_DIR, "tools", "setup_global.py.in"), "rb") as f:
         contents = (
             string.Template(f.read().decode())
             .substitute(version=version, extra_cmd="")
-            .encode()
+            .encode("utf-8")
         )
         assert setup_py == contents
 
     with open(os.path.join(MAIN_DIR, "tools", "pyproject.toml"), "rb") as f:
         contents = f.read()
         assert pyproject_toml == contents
 
+    simple_version = ".".join(version.split(".")[:3])
+    pkgconfig_expected = PKGCONFIG.format(VERSION=simple_version).encode("utf-8")
+    assert normalize_line_endings(pkgconfig) == pkgconfig_expected
+
 
 def tests_build_wheel(monkeypatch, tmpdir):
     monkeypatch.chdir(MAIN_DIR)
 
-    subprocess.check_output(
-        [sys.executable, "-m", "pip", "wheel", ".", "-w", str(tmpdir)]
+    subprocess.run(
+        [sys.executable, "-m", "pip", "wheel", ".", "-w", str(tmpdir)], check=True
     )
 
     (wheel,) = tmpdir.visit("*.whl")
 
-    files = {"pybind11/{}".format(n) for n in all_files}
+    files = {f"pybind11/{n}" for n in all_files}
     files |= {
         "dist-info/LICENSE",
         "dist-info/METADATA",
         "dist-info/RECORD",
         "dist-info/WHEEL",
         "dist-info/entry_points.txt",
         "dist-info/top_level.txt",
     }
 
     with zipfile.ZipFile(str(wheel)) as z:
         names = z.namelist()
 
     trimmed = {n for n in names if "dist-info" not in n}
-    trimmed |= {
-        "dist-info/{}".format(n.split("/", 1)[-1]) for n in names if "dist-info" in n
-    }
+    trimmed |= {f"dist-info/{n.split('/', 1)[-1]}" for n in names if "dist-info" in n}
     assert files == trimmed
 
 
 def tests_build_global_wheel(monkeypatch, tmpdir):
     monkeypatch.chdir(MAIN_DIR)
     monkeypatch.setenv("PYBIND11_GLOBAL_SDIST", "1")
 
-    subprocess.check_output(
-        [sys.executable, "-m", "pip", "wheel", ".", "-w", str(tmpdir)]
+    subprocess.run(
+        [sys.executable, "-m", "pip", "wheel", ".", "-w", str(tmpdir)], check=True
     )
 
     (wheel,) = tmpdir.visit("*.whl")
 
-    files = {"data/data/{}".format(n) for n in src_files}
-    files |= {"data/headers/{}".format(n[8:]) for n in headers}
+    files = {f"data/data/{n}" for n in src_files}
+    files |= {f"data/headers/{n[8:]}" for n in headers}
     files |= {
         "dist-info/LICENSE",
         "dist-info/METADATA",
         "dist-info/WHEEL",
         "dist-info/top_level.txt",
         "dist-info/RECORD",
     }
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/extra_setuptools/test_setuphelper.py` & `python_prtree-0.6.1/third/pybind11/tests/extra_setuptools/test_setuphelper.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 import os
 import subprocess
 import sys
 from textwrap import dedent
 
 import pytest
 
@@ -15,15 +14,15 @@
 @pytest.mark.parametrize("std", [11, 0])
 def test_simple_setup_py(monkeypatch, tmpdir, parallel, std):
     monkeypatch.chdir(tmpdir)
     monkeypatch.syspath_prepend(MAIN_DIR)
 
     (tmpdir / "setup.py").write_text(
         dedent(
-            u"""\
+            f"""\
             import sys
             sys.path.append({MAIN_DIR!r})
 
             from setuptools import setup, Extension
             from pybind11.setup_helpers import build_ext, Pybind11Extension
 
             std = {std}
@@ -48,21 +47,21 @@
 
             setup(
                 name="simple_setup_package",
                 cmdclass=cmdclass,
                 ext_modules=ext_modules,
             )
             """
-        ).format(MAIN_DIR=MAIN_DIR, std=std, parallel=parallel),
+        ),
         encoding="ascii",
     )
 
     (tmpdir / "main.cpp").write_text(
         dedent(
-            u"""\
+            """\
             #include <pybind11/pybind11.h>
 
             int f(int x) {
                 return x * 3;
             }
             PYBIND11_MODULE(simple_setup, m) {
                 m.def("f", &f);
@@ -92,15 +91,15 @@
     assert (
         len([f for f in tmpdir.listdir() if f.basename.startswith("simple_setup")]) == 1
     )
     assert len(list(tmpdir.listdir())) == 4  # two files + output + build_dir
 
     (tmpdir / "test.py").write_text(
         dedent(
-            u"""\
+            """\
             import simple_setup
             assert simple_setup.f(3) == 9
             """
         ),
         encoding="ascii",
     )
 
@@ -117,18 +116,19 @@
     monkeypatch.chdir(tmpdir)
     root = tmpdir
     root.ensure_dir()
     subdir = root / "dir"
     subdir.ensure_dir()
     src = subdir / "ext.cpp"
     src.ensure()
-    (ext,) = intree_extensions([src.relto(tmpdir)])
+    relpath = src.relto(tmpdir)
+    (ext,) = intree_extensions([relpath])
     assert ext.name == "ext"
     subdir.ensure("__init__.py")
-    (ext,) = intree_extensions([src.relto(tmpdir)])
+    (ext,) = intree_extensions([relpath])
     assert ext.name == "dir.ext"
 
 
 def test_intree_extensions_package_dir(monkeypatch, tmpdir):
     monkeypatch.syspath_prepend(MAIN_DIR)
 
     from pybind11.setup_helpers import intree_extensions
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/local_bindings.h` & `python_prtree-0.6.1/third/pybind11/tests/local_bindings.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/tests/object.h` & `python_prtree-0.6.1/third/pybind11/tests/object.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/tests/pybind11_cross_module_tests.cpp` & `python_prtree-0.6.1/third/pybind11/tests/pybind11_cross_module_tests.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -27,44 +27,44 @@
     // test_load_external
     bind_local<ExternalType1>(m, "ExternalType1", py::module_local());
     bind_local<ExternalType2>(m, "ExternalType2", py::module_local());
 
     // test_exceptions.py
     py::register_local_exception<LocalSimpleException>(m, "LocalSimpleException");
     m.def("raise_runtime_error", []() {
-        PyErr_SetString(PyExc_RuntimeError, "My runtime error");
+        py::set_error(PyExc_RuntimeError, "My runtime error");
         throw py::error_already_set();
     });
     m.def("raise_value_error", []() {
-        PyErr_SetString(PyExc_ValueError, "My value error");
+        py::set_error(PyExc_ValueError, "My value error");
         throw py::error_already_set();
     });
     m.def("throw_pybind_value_error", []() { throw py::value_error("pybind11 value error"); });
     m.def("throw_pybind_type_error", []() { throw py::type_error("pybind11 type error"); });
     m.def("throw_stop_iteration", []() { throw py::stop_iteration(); });
     m.def("throw_local_error", []() { throw LocalException("just local"); });
     m.def("throw_local_simple_error", []() { throw LocalSimpleException("external mod"); });
     py::register_exception_translator([](std::exception_ptr p) {
         try {
             if (p) {
                 std::rethrow_exception(p);
             }
         } catch (const shared_exception &e) {
-            PyErr_SetString(PyExc_KeyError, e.what());
+            py::set_error(PyExc_KeyError, e.what());
         }
     });
 
     // translate the local exception into a key error but only in this module
     py::register_local_exception_translator([](std::exception_ptr p) {
         try {
             if (p) {
                 std::rethrow_exception(p);
             }
         } catch (const LocalException &e) {
-            PyErr_SetString(PyExc_KeyError, e.what());
+            py::set_error(PyExc_KeyError, e.what());
         }
     });
 
     // test_local_bindings.py
     // Local to both:
     bind_local<LocalType, 1>(m, "LocalType", py::module_local()).def("get2", [](LocalType &t) {
         return t.i + 2;
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/pybind11_tests.cpp` & `python_prtree-0.6.1/third/pybind11/tests/pybind11_tests.cpp`

 * *Files 24% similar despite different names*

```diff
@@ -58,23 +58,60 @@
         // registered instances to allow instance cleanup checks (invokes a GC first)
         .def_static("detail_reg_inst", []() {
             ConstructorStats::gc();
             return py::detail::get_internals().registered_instances.size();
         });
 }
 
+const char *cpp_std() {
+    return
+#if defined(PYBIND11_CPP20)
+        "C++20";
+#elif defined(PYBIND11_CPP17)
+        "C++17";
+#elif defined(PYBIND11_CPP14)
+        "C++14";
+#else
+        "C++11";
+#endif
+}
+
 PYBIND11_MODULE(pybind11_tests, m) {
     m.doc() = "pybind11 test module";
 
+    // Intentionally kept minimal to not create a maintenance chore
+    // ("just enough" to be conclusive).
+#if defined(__VERSION__)
+    m.attr("compiler_info") = __VERSION__;
+#elif defined(_MSC_FULL_VER)
+    m.attr("compiler_info") = "MSVC " PYBIND11_TOSTRING(_MSC_FULL_VER);
+#else
+    m.attr("compiler_info") = py::none();
+#endif
+    m.attr("cpp_std") = cpp_std();
+    m.attr("PYBIND11_INTERNALS_ID") = PYBIND11_INTERNALS_ID;
+    m.attr("PYBIND11_SIMPLE_GIL_MANAGEMENT") =
+#if defined(PYBIND11_SIMPLE_GIL_MANAGEMENT)
+        true;
+#else
+        false;
+#endif
+    m.attr("PYBIND11_NUMPY_1_ONLY") =
+#if defined(PYBIND11_NUMPY_1_ONLY)
+        true;
+#else
+        false;
+#endif
+
     bind_ConstructorStats(m);
 
-#if !defined(NDEBUG)
-    m.attr("debug_enabled") = true;
+#if defined(PYBIND11_DETAILED_ERROR_MESSAGES)
+    m.attr("detailed_error_messages_enabled") = true;
 #else
-    m.attr("debug_enabled") = false;
+    m.attr("detailed_error_messages_enabled") = false;
 #endif
 
     py::class_<UserType>(m, "UserType", "A `py::class_` type for testing")
         .def(py::init<>())
         .def(py::init<int>())
         .def("get_value", &UserType::value, "Get value using a method")
         .def("set_value", &UserType::set, "Set value using a method")
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/pybind11_tests.h` & `python_prtree-0.6.1/third/pybind11/tests/pybind11_tests.h`

 * *Files 20% similar despite different names*

```diff
@@ -1,18 +1,12 @@
 #pragma once
 
 #include <pybind11/eval.h>
 #include <pybind11/pybind11.h>
 
-#if defined(_MSC_VER) && _MSC_VER < 1910
-// We get some really long type names here which causes MSVC 2015 to emit warnings
-#    pragma warning(                                                                              \
-        disable : 4503) // NOLINT: warning C4503: decorated name length exceeded, name was truncated
-#endif
-
 namespace py = pybind11;
 using namespace pybind11::literals;
 
 class test_initializer {
     using Initializer = void (*)(py::module_ &);
 
 public:
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/pytest.ini` & `python_prtree-0.6.1/third/pybind11/tests/pytest.ini`

 * *Files 18% similar despite different names*

```diff
@@ -1,16 +1,19 @@
 [pytest]
-minversion = 3.1
+minversion = 3.10
 norecursedirs = test_* extra_*
 xfail_strict = True
 addopts =
-    # show summary of skipped tests
-    -rs
+    # show summary of tests
+    -ra
     # capture only Python print and C++ py::print, but not C output (low-level Python errors)
     --capture=sys
+    # Show local info when a failure occurs
+    --showlocals
+log_cli_level = info
 filterwarnings =
     # make warnings into errors but ignore certain third-party extension issues
     error
     # somehow, some DeprecationWarnings do not get turned into errors
     always::DeprecationWarning
     # importing scipy submodules on some version of Python
     ignore::ImportWarning
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_async.cpp` & `python_prtree-0.6.1/third/pybind11/tests/test_async.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_async.py` & `python_prtree-0.6.1/third/pybind11/tests/test_async.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,25 +1,24 @@
-# -*- coding: utf-8 -*-
 import pytest
 
 asyncio = pytest.importorskip("asyncio")
 m = pytest.importorskip("pybind11_tests.async_module")
 
 
-@pytest.fixture
+@pytest.fixture()
 def event_loop():
     loop = asyncio.new_event_loop()
     yield loop
     loop.close()
 
 
 async def get_await_result(x):
     return await x
 
 
 def test_await(event_loop):
-    assert 5 == event_loop.run_until_complete(get_await_result(m.SupportsAsync()))
+    assert event_loop.run_until_complete(get_await_result(m.SupportsAsync())) == 5
 
 
 def test_await_missing(event_loop):
     with pytest.raises(TypeError):
         event_loop.run_until_complete(get_await_result(m.DoesNotSupportAsync()))
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_buffers.cpp` & `python_prtree-0.6.1/third/pybind11/tests/test_buffers.cpp`

 * *Files 21% similar despite different names*

```diff
@@ -3,20 +3,55 @@
 
     Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
 
     All rights reserved. Use of this source code is governed by a
     BSD-style license that can be found in the LICENSE file.
 */
 
+#include <pybind11/complex.h>
 #include <pybind11/stl.h>
 
 #include "constructor_stats.h"
 #include "pybind11_tests.h"
 
 TEST_SUBMODULE(buffers, m) {
+    m.attr("long_double_and_double_have_same_size") = (sizeof(long double) == sizeof(double));
+
+    m.def("format_descriptor_format_buffer_info_equiv",
+          [](const std::string &cpp_name, const py::buffer &buffer) {
+              // https://google.github.io/styleguide/cppguide.html#Static_and_Global_Variables
+              static auto *format_table = new std::map<std::string, std::string>;
+              static auto *equiv_table
+                  = new std::map<std::string, bool (py::buffer_info::*)() const>;
+              if (format_table->empty()) {
+#define PYBIND11_ASSIGN_HELPER(...)                                                               \
+    (*format_table)[#__VA_ARGS__] = py::format_descriptor<__VA_ARGS__>::format();                 \
+    (*equiv_table)[#__VA_ARGS__] = &py::buffer_info::item_type_is_equivalent_to<__VA_ARGS__>;
+                  PYBIND11_ASSIGN_HELPER(PyObject *)
+                  PYBIND11_ASSIGN_HELPER(bool)
+                  PYBIND11_ASSIGN_HELPER(std::int8_t)
+                  PYBIND11_ASSIGN_HELPER(std::uint8_t)
+                  PYBIND11_ASSIGN_HELPER(std::int16_t)
+                  PYBIND11_ASSIGN_HELPER(std::uint16_t)
+                  PYBIND11_ASSIGN_HELPER(std::int32_t)
+                  PYBIND11_ASSIGN_HELPER(std::uint32_t)
+                  PYBIND11_ASSIGN_HELPER(std::int64_t)
+                  PYBIND11_ASSIGN_HELPER(std::uint64_t)
+                  PYBIND11_ASSIGN_HELPER(float)
+                  PYBIND11_ASSIGN_HELPER(double)
+                  PYBIND11_ASSIGN_HELPER(long double)
+                  PYBIND11_ASSIGN_HELPER(std::complex<float>)
+                  PYBIND11_ASSIGN_HELPER(std::complex<double>)
+                  PYBIND11_ASSIGN_HELPER(std::complex<long double>)
+#undef PYBIND11_ASSIGN_HELPER
+              }
+              return std::pair<std::string, bool>(
+                  (*format_table)[cpp_name], (buffer.request().*((*equiv_table)[cpp_name]))());
+          });
+
     // test_from_python / test_to_python:
     class Matrix {
     public:
         Matrix(py::ssize_t rows, py::ssize_t cols) : m_rows(rows), m_cols(cols) {
             print_created(this, std::to_string(m_rows) + "x" + std::to_string(m_cols) + " matrix");
             // NOLINTNEXTLINE(cppcoreguidelines-prefer-member-initializer)
             m_data = new float[(size_t) (rows * cols)];
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_buffers.py` & `python_prtree-0.6.1/third/pybind11/tests/test_buffers.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,20 +1,76 @@
-# -*- coding: utf-8 -*-
 import ctypes
 import io
 import struct
 
 import pytest
 
 import env
 from pybind11_tests import ConstructorStats
 from pybind11_tests import buffers as m
 
 np = pytest.importorskip("numpy")
 
+if m.long_double_and_double_have_same_size:
+    # Determined by the compiler used to build the pybind11 tests
+    # (e.g. MSVC gets here, but MinGW might not).
+    np_float128 = None
+    np_complex256 = None
+else:
+    # Determined by the compiler used to build numpy (e.g. MinGW).
+    np_float128 = getattr(np, *["float128"] * 2)
+    np_complex256 = getattr(np, *["complex256"] * 2)
+
+CPP_NAME_FORMAT_NP_DTYPE_TABLE = [
+    ("PyObject *", "O", object),
+    ("bool", "?", np.bool_),
+    ("std::int8_t", "b", np.int8),
+    ("std::uint8_t", "B", np.uint8),
+    ("std::int16_t", "h", np.int16),
+    ("std::uint16_t", "H", np.uint16),
+    ("std::int32_t", "i", np.int32),
+    ("std::uint32_t", "I", np.uint32),
+    ("std::int64_t", "q", np.int64),
+    ("std::uint64_t", "Q", np.uint64),
+    ("float", "f", np.float32),
+    ("double", "d", np.float64),
+    ("long double", "g", np_float128),
+    ("std::complex<float>", "Zf", np.complex64),
+    ("std::complex<double>", "Zd", np.complex128),
+    ("std::complex<long double>", "Zg", np_complex256),
+]
+CPP_NAME_FORMAT_TABLE = [
+    (cpp_name, format)
+    for cpp_name, format, np_dtype in CPP_NAME_FORMAT_NP_DTYPE_TABLE
+    if np_dtype is not None
+]
+CPP_NAME_NP_DTYPE_TABLE = [
+    (cpp_name, np_dtype) for cpp_name, _, np_dtype in CPP_NAME_FORMAT_NP_DTYPE_TABLE
+]
+
+
+@pytest.mark.parametrize(("cpp_name", "np_dtype"), CPP_NAME_NP_DTYPE_TABLE)
+def test_format_descriptor_format_buffer_info_equiv(cpp_name, np_dtype):
+    if np_dtype is None:
+        pytest.skip(
+            f"cpp_name=`{cpp_name}`: `long double` and `double` have same size."
+        )
+    if isinstance(np_dtype, str):
+        pytest.skip(f"np.{np_dtype} does not exist.")
+    np_array = np.array([], dtype=np_dtype)
+    for other_cpp_name, expected_format in CPP_NAME_FORMAT_TABLE:
+        format, np_array_is_matching = m.format_descriptor_format_buffer_info_equiv(
+            other_cpp_name, np_array
+        )
+        assert format == expected_format
+        if other_cpp_name == cpp_name:
+            assert np_array_is_matching
+        else:
+            assert not np_array_is_matching
+
 
 def test_from_python():
     with pytest.raises(RuntimeError) as excinfo:
         m.Matrix(np.array([1, 2, 3]))  # trying to assign a 1D array
     assert str(excinfo.value) == "Incompatible buffer format!"
 
     m3 = np.array([[1, 2, 3], [4, 5, 6]]).astype(np.float32)
@@ -51,15 +107,16 @@
     assert mat[3, 2] == 7
     assert struct.unpack_from("f", mat, (3 * 4 + 2) * 4) == (7,)
     assert struct.unpack_from("f", mat, (2 * 4 + 3) * 4) == (4,)
 
     mat2 = np.array(mat, copy=False)
     assert mat2.shape == (5, 4)
     assert abs(mat2).sum() == 11
-    assert mat2[2, 3] == 4 and mat2[3, 2] == 7
+    assert mat2[2, 3] == 4
+    assert mat2[3, 2] == 7
     mat2[2, 3] = 5
     assert mat2[2, 3] == 5
 
     cstats = ConstructorStats.get(m.Matrix)
     assert cstats.alive() == 1
     del mat
     pytest.gc_collect()
@@ -89,32 +146,32 @@
         value = struct.unpack("i", bytearray(buf))[0]
         assert value == 0x12345678
 
 
 def test_readonly_buffer():
     buf = m.BufferReadOnly(0x64)
     view = memoryview(buf)
-    assert view[0] == b"d" if env.PY2 else 0x64
+    assert view[0] == 0x64
     assert view.readonly
     with pytest.raises(TypeError):
-        view[0] = b"\0" if env.PY2 else 0
+        view[0] = 0
 
 
 def test_selective_readonly_buffer():
     buf = m.BufferReadOnlySelect()
 
-    memoryview(buf)[0] = b"d" if env.PY2 else 0x64
+    memoryview(buf)[0] = 0x64
     assert buf.value == 0x64
 
     io.BytesIO(b"A").readinto(buf)
     assert buf.value == ord(b"A")
 
     buf.readonly = True
     with pytest.raises(TypeError):
-        memoryview(buf)[0] = b"\0" if env.PY2 else 0
+        memoryview(buf)[0] = 0
     with pytest.raises(TypeError):
         io.BytesIO(b"1").readinto(buf)
 
 
 def test_ctypes_array_1d():
     char1d = (ctypes.c_char * 10)()
     int1d = (ctypes.c_int * 15)()
@@ -141,17 +198,14 @@
         assert info.size == len(carray) * len(carray[0])
         assert info.ndim == 2
         assert info.shape == [len(carray), len(carray[0])]
         assert info.strides == [info.itemsize * len(carray[0]), info.itemsize]
         assert not info.readonly
 
 
-@pytest.mark.skipif(
-    "env.PYPY and env.PY2", reason="PyPy2 bytes buffer not reported as readonly"
-)
 def test_ctypes_from_buffer():
     test_pystr = b"0123456789"
     for pyarray in (test_pystr, bytearray(test_pystr)):
         pyinfo = m.get_buffer_info(pyarray)
 
         if pyinfo.readonly:
             cbytes = (ctypes.c_char * len(pyarray)).from_buffer_copy(pyarray)
@@ -161,7 +215,14 @@
             cinfo = m.get_buffer_info(cbytes)
 
         assert cinfo.size == pyinfo.size
         assert cinfo.ndim == pyinfo.ndim
         assert cinfo.shape == pyinfo.shape
         assert cinfo.strides == pyinfo.strides
         assert not cinfo.readonly
+
+
+def test_buffer_docstring():
+    assert (
+        m.get_buffer_info.__doc__.strip()
+        == "get_buffer_info(arg0: Buffer) -> pybind11_tests.buffers.buffer_info"
+    )
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_builtin_casters.cpp` & `python_prtree-0.6.1/third/pybind11/tests/test_builtin_casters.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -69,28 +69,31 @@
 private:
     ConstRefCasted value = {0};
 };
 PYBIND11_NAMESPACE_END(detail)
 PYBIND11_NAMESPACE_END(pybind11)
 
 TEST_SUBMODULE(builtin_casters, m) {
+    PYBIND11_WARNING_PUSH
+    PYBIND11_WARNING_DISABLE_MSVC(4127)
+
     // test_simple_string
     m.def("string_roundtrip", [](const char *s) { return s; });
 
     // test_unicode_conversion
     // Some test characters in utf16 and utf32 encodings.  The last one (the ) contains a null
     // byte
     char32_t a32 = 0x61 /*a*/, z32 = 0x7a /*z*/, ib32 = 0x203d /**/, cake32 = 0x1f382 /**/,
              mathbfA32 = 0x1d400 /**/;
     char16_t b16 = 0x62 /*b*/, z16 = 0x7a, ib16 = 0x203d, cake16_1 = 0xd83c, cake16_2 = 0xdf82,
              mathbfA16_1 = 0xd835, mathbfA16_2 = 0xdc00;
     std::wstring wstr;
     wstr.push_back(0x61);   // a
     wstr.push_back(0x2e18); // 
-    if (PYBIND11_SILENCE_MSVC_C4127(sizeof(wchar_t) == 2)) {
+    if (sizeof(wchar_t) == 2) {
         wstr.push_back(mathbfA16_1);
         wstr.push_back(mathbfA16_2);
     } // , utf16
     else {
         wstr.push_back((wchar_t) mathbfA32);
     }                     // , utf32
     wstr.push_back(0x7a); // z
@@ -106,24 +109,22 @@
     });                                                 // az
     m.def("good_wchar_string", [=]() { return wstr; }); // az
     m.def("bad_utf8_string", []() {
         return std::string("abc\xd0"
                            "def");
     });
     m.def("bad_utf16_string", [=]() { return std::u16string({b16, char16_t(0xd800), z16}); });
-#if PY_MAJOR_VERSION >= 3
-    // Under Python 2.7, invalid unicode UTF-32 characters don't appear to trigger
+    // Under Python 2.7, invalid unicode UTF-32 characters didn't appear to trigger
     // UnicodeDecodeError
     m.def("bad_utf32_string", [=]() { return std::u32string({a32, char32_t(0xd800), z32}); });
-    if (PYBIND11_SILENCE_MSVC_C4127(sizeof(wchar_t) == 2)) {
+    if (sizeof(wchar_t) == 2) {
         m.def("bad_wchar_string", [=]() {
             return std::wstring({wchar_t(0x61), wchar_t(0xd800)});
         });
     }
-#endif
     m.def("u8_Z", []() -> char { return 'Z'; });
     m.def("u8_eacute", []() -> char { return '\xe9'; });
     m.def("u16_ibang", [=]() -> char16_t { return ib16; });
     m.def("u32_mathbfA", [=]() -> char32_t { return mathbfA32; });
     m.def("wchar_heart", []() -> wchar_t { return 0x2665; });
 
     // test_single_char_arguments
@@ -194,20 +195,18 @@
     using namespace std::literals;
     m.def("string_view_bytes",
           []() { return [](py::bytes b) { return b; }("abc \x80\x80 def"sv); });
     m.def("string_view_str",
           []() { return [](py::str s) { return s; }("abc \342\200\275 def"sv); });
     m.def("string_view_from_bytes",
           [](const py::bytes &b) { return [](std::string_view s) { return s; }(b); });
-#    if PY_MAJOR_VERSION >= 3
     m.def("string_view_memoryview", []() {
         static constexpr auto val = "Have some \360\237\216\202"sv;
         return py::memoryview::from_memory(val);
     });
-#    endif
 
 #    ifdef PYBIND11_HAS_U8STRING
     m.def("string_view8_print", [](std::u8string_view s) { py::print(s, s.size()); });
     m.def("string_view8_chars", [](std::u8string_view s) {
         py::list l;
         for (auto c : s)
             l.append((std::uint8_t) c);
@@ -266,16 +265,22 @@
     m.def("rvalue_nested", []() {
         return std::make_pair(
             RValueCaster{},
             std::make_tuple(RValueCaster{}, std::make_pair(RValueCaster{}, RValueCaster{})));
     });
     m.def("lvalue_nested", []() -> const decltype(lvnested) & { return lvnested; });
 
-    static std::pair<int, std::string> int_string_pair{2, "items"};
-    m.def("int_string_pair", []() { return &int_string_pair; });
+    m.def(
+        "int_string_pair",
+        []() {
+            // Using no-destructor idiom to side-step warnings from overzealous compilers.
+            static auto *int_string_pair = new std::pair<int, std::string>{2, "items"};
+            return int_string_pair;
+        },
+        py::return_value_policy::reference);
 
     // test_builtins_cast_return_none
     m.def("return_none_string", []() -> std::string * { return nullptr; });
     m.def("return_none_char", []() -> const char * { return nullptr; });
     m.def("return_none_bool", []() -> bool * { return nullptr; });
     m.def("return_none_int", []() -> int * { return nullptr; });
     m.def("return_none_float", []() -> float * { return nullptr; });
@@ -378,8 +383,10 @@
     m.def("takes_ptr", [](ConstRefCasted *x) { return x->tag; });
     m.def("takes_ref", [](ConstRefCasted &x) { return x.tag; });
     m.def("takes_ref_wrap", [](std::reference_wrapper<ConstRefCasted> x) { return x.get().tag; });
     m.def("takes_const_ptr", [](const ConstRefCasted *x) { return x->tag; });
     m.def("takes_const_ref", [](const ConstRefCasted &x) { return x.tag; });
     m.def("takes_const_ref_wrap",
           [](std::reference_wrapper<const ConstRefCasted> x) { return x.get().tag; });
+
+    PYBIND11_WARNING_POP
 }
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_builtin_casters.py` & `python_prtree-0.6.1/third/pybind11/tests/test_builtin_casters.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,301 +1,285 @@
-# -*- coding: utf-8 -*-
+import sys
+
 import pytest
 
 import env
 from pybind11_tests import IncType, UserType
 from pybind11_tests import builtin_casters as m
 
 
 def test_simple_string():
     assert m.string_roundtrip("const char *") == "const char *"
 
 
 def test_unicode_conversion():
     """Tests unicode conversion and error reporting."""
-    assert m.good_utf8_string() == u"Say utf8  "
-    assert m.good_utf16_string() == u"bz"
-    assert m.good_utf32_string() == u"az"
-    assert m.good_wchar_string() == u"az"
+    assert m.good_utf8_string() == "Say utf8  "
+    assert m.good_utf16_string() == "bz"
+    assert m.good_utf32_string() == "az"
+    assert m.good_wchar_string() == "az"
     if hasattr(m, "has_u8string"):
-        assert m.good_utf8_u8string() == u"Say utf8  "
+        assert m.good_utf8_u8string() == "Say utf8  "
 
     with pytest.raises(UnicodeDecodeError):
         m.bad_utf8_string()
 
     with pytest.raises(UnicodeDecodeError):
         m.bad_utf16_string()
 
-    # These are provided only if they actually fail (they don't when 32-bit and under Python 2.7)
+    # These are provided only if they actually fail (they don't when 32-bit)
     if hasattr(m, "bad_utf32_string"):
         with pytest.raises(UnicodeDecodeError):
             m.bad_utf32_string()
     if hasattr(m, "bad_wchar_string"):
         with pytest.raises(UnicodeDecodeError):
             m.bad_wchar_string()
     if hasattr(m, "has_u8string"):
         with pytest.raises(UnicodeDecodeError):
             m.bad_utf8_u8string()
 
     assert m.u8_Z() == "Z"
-    assert m.u8_eacute() == u""
-    assert m.u16_ibang() == u""
-    assert m.u32_mathbfA() == u""
-    assert m.wchar_heart() == u""
+    assert m.u8_eacute() == ""
+    assert m.u16_ibang() == ""
+    assert m.u32_mathbfA() == ""
+    assert m.wchar_heart() == ""
     if hasattr(m, "has_u8string"):
         assert m.u8_char8_Z() == "Z"
 
 
 def test_single_char_arguments():
     """Tests failures for passing invalid inputs to char-accepting functions"""
 
     def toobig_message(r):
-        return "Character code point not in range({:#x})".format(r)
+        return f"Character code point not in range({r:#x})"
 
     toolong_message = "Expected a character, but multi-character string found"
 
-    assert m.ord_char(u"a") == 0x61  # simple ASCII
-    assert m.ord_char_lv(u"b") == 0x62
+    assert m.ord_char("a") == 0x61  # simple ASCII
+    assert m.ord_char_lv("b") == 0x62
     assert (
-        m.ord_char(u"") == 0xE9
+        m.ord_char("") == 0xE9
     )  # requires 2 bytes in utf-8, but can be stuffed in a char
     with pytest.raises(ValueError) as excinfo:
-        assert m.ord_char(u"") == 0x100  # requires 2 bytes, doesn't fit in a char
+        assert m.ord_char("") == 0x100  # requires 2 bytes, doesn't fit in a char
     assert str(excinfo.value) == toobig_message(0x100)
     with pytest.raises(ValueError) as excinfo:
-        assert m.ord_char(u"ab")
+        assert m.ord_char("ab")
     assert str(excinfo.value) == toolong_message
 
-    assert m.ord_char16(u"a") == 0x61
-    assert m.ord_char16(u"") == 0xE9
-    assert m.ord_char16_lv(u"") == 0xEA
-    assert m.ord_char16(u"") == 0x100
-    assert m.ord_char16(u"") == 0x203D
-    assert m.ord_char16(u"") == 0x2665
-    assert m.ord_char16_lv(u"") == 0x2661
+    assert m.ord_char16("a") == 0x61
+    assert m.ord_char16("") == 0xE9
+    assert m.ord_char16_lv("") == 0xEA
+    assert m.ord_char16("") == 0x100
+    assert m.ord_char16("") == 0x203D
+    assert m.ord_char16("") == 0x2665
+    assert m.ord_char16_lv("") == 0x2661
     with pytest.raises(ValueError) as excinfo:
-        assert m.ord_char16(u"") == 0x1F382  # requires surrogate pair
+        assert m.ord_char16("") == 0x1F382  # requires surrogate pair
     assert str(excinfo.value) == toobig_message(0x10000)
     with pytest.raises(ValueError) as excinfo:
-        assert m.ord_char16(u"aa")
+        assert m.ord_char16("aa")
     assert str(excinfo.value) == toolong_message
 
-    assert m.ord_char32(u"a") == 0x61
-    assert m.ord_char32(u"") == 0xE9
-    assert m.ord_char32(u"") == 0x100
-    assert m.ord_char32(u"") == 0x203D
-    assert m.ord_char32(u"") == 0x2665
-    assert m.ord_char32(u"") == 0x1F382
+    assert m.ord_char32("a") == 0x61
+    assert m.ord_char32("") == 0xE9
+    assert m.ord_char32("") == 0x100
+    assert m.ord_char32("") == 0x203D
+    assert m.ord_char32("") == 0x2665
+    assert m.ord_char32("") == 0x1F382
     with pytest.raises(ValueError) as excinfo:
-        assert m.ord_char32(u"aa")
+        assert m.ord_char32("aa")
     assert str(excinfo.value) == toolong_message
 
-    assert m.ord_wchar(u"a") == 0x61
-    assert m.ord_wchar(u"") == 0xE9
-    assert m.ord_wchar(u"") == 0x100
-    assert m.ord_wchar(u"") == 0x203D
-    assert m.ord_wchar(u"") == 0x2665
+    assert m.ord_wchar("a") == 0x61
+    assert m.ord_wchar("") == 0xE9
+    assert m.ord_wchar("") == 0x100
+    assert m.ord_wchar("") == 0x203D
+    assert m.ord_wchar("") == 0x2665
     if m.wchar_size == 2:
         with pytest.raises(ValueError) as excinfo:
-            assert m.ord_wchar(u"") == 0x1F382  # requires surrogate pair
+            assert m.ord_wchar("") == 0x1F382  # requires surrogate pair
         assert str(excinfo.value) == toobig_message(0x10000)
     else:
-        assert m.ord_wchar(u"") == 0x1F382
+        assert m.ord_wchar("") == 0x1F382
     with pytest.raises(ValueError) as excinfo:
-        assert m.ord_wchar(u"aa")
+        assert m.ord_wchar("aa")
     assert str(excinfo.value) == toolong_message
 
     if hasattr(m, "has_u8string"):
-        assert m.ord_char8(u"a") == 0x61  # simple ASCII
-        assert m.ord_char8_lv(u"b") == 0x62
+        assert m.ord_char8("a") == 0x61  # simple ASCII
+        assert m.ord_char8_lv("b") == 0x62
         assert (
-            m.ord_char8(u"") == 0xE9
+            m.ord_char8("") == 0xE9
         )  # requires 2 bytes in utf-8, but can be stuffed in a char
         with pytest.raises(ValueError) as excinfo:
-            assert m.ord_char8(u"") == 0x100  # requires 2 bytes, doesn't fit in a char
+            assert m.ord_char8("") == 0x100  # requires 2 bytes, doesn't fit in a char
         assert str(excinfo.value) == toobig_message(0x100)
         with pytest.raises(ValueError) as excinfo:
-            assert m.ord_char8(u"ab")
+            assert m.ord_char8("ab")
         assert str(excinfo.value) == toolong_message
 
 
 def test_bytes_to_string():
     """Tests the ability to pass bytes to C++ string-accepting functions.  Note that this is
     one-way: the only way to return bytes to Python is via the pybind11::bytes class."""
     # Issue #816
 
-    def to_bytes(s):
-        b = s if env.PY2 else s.encode("utf8")
-        assert isinstance(b, bytes)
-        return b
-
-    assert m.strlen(to_bytes("hi")) == 2
-    assert m.string_length(to_bytes("world")) == 5
-    assert m.string_length(to_bytes("a\x00b")) == 3
-    assert m.strlen(to_bytes("a\x00b")) == 1  # C-string limitation
+    assert m.strlen(b"hi") == 2
+    assert m.string_length(b"world") == 5
+    assert m.string_length(b"a\x00b") == 3
+    assert m.strlen(b"a\x00b") == 1  # C-string limitation
 
     # passing in a utf8 encoded string should work
-    assert m.string_length(u"".encode("utf8")) == 4
+    assert m.string_length("".encode()) == 4
+
+
+def test_bytearray_to_string():
+    """Tests the ability to pass bytearray to C++ string-accepting functions"""
+    assert m.string_length(bytearray(b"Hi")) == 2
+    assert m.strlen(bytearray(b"bytearray")) == 9
+    assert m.string_length(bytearray()) == 0
+    assert m.string_length(bytearray("", "utf-8", "strict")) == 4
+    assert m.string_length(bytearray(b"\x80")) == 1
 
 
 @pytest.mark.skipif(not hasattr(m, "has_string_view"), reason="no <string_view>")
 def test_string_view(capture):
     """Tests support for C++17 string_view arguments and return values"""
     assert m.string_view_chars("Hi") == [72, 105]
     assert m.string_view_chars("Hi ") == [72, 105, 32, 0xF0, 0x9F, 0x8E, 0x82]
-    assert m.string_view16_chars(u"Hi ") == [72, 105, 32, 0xD83C, 0xDF82]
-    assert m.string_view32_chars(u"Hi ") == [72, 105, 32, 127874]
+    assert m.string_view16_chars("Hi ") == [72, 105, 32, 0xD83C, 0xDF82]
+    assert m.string_view32_chars("Hi ") == [72, 105, 32, 127874]
     if hasattr(m, "has_u8string"):
         assert m.string_view8_chars("Hi") == [72, 105]
-        assert m.string_view8_chars(u"Hi ") == [72, 105, 32, 0xF0, 0x9F, 0x8E, 0x82]
+        assert m.string_view8_chars("Hi ") == [72, 105, 32, 0xF0, 0x9F, 0x8E, 0x82]
 
-    assert m.string_view_return() == u"utf8 secret "
-    assert m.string_view16_return() == u"utf16 secret "
-    assert m.string_view32_return() == u"utf32 secret "
+    assert m.string_view_return() == "utf8 secret "
+    assert m.string_view16_return() == "utf16 secret "
+    assert m.string_view32_return() == "utf32 secret "
     if hasattr(m, "has_u8string"):
-        assert m.string_view8_return() == u"utf8 secret "
+        assert m.string_view8_return() == "utf8 secret "
 
     with capture:
         m.string_view_print("Hi")
         m.string_view_print("utf8 ")
-        m.string_view16_print(u"utf16 ")
-        m.string_view32_print(u"utf32 ")
+        m.string_view16_print("utf16 ")
+        m.string_view32_print("utf32 ")
     assert (
         capture
-        == u"""
+        == """
         Hi 2
         utf8  9
         utf16  8
         utf32  7
     """
     )
     if hasattr(m, "has_u8string"):
         with capture:
             m.string_view8_print("Hi")
-            m.string_view8_print(u"utf8 ")
+            m.string_view8_print("utf8 ")
         assert (
             capture
-            == u"""
+            == """
             Hi 2
             utf8  9
         """
         )
 
     with capture:
         m.string_view_print("Hi, ascii")
         m.string_view_print("Hi, utf8 ")
-        m.string_view16_print(u"Hi, utf16 ")
-        m.string_view32_print(u"Hi, utf32 ")
+        m.string_view16_print("Hi, utf16 ")
+        m.string_view32_print("Hi, utf32 ")
     assert (
         capture
-        == u"""
+        == """
         Hi, ascii 9
         Hi, utf8  13
         Hi, utf16  12
         Hi, utf32  11
     """
     )
     if hasattr(m, "has_u8string"):
         with capture:
             m.string_view8_print("Hi, ascii")
-            m.string_view8_print(u"Hi, utf8 ")
+            m.string_view8_print("Hi, utf8 ")
         assert (
             capture
-            == u"""
+            == """
             Hi, ascii 9
             Hi, utf8  13
         """
         )
 
     assert m.string_view_bytes() == b"abc \x80\x80 def"
-    assert m.string_view_str() == u"abc  def"
-    assert m.string_view_from_bytes(u"abc  def".encode("utf-8")) == u"abc  def"
+    assert m.string_view_str() == "abc  def"
+    assert m.string_view_from_bytes("abc  def".encode()) == "abc  def"
     if hasattr(m, "has_u8string"):
-        assert m.string_view8_str() == u"abc  def"
-    if not env.PY2:
-        assert m.string_view_memoryview() == "Have some ".encode()
+        assert m.string_view8_str() == "abc  def"
+    assert m.string_view_memoryview() == "Have some ".encode()
 
     assert m.bytes_from_type_with_both_operator_string_and_string_view() == b"success"
     assert m.str_from_type_with_both_operator_string_and_string_view() == "success"
 
 
 def test_integer_casting():
     """Issue #929 - out-of-range integer values shouldn't be accepted"""
     assert m.i32_str(-1) == "-1"
     assert m.i64_str(-1) == "-1"
     assert m.i32_str(2000000000) == "2000000000"
     assert m.u32_str(2000000000) == "2000000000"
-    if env.PY2:
-        assert m.i32_str(long(-1)) == "-1"  # noqa: F821 undefined name 'long'
-        assert m.i64_str(long(-1)) == "-1"  # noqa: F821 undefined name 'long'
-        assert (
-            m.i64_str(long(-999999999999))  # noqa: F821 undefined name 'long'
-            == "-999999999999"
-        )
-        assert (
-            m.u64_str(long(999999999999))  # noqa: F821 undefined name 'long'
-            == "999999999999"
-        )
-    else:
-        assert m.i64_str(-999999999999) == "-999999999999"
-        assert m.u64_str(999999999999) == "999999999999"
+    assert m.i64_str(-999999999999) == "-999999999999"
+    assert m.u64_str(999999999999) == "999999999999"
 
     with pytest.raises(TypeError) as excinfo:
         m.u32_str(-1)
     assert "incompatible function arguments" in str(excinfo.value)
     with pytest.raises(TypeError) as excinfo:
         m.u64_str(-1)
     assert "incompatible function arguments" in str(excinfo.value)
     with pytest.raises(TypeError) as excinfo:
         m.i32_str(-3000000000)
     assert "incompatible function arguments" in str(excinfo.value)
     with pytest.raises(TypeError) as excinfo:
         m.i32_str(3000000000)
     assert "incompatible function arguments" in str(excinfo.value)
 
-    if env.PY2:
-        with pytest.raises(TypeError) as excinfo:
-            m.u32_str(long(-1))  # noqa: F821 undefined name 'long'
-        assert "incompatible function arguments" in str(excinfo.value)
-        with pytest.raises(TypeError) as excinfo:
-            m.u64_str(long(-1))  # noqa: F821 undefined name 'long'
-        assert "incompatible function arguments" in str(excinfo.value)
-
 
 def test_int_convert():
-    class Int(object):
+    class Int:
         def __int__(self):
             return 42
 
-    class NotInt(object):
+    class NotInt:
         pass
 
-    class Float(object):
+    class Float:
         def __float__(self):
             return 41.99999
 
-    class Index(object):
+    class Index:
         def __index__(self):
             return 42
 
-    class IntAndIndex(object):
+    class IntAndIndex:
         def __int__(self):
             return 42
 
         def __index__(self):
             return 0
 
-    class RaisingTypeErrorOnIndex(object):
+    class RaisingTypeErrorOnIndex:
         def __index__(self):
             raise TypeError
 
         def __int__(self):
             return 42
 
-    class RaisingValueErrorOnIndex(object):
+    class RaisingValueErrorOnIndex:
         def __index__(self):
             raise ValueError
 
         def __int__(self):
             return 42
 
     convert, noconvert = m.int_passthrough, m.int_passthrough_noconvert
@@ -307,15 +291,15 @@
         pytest.raises(TypeError, convert, v)
 
     assert convert(7) == 7
     assert noconvert(7) == 7
     cant_convert(3.14159)
     # TODO: Avoid DeprecationWarning in `PyLong_AsLong` (and similar)
     # TODO: PyPy 3.8 does not behave like CPython 3.8 here yet (7.3.7)
-    if (3, 8) <= env.PY < (3, 10) and env.CPYTHON:
+    if (3, 8) <= sys.version_info < (3, 10) and env.CPYTHON:
         with env.deprecated_call():
             assert convert(Int()) == 42
     else:
         assert convert(Int()) == 42
     requires_conversion(Int())
     cant_convert(NotInt())
     cant_convert(Float())
@@ -344,15 +328,15 @@
     assert convert(np.intc(42)) == 42
     assert noconvert(np.intc(42)) == 42
 
     # The implicit conversion from np.float32 is undesirable but currently accepted.
     # TODO: Avoid DeprecationWarning in `PyLong_AsLong` (and similar)
     # TODO: PyPy 3.8 does not behave like CPython 3.8 here yet (7.3.7)
     # https://github.com/pybind/pybind11/issues/3408
-    if (3, 8) <= env.PY < (3, 10) and env.CPYTHON:
+    if (3, 8) <= sys.version_info < (3, 10) and env.CPYTHON:
         with env.deprecated_call():
             assert convert(np.float32(3.14159)) == 3
     else:
         assert convert(np.float32(3.14159)) == 3
     require_implicit(np.float32(3.14159))
 
 
@@ -364,23 +348,23 @@
     assert m.pair_passthrough([True, "test"]) == ("test", True)
     assert m.tuple_passthrough([True, "test", 5]) == (5, "test", True)
     assert m.empty_tuple() == ()
 
     assert (
         doc(m.pair_passthrough)
         == """
-        pair_passthrough(arg0: Tuple[bool, str]) -> Tuple[str, bool]
+        pair_passthrough(arg0: tuple[bool, str]) -> tuple[str, bool]
 
         Return a pair in reversed order
     """
     )
     assert (
         doc(m.tuple_passthrough)
         == """
-        tuple_passthrough(arg0: Tuple[bool, str, int]) -> Tuple[int, str, bool]
+        tuple_passthrough(arg0: tuple[bool, str, int]) -> tuple[int, str, bool]
 
         Return a triple in reversed order
     """
     )
 
     assert m.rvalue_pair() == ("rvalue", "rvalue")
     assert m.lvalue_pair() == ("lvalue", "lvalue")
@@ -433,21 +417,23 @@
     assert m.refwrap_lvalue().value == 1
     assert m.refwrap_lvalue_const().value == 1
 
     a1 = m.refwrap_list(copy=True)
     a2 = m.refwrap_list(copy=True)
     assert [x.value for x in a1] == [2, 3]
     assert [x.value for x in a2] == [2, 3]
-    assert not a1[0] is a2[0] and not a1[1] is a2[1]
+    assert a1[0] is not a2[0]
+    assert a1[1] is not a2[1]
 
     b1 = m.refwrap_list(copy=False)
     b2 = m.refwrap_list(copy=False)
     assert [x.value for x in b1] == [1, 2]
     assert [x.value for x in b2] == [1, 2]
-    assert b1[0] is b2[0] and b1[1] is b2[1]
+    assert b1[0] is b2[0]
+    assert b1[1] is b2[1]
 
     assert m.refwrap_iiw(IncType(5)) == 5
     assert m.refwrap_call_iiw(IncType(10), m.refwrap_iiw) == [10, 10, 10, 10]
 
 
 def test_complex_cast():
     """std::complex casts"""
@@ -471,25 +457,25 @@
     assert noconvert(True) is True
     assert noconvert(False) is False
 
     # None requires implicit conversion
     require_implicit(None)
     assert convert(None) is False
 
-    class A(object):
+    class A:
         def __init__(self, x):
             self.x = x
 
         def __nonzero__(self):
             return self.x
 
         def __bool__(self):
             return self.x
 
-    class B(object):
+    class B:
         pass
 
     # Arbitrary objects are not accepted
     cant_convert(object())
     cant_convert(B())
 
     # Objects with __nonzero__ / __bool__ defined can be converted
@@ -511,25 +497,17 @@
     assert convert(np.bool_(False)) is False
     assert noconvert(np.bool_(True)) is True
     assert noconvert(np.bool_(False)) is False
     cant_convert(np.zeros(2, dtype="int"))
 
 
 def test_int_long():
-    """In Python 2, a C++ int should return a Python int rather than long
-    if possible: longs are not always accepted where ints are used (such
-    as the argument to sys.exit()). A C++ long long is always a Python
-    long."""
-
-    import sys
-
-    must_be_long = type(getattr(sys, "maxint", 1) + 1)
     assert isinstance(m.int_cast(), int)
     assert isinstance(m.long_cast(), int)
-    assert isinstance(m.longlong_cast(), must_be_long)
+    assert isinstance(m.longlong_cast(), int)
 
 
 def test_void_caster_2():
     assert m.test_void_caster()
 
 
 def test_const_ref_caster():
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_call_policies.cpp` & `python_prtree-0.6.1/third/pybind11/tests/test_call_policies.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_call_policies.py` & `python_prtree-0.6.1/third/pybind11/tests/test_call_policies.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 import pytest
 
 import env  # noqa: F401
 from pybind11_tests import ConstructorStats
 from pybind11_tests import call_policies as m
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_callbacks.cpp` & `python_prtree-0.6.1/third/pybind11/tests/test_callbacks.cpp`

 * *Files 14% similar despite different names*

```diff
@@ -236,8 +236,45 @@
     });
 
     m.def("callback_num_times", [](const py::function &f, std::size_t num) {
         for (std::size_t i = 0; i < num; i++) {
             f();
         }
     });
+
+    auto *custom_def = []() {
+        static PyMethodDef def;
+        def.ml_name = "example_name";
+        def.ml_doc = "Example doc";
+        def.ml_meth = [](PyObject *, PyObject *args) -> PyObject * {
+            if (PyTuple_Size(args) != 1) {
+                throw std::runtime_error("Invalid number of arguments for example_name");
+            }
+            PyObject *first = PyTuple_GetItem(args, 0);
+            if (!PyLong_Check(first)) {
+                throw std::runtime_error("Invalid argument to example_name");
+            }
+            auto result = py::cast(PyLong_AsLong(first) * 9);
+            return result.release().ptr();
+        };
+        def.ml_flags = METH_VARARGS;
+        return &def;
+    }();
+
+    // rec_capsule with name that has the same value (but not pointer) as our internal one
+    // This capsule should be detected by our code as foreign and not inspected as the pointers
+    // shouldn't match
+    constexpr const char *rec_capsule_name
+        = pybind11::detail::internals_function_record_capsule_name;
+    py::capsule rec_capsule(std::malloc(1), [](void *data) { std::free(data); });
+    rec_capsule.set_name(rec_capsule_name);
+    m.add_object("custom_function", PyCFunction_New(custom_def, rec_capsule.ptr()));
+
+    // This test requires a new ABI version to pass
+#if PYBIND11_INTERNALS_VERSION > 4
+    // rec_capsule with nullptr name
+    py::capsule rec_capsule2(std::malloc(1), [](void *data) { std::free(data); });
+    m.add_object("custom_function2", PyCFunction_New(custom_def, rec_capsule2.ptr()));
+#else
+    m.add_object("custom_function2", py::none());
+#endif
 }
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_callbacks.py` & `python_prtree-0.6.1/third/pybind11/tests/test_callbacks.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,28 +1,28 @@
-# -*- coding: utf-8 -*-
 import time
 from threading import Thread
 
 import pytest
 
 import env  # noqa: F401
 from pybind11_tests import callbacks as m
+from pybind11_tests import detailed_error_messages_enabled
 
 
 def test_callbacks():
     from functools import partial
 
     def func1():
         return "func1"
 
     def func2(a, b, c, d):
         return "func2", a, b, c, d
 
     def func3(a):
-        return "func3({})".format(a)
+        return f"func3({a})"
 
     assert m.test_callback1(func1) == "func1"
     assert m.test_callback2(func2) == ("func2", "Hello", "x", True, 5)
     assert m.test_callback1(partial(func2, 1, 2, 3, 4)) == ("func2", 1, 2, 3, 4)
     assert m.test_callback1(partial(func3, "partial")) == "func3(partial)"
     assert m.test_callback3(lambda i: i + 1) == "func(43) = 44"
 
@@ -67,19 +67,28 @@
 
     with pytest.raises(TypeError) as excinfo:
         m.test_unpacking_error2(f)
     assert "Got multiple values for keyword argument" in str(excinfo.value)
 
     with pytest.raises(RuntimeError) as excinfo:
         m.test_arg_conversion_error1(f)
-    assert "Unable to convert call argument" in str(excinfo.value)
+    assert str(excinfo.value) == "Unable to convert call argument " + (
+        "'1' of type 'UnregisteredType' to Python object"
+        if detailed_error_messages_enabled
+        else "'1' to Python object (#define PYBIND11_DETAILED_ERROR_MESSAGES or compile in debug mode for details)"
+    )
 
     with pytest.raises(RuntimeError) as excinfo:
         m.test_arg_conversion_error2(f)
-    assert "Unable to convert call argument" in str(excinfo.value)
+    assert str(excinfo.value) == "Unable to convert call argument " + (
+        "'expected_name' of type 'UnregisteredType' to Python object"
+        if detailed_error_messages_enabled
+        else "'expected_name' to Python object "
+        "(#define PYBIND11_DETAILED_ERROR_MESSAGES or compile in debug mode for details)"
+    )
 
 
 def test_lambda_closure_cleanup():
     m.test_lambda_closure_cleanup()
     cstats = m.payload_cstats()
     assert cstats.alive() == 0
     assert cstats.copy_constructions == 1
@@ -185,18 +194,32 @@
         m.callback_num_times(lambda: None, num_millions * one_million)
         td = time.time() - t0
         rate = num_millions / td if td else 0
         rates.append(rate)
         if not rep:
             print()
         print(
-            "callback_num_times: {:d} million / {:.3f} seconds = {:.3f} million / second".format(
-                num_millions, td, rate
-            )
+            f"callback_num_times: {num_millions:d} million / {td:.3f} seconds = {rate:.3f} million / second"
         )
     if len(rates) > 1:
         print("Min    Mean   Max")
-        print(
-            "{:6.3f} {:6.3f} {:6.3f}".format(
-                min(rates), sum(rates) / len(rates), max(rates)
-            )
-        )
+        print(f"{min(rates):6.3f} {sum(rates) / len(rates):6.3f} {max(rates):6.3f}")
+
+
+def test_custom_func():
+    assert m.custom_function(4) == 36
+    assert m.roundtrip(m.custom_function)(4) == 36
+
+
+@pytest.mark.skipif(
+    m.custom_function2 is None, reason="Current PYBIND11_INTERNALS_VERSION too low"
+)
+def test_custom_func2():
+    assert m.custom_function2(3) == 27
+    assert m.roundtrip(m.custom_function2)(3) == 27
+
+
+def test_callback_docstring():
+    assert (
+        m.test_tuple_unpacking.__doc__.strip()
+        == "test_tuple_unpacking(arg0: Callable) -> object"
+    )
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_chrono.cpp` & `python_prtree-0.6.1/third/pybind11/tests/test_chrono.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_chrono.py` & `python_prtree-0.6.1/third/pybind11/tests/test_chrono.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,18 +1,16 @@
-# -*- coding: utf-8 -*-
 import datetime
 
 import pytest
 
 import env  # noqa: F401
 from pybind11_tests import chrono as m
 
 
 def test_chrono_system_clock():
-
     # Get the time from both c++ and datetime
     date0 = datetime.datetime.today()
     date1 = m.test_chrono1()
     date2 = datetime.datetime.today()
 
     # The returned value should be a datetime
     assert isinstance(date1, datetime.datetime)
@@ -97,15 +95,15 @@
         pytest.param("Europe/Brussels", marks=SKIP_TZ_ENV_ON_WIN),
         pytest.param("Asia/Pyongyang", marks=SKIP_TZ_ENV_ON_WIN),
         pytest.param("America/New_York", marks=SKIP_TZ_ENV_ON_WIN),
     ],
 )
 def test_chrono_system_clock_roundtrip_time(time1, tz, monkeypatch):
     if tz is not None:
-        monkeypatch.setenv("TZ", "/usr/share/zoneinfo/{}".format(tz))
+        monkeypatch.setenv("TZ", f"/usr/share/zoneinfo/{tz}")
 
     # Roundtrip the time
     datetime2 = m.test_chrono2(time1)
     date2 = datetime2.date()
     time2 = datetime2.time()
 
     # The returned value should be a datetime
@@ -119,15 +117,14 @@
     # There should be no date information (i.e. date = python base date)
     assert date2.year == 1970
     assert date2.month == 1
     assert date2.day == 1
 
 
 def test_chrono_duration_roundtrip():
-
     # Get the difference between two times (a timedelta)
     date1 = datetime.datetime.today()
     date2 = datetime.datetime.today()
     diff = date2 - date1
 
     # Make sure this is a timedelta
     assert isinstance(diff, datetime.timedelta)
@@ -140,26 +137,24 @@
     diff = datetime.timedelta(microseconds=-1)
     cpp_diff = m.test_chrono3(diff)
 
     assert cpp_diff == diff
 
 
 def test_chrono_duration_subtraction_equivalence():
-
     date1 = datetime.datetime.today()
     date2 = datetime.datetime.today()
 
     diff = date2 - date1
     cpp_diff = m.test_chrono4(date2, date1)
 
     assert cpp_diff == diff
 
 
 def test_chrono_duration_subtraction_equivalence_date():
-
     date1 = datetime.date.today()
     date2 = datetime.date.today()
 
     diff = date2 - date1
     cpp_diff = m.test_chrono4(date2, date1)
 
     assert cpp_diff == diff
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_class.cpp` & `python_prtree-0.6.1/third/pybind11/tests/test_class.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -18,29 +18,49 @@
 
 #include "constructor_stats.h"
 #include "local_bindings.h"
 #include "pybind11_tests.h"
 
 #include <utility>
 
-#if defined(_MSC_VER)
-#    pragma warning(disable : 4324)
+PYBIND11_WARNING_DISABLE_MSVC(4324)
 //     warning C4324: structure was padded due to alignment specifier
-#endif
 
 // test_brace_initialization
 struct NoBraceInitialization {
     explicit NoBraceInitialization(std::vector<int> v) : vec{std::move(v)} {}
     template <typename T>
     NoBraceInitialization(std::initializer_list<T> l) : vec(l) {}
 
     std::vector<int> vec;
 };
 
+namespace test_class {
+namespace pr4220_tripped_over_this { // PR #4227
+
+template <int>
+struct SoEmpty {};
+
+template <typename T>
+std::string get_msg(const T &) {
+    return "This is really only meant to exercise successful compilation.";
+}
+
+using Empty0 = SoEmpty<0x0>;
+
+void bind_empty0(py::module_ &m) {
+    py::class_<Empty0>(m, "Empty0").def(py::init<>()).def("get_msg", get_msg<Empty0>);
+}
+
+} // namespace pr4220_tripped_over_this
+} // namespace test_class
+
 TEST_SUBMODULE(class_, m) {
+    m.def("obj_class_name", [](py::handle obj) { return py::detail::obj_class_name(obj.ptr()); });
+
     // test_instance
     struct NoConstructor {
         NoConstructor() = default;
         NoConstructor(const NoConstructor &) = default;
         NoConstructor(NoConstructor &&) = default;
         static NoConstructor *new_instance() {
             auto *ptr = new NoConstructor();
@@ -61,15 +81,15 @@
         ~NoConstructorNew() { print_destroyed(this); }
     };
 
     py::class_<NoConstructor>(m, "NoConstructor")
         .def_static("new_instance", &NoConstructor::new_instance, "Return an instance");
 
     py::class_<NoConstructorNew>(m, "NoConstructorNew")
-        .def(py::init([](const NoConstructorNew &self) { return self; })) // Need a NOOP __init__
+        .def(py::init([]() { return nullptr; })) // Need a NOOP __init__
         .def_static("__new__",
                     [](const py::object &) { return NoConstructorNew::new_instance(); });
 
     // test_inheritance
     class Pet {
     public:
         Pet(const std::string &name, const std::string &species)
@@ -350,56 +370,62 @@
     };
 
     class PublicistA : public ProtectedA {
     public:
         using ProtectedA::foo;
     };
 
-    py::class_<ProtectedA>(m, "ProtectedA")
-        .def(py::init<>())
-#if !defined(_MSC_VER) || _MSC_VER >= 1910
-        .def("foo", &PublicistA::foo);
-#else
-        .def("foo", static_cast<int (ProtectedA::*)() const>(&PublicistA::foo));
-#endif
+    py::class_<ProtectedA>(m, "ProtectedA").def(py::init<>()).def("foo", &PublicistA::foo);
 
     class ProtectedB {
     public:
         virtual ~ProtectedB() = default;
         ProtectedB() = default;
         ProtectedB(const ProtectedB &) = delete;
 
     protected:
         virtual int foo() const { return value; }
+        virtual void *void_foo() { return static_cast<void *>(&value); }
+        virtual void *get_self() { return static_cast<void *>(this); }
 
     private:
         int value = 42;
     };
 
     class TrampolineB : public ProtectedB {
     public:
         int foo() const override { PYBIND11_OVERRIDE(int, ProtectedB, foo, ); }
+        void *void_foo() override { PYBIND11_OVERRIDE(void *, ProtectedB, void_foo, ); }
+        void *get_self() override { PYBIND11_OVERRIDE(void *, ProtectedB, get_self, ); }
     };
 
     class PublicistB : public ProtectedB {
     public:
         // [workaround(intel)] = default does not work here
         // Removing or defaulting this destructor results in linking errors with the Intel compiler
         // (in Debug builds only, tested with icpc (ICC) 2021.1 Beta 20200827)
         ~PublicistB() override{}; // NOLINT(modernize-use-equals-default)
         using ProtectedB::foo;
+        using ProtectedB::get_self;
+        using ProtectedB::void_foo;
     };
 
+    m.def("read_foo", [](const void *original) {
+        const int *ptr = reinterpret_cast<const int *>(original);
+        return *ptr;
+    });
+
+    m.def("pointers_equal",
+          [](const void *original, const void *comparison) { return original == comparison; });
+
     py::class_<ProtectedB, TrampolineB>(m, "ProtectedB")
         .def(py::init<>())
-#if !defined(_MSC_VER) || _MSC_VER >= 1910
-        .def("foo", &PublicistB::foo);
-#else
-        .def("foo", static_cast<int (ProtectedB::*)() const>(&PublicistB::foo));
-#endif
+        .def("foo", &PublicistB::foo)
+        .def("void_foo", &PublicistB::void_foo)
+        .def("get_self", &PublicistB::get_self);
 
     // test_brace_initialization
     struct BraceInitialization {
         int field1;
         std::string field2;
     };
 
@@ -523,14 +549,16 @@
         py::class_<DuplicateNested>(gt, "DuplicateNested");
         py::class_<OtherDuplicateNested>(gt, "DuplicateNested");
     });
     m.def("register_duplicate_nested_class_type", [](const py::object &gt) {
         py::class_<OtherDuplicateNested>(gt, "OtherDuplicateNested");
         py::class_<OtherDuplicateNested>(gt, "YetAnotherDuplicateNested");
     });
+
+    test_class::pr4220_tripped_over_this::bind_empty0(m);
 }
 
 template <int N>
 class BreaksBase {
 public:
     virtual ~BreaksBase() = default;
     BreaksBase() = default;
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_class.py` & `python_prtree-0.6.1/third/pybind11/tests/test_class.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,17 +1,23 @@
-# -*- coding: utf-8 -*-
+from unittest import mock
+
 import pytest
 
-import env  # noqa: F401
+import env
 from pybind11_tests import ConstructorStats, UserType
 from pybind11_tests import class_ as m
 
 
+def test_obj_class_name():
+    expected_name = "UserType" if env.PYPY else "pybind11_tests.UserType"
+    assert m.obj_class_name(UserType(1)) == expected_name
+    assert m.obj_class_name(UserType) == expected_name
+
+
 def test_repr():
-    # In Python 3.3+, repr() accesses __qualname__
     assert "pybind11_type" in repr(type(UserType))
     assert "UserType" in repr(UserType)
 
 
 def test_instance(msg):
     with pytest.raises(TypeError) as excinfo:
         m.NoConstructor()
@@ -21,15 +27,15 @@
 
     cstats = ConstructorStats.get(m.NoConstructor)
     assert cstats.alive() == 1
     del instance
     assert cstats.alive() == 0
 
 
-def test_instance_new(msg):
+def test_instance_new():
     instance = m.NoConstructorNew()  # .__new__(m.NoConstructor.__class__)
     cstats = ConstructorStats.get(m.NoConstructorNew)
     assert cstats.alive() == 1
     del instance
     assert cstats.alive() == 0
 
 
@@ -99,16 +105,16 @@
 
         Return an instance
     """
     )
 
 
 def test_qualname(doc):
-    """Tests that a properly qualified name is set in __qualname__ (even in pre-3.3, where we
-    backport the attribute) and that generated docstrings properly use it and the module name"""
+    """Tests that a properly qualified name is set in __qualname__ and that
+    generated docstrings properly use it and the module name"""
     assert m.NestBase.__qualname__ == "NestBase"
     assert m.NestBase.Nested.__qualname__ == "NestBase.Nested"
 
     assert (
         doc(m.NestBase.__init__)
         == """
         __init__(self: m.class_.NestBase) -> None
@@ -126,21 +132,21 @@
         __init__(self: m.class_.NestBase.Nested) -> None
     """
     )
     assert (
         doc(m.NestBase.Nested.fn)
         == """
         fn(self: m.class_.NestBase.Nested, arg0: int, arg1: m.class_.NestBase, arg2: m.class_.NestBase.Nested) -> None
-    """  # noqa: E501 line too long
+    """
     )
     assert (
         doc(m.NestBase.Nested.fa)
         == """
         fa(self: m.class_.NestBase.Nested, a: int, b: m.class_.NestBase, c: m.class_.NestBase.Nested) -> None
-    """  # noqa: E501 line too long
+    """
     )
     assert m.NestBase.__module__ == "pybind11_tests.class_"
     assert m.NestBase.Nested.__module__ == "pybind11_tests.class_"
 
 
 def test_inheritance(msg):
     roger = m.Rabbit("Rabbit")
@@ -174,15 +180,14 @@
 
     with pytest.raises(TypeError) as excinfo:
         m.Chimera("lion", "goat")
     assert "No constructor defined!" in str(excinfo.value)
 
 
 def test_inheritance_init(msg):
-
     # Single base
     class Python(m.Pet):
         def __init__(self):
             pass
 
     with pytest.raises(TypeError) as exc_info:
         Python()
@@ -196,14 +201,26 @@
 
     with pytest.raises(TypeError) as exc_info:
         RabbitHamster()
     expected = "m.class_.Hamster.__init__() must be called when overriding __init__"
     assert msg(exc_info.value) == expected
 
 
+@pytest.mark.parametrize(
+    "mock_return_value", [None, (1, 2, 3), m.Pet("Polly", "parrot"), m.Dog("Molly")]
+)
+def test_mock_new(mock_return_value):
+    with mock.patch.object(
+        m.Pet, "__new__", return_value=mock_return_value
+    ) as mock_new:
+        obj = m.Pet("Noname", "Nospecies")
+    assert obj is mock_return_value
+    mock_new.assert_called_once_with(m.Pet, "Noname", "Nospecies")
+
+
 def test_automatic_upcasting():
     assert type(m.return_class_1()).__name__ == "DerivedClass1"
     assert type(m.return_class_2()).__name__ == "DerivedClass2"
     assert type(m.return_none()).__name__ == "NoneType"
     # Repeat these a few times in a random order to ensure no invalid caching is applied
     assert type(m.return_class_n(1)).__name__ == "DerivedClass1"
     assert type(m.return_class_n(2)).__name__ == "DerivedClass2"
@@ -211,15 +228,15 @@
     assert type(m.return_class_n(2)).__name__ == "DerivedClass2"
     assert type(m.return_class_n(2)).__name__ == "DerivedClass2"
     assert type(m.return_class_n(0)).__name__ == "BaseClass"
     assert type(m.return_class_n(1)).__name__ == "DerivedClass1"
 
 
 def test_isinstance():
-    objects = [tuple(), dict(), m.Pet("Polly", "parrot")] + [m.Dog("Molly")] * 4
+    objects = [(), {}, m.Pet("Polly", "parrot")] + [m.Dog("Molly")] * 4
     expected = (True, True, True, True, True, False, False)
     assert m.check_instances(objects) == expected
 
 
 def test_mismatched_holder():
     import re
 
@@ -311,14 +328,16 @@
 def test_bind_protected_functions():
     """Expose protected member functions to Python using a helper class"""
     a = m.ProtectedA()
     assert a.foo() == 42
 
     b = m.ProtectedB()
     assert b.foo() == 42
+    assert m.read_foo(b.void_foo()) == 42
+    assert m.pointers_equal(b.get_self(), b)
 
     class C(m.ProtectedB):
         def __init__(self):
             m.ProtectedB.__init__(self)
 
         def foo(self):
             return 0
@@ -415,15 +434,15 @@
 # https://github.com/pybind/pybind11/issues/1878
 def test_exception_rvalue_abort():
     with pytest.raises(RuntimeError):
         m.PyPrintDestructor().throw_something()
 
 
 # https://github.com/pybind/pybind11/issues/1568
-def test_multiple_instances_with_same_pointer(capture):
+def test_multiple_instances_with_same_pointer():
     n = 100
     instances = [m.SamePointer() for _ in range(n)]
     for i in range(n):
         # We need to reuse the same allocated memory for with a different type,
         # to ensure the bug in `deregister_instance_impl` is detected. Otherwise
         # `Py_TYPE(self) == Py_TYPE(it->second)` will still succeed, even though
         # the `instance` is already deleted.
@@ -467,7 +486,14 @@
         "an object with that name is already defined"
     )
     assert str(exc_info.value) == expected
     with pytest.raises(RuntimeError) as exc_info:
         m.register_duplicate_nested_class_type(ClassScope)
     expected = 'generic_type: type "YetAnotherDuplicateNested" is already registered!'
     assert str(exc_info.value) == expected
+
+
+def test_pr4220_tripped_over_this():
+    assert (
+        m.Empty0().get_msg()
+        == "This is really only meant to exercise successful compilation."
+    )
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_cmake_build/CMakeLists.txt` & `python_prtree-0.6.1/third/pybind11/tests/test_cmake_build/CMakeLists.txt`

 * *Files 5% similar despite different names*

```diff
@@ -1,20 +1,16 @@
-# Built-in in CMake 3.5+
-include(CMakeParseArguments)
-
 add_custom_target(test_cmake_build)
 
 function(pybind11_add_build_test name)
   cmake_parse_arguments(ARG "INSTALL" "" "" ${ARGN})
 
   set(build_options "-DCMAKE_CXX_COMPILER=${CMAKE_CXX_COMPILER}")
 
+  list(APPEND build_options "-DPYBIND11_FINDPYTHON=${PYBIND11_FINDPYTHON}")
   if(PYBIND11_FINDPYTHON)
-    list(APPEND build_options "-DPYBIND11_FINDPYTHON=${PYBIND11_FINDPYTHON}")
-
     if(DEFINED Python_ROOT_DIR)
       list(APPEND build_options "-DPython_ROOT_DIR=${Python_ROOT_DIR}")
     endif()
 
     list(APPEND build_options "-DPython_EXECUTABLE=${Python_EXECUTABLE}")
   else()
     list(APPEND build_options "-DPYTHON_EXECUTABLE=${PYTHON_EXECUTABLE}")
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_cmake_build/embed.cpp` & `python_prtree-0.6.1/third/pybind11/tests/test_cmake_build/embed.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_cmake_build/installed_embed/CMakeLists.txt` & `python_prtree-0.6.1/third/pybind11/tests/test_cmake_build/installed_embed/CMakeLists.txt`

 * *Files 8% similar despite different names*

```diff
@@ -1,16 +1,16 @@
-cmake_minimum_required(VERSION 3.4)
+cmake_minimum_required(VERSION 3.5)
 
-# The `cmake_minimum_required(VERSION 3.4...3.18)` syntax does not work with
+# The `cmake_minimum_required(VERSION 3.5...3.27)` syntax does not work with
 # some versions of VS that have a patched CMake 3.11. This forces us to emulate
 # the behavior using the following workaround:
-if(${CMAKE_VERSION} VERSION_LESS 3.18)
+if(${CMAKE_VERSION} VERSION_LESS 3.27)
   cmake_policy(VERSION ${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION})
 else()
-  cmake_policy(VERSION 3.18)
+  cmake_policy(VERSION 3.27)
 endif()
 
 project(test_installed_embed CXX)
 
 find_package(pybind11 CONFIG REQUIRED)
 message(STATUS "Found pybind11 v${pybind11_VERSION}: ${pybind11_INCLUDE_DIRS}")
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_cmake_build/installed_function/CMakeLists.txt` & `python_prtree-0.6.1/third/pybind11/tests/test_cmake_build/installed_function/CMakeLists.txt`

 * *Files 3% similar despite different names*

```diff
@@ -1,17 +1,17 @@
-cmake_minimum_required(VERSION 3.4)
+cmake_minimum_required(VERSION 3.5)
 project(test_installed_module CXX)
 
-# The `cmake_minimum_required(VERSION 3.4...3.18)` syntax does not work with
+# The `cmake_minimum_required(VERSION 3.5...3.27)` syntax does not work with
 # some versions of VS that have a patched CMake 3.11. This forces us to emulate
 # the behavior using the following workaround:
-if(${CMAKE_VERSION} VERSION_LESS 3.18)
+if(${CMAKE_VERSION} VERSION_LESS 3.27)
   cmake_policy(VERSION ${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION})
 else()
-  cmake_policy(VERSION 3.18)
+  cmake_policy(VERSION 3.27)
 endif()
 
 project(test_installed_function CXX)
 
 find_package(pybind11 CONFIG REQUIRED)
 message(
   STATUS "Found pybind11 v${pybind11_VERSION} ${pybind11_VERSION_TYPE}: ${pybind11_INCLUDE_DIRS}")
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_cmake_build/installed_target/CMakeLists.txt` & `python_prtree-0.6.1/third/pybind11/tests/test_cmake_build/installed_target/CMakeLists.txt`

 * *Files 9% similar despite different names*

```diff
@@ -1,16 +1,16 @@
-cmake_minimum_required(VERSION 3.4)
+cmake_minimum_required(VERSION 3.5)
 
-# The `cmake_minimum_required(VERSION 3.4...3.18)` syntax does not work with
+# The `cmake_minimum_required(VERSION 3.5...3.27)` syntax does not work with
 # some versions of VS that have a patched CMake 3.11. This forces us to emulate
 # the behavior using the following workaround:
-if(${CMAKE_VERSION} VERSION_LESS 3.18)
+if(${CMAKE_VERSION} VERSION_LESS 3.27)
   cmake_policy(VERSION ${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION})
 else()
-  cmake_policy(VERSION 3.18)
+  cmake_policy(VERSION 3.27)
 endif()
 
 project(test_installed_target CXX)
 
 find_package(pybind11 CONFIG REQUIRED)
 message(STATUS "Found pybind11 v${pybind11_VERSION}: ${pybind11_INCLUDE_DIRS}")
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_cmake_build/subdirectory_embed/CMakeLists.txt` & `python_prtree-0.6.1/third/pybind11/tests/test_cmake_build/subdirectory_embed/CMakeLists.txt`

 * *Files 20% similar despite different names*

```diff
@@ -1,25 +1,31 @@
-cmake_minimum_required(VERSION 3.4)
+cmake_minimum_required(VERSION 3.5)
 
-# The `cmake_minimum_required(VERSION 3.4...3.18)` syntax does not work with
+# The `cmake_minimum_required(VERSION 3.5...3.27)` syntax does not work with
 # some versions of VS that have a patched CMake 3.11. This forces us to emulate
 # the behavior using the following workaround:
-if(${CMAKE_VERSION} VERSION_LESS 3.18)
+if(${CMAKE_VERSION} VERSION_LESS 3.27)
   cmake_policy(VERSION ${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION})
 else()
-  cmake_policy(VERSION 3.18)
+  cmake_policy(VERSION 3.27)
 endif()
 
 project(test_subdirectory_embed CXX)
 
 set(PYBIND11_INSTALL
     ON
     CACHE BOOL "")
 set(PYBIND11_EXPORT_NAME test_export)
 
+# Allow PYTHON_EXECUTABLE if in FINDPYTHON mode and building pybind11's tests
+# (makes transition easier while we support both modes).
+if(DEFINED PYTHON_EXECUTABLE AND NOT DEFINED Python_EXECUTABLE)
+  set(Python_EXECUTABLE "${PYTHON_EXECUTABLE}")
+endif()
+
 add_subdirectory("${pybind11_SOURCE_DIR}" pybind11)
 
 # Test basic target functionality
 add_executable(test_subdirectory_embed ../embed.cpp)
 target_link_libraries(test_subdirectory_embed PRIVATE pybind11::embed)
 set_target_properties(test_subdirectory_embed PROPERTIES OUTPUT_NAME test_cmake_build)
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_cmake_build/subdirectory_function/CMakeLists.txt` & `python_prtree-0.6.1/third/pybind11/tests/test_cmake_build/subdirectory_function/CMakeLists.txt`

 * *Files 17% similar despite different names*

```diff
@@ -1,20 +1,26 @@
-cmake_minimum_required(VERSION 3.4)
+cmake_minimum_required(VERSION 3.5)
 
-# The `cmake_minimum_required(VERSION 3.4...3.18)` syntax does not work with
+# The `cmake_minimum_required(VERSION 3.5...3.27)` syntax does not work with
 # some versions of VS that have a patched CMake 3.11. This forces us to emulate
 # the behavior using the following workaround:
-if(${CMAKE_VERSION} VERSION_LESS 3.18)
+if(${CMAKE_VERSION} VERSION_LESS 3.27)
   cmake_policy(VERSION ${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION})
 else()
-  cmake_policy(VERSION 3.18)
+  cmake_policy(VERSION 3.27)
 endif()
 
 project(test_subdirectory_function CXX)
 
+# Allow PYTHON_EXECUTABLE if in FINDPYTHON mode and building pybind11's tests
+# (makes transition easier while we support both modes).
+if(DEFINED PYTHON_EXECUTABLE AND NOT DEFINED Python_EXECUTABLE)
+  set(Python_EXECUTABLE "${PYTHON_EXECUTABLE}")
+endif()
+
 add_subdirectory("${pybind11_SOURCE_DIR}" pybind11)
 pybind11_add_module(test_subdirectory_function ../main.cpp)
 set_target_properties(test_subdirectory_function PROPERTIES OUTPUT_NAME test_cmake_build)
 
 if(DEFINED Python_EXECUTABLE)
   set(_Python_EXECUTABLE "${Python_EXECUTABLE}")
 elseif(DEFINED PYTHON_EXECUTABLE)
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_cmake_build/subdirectory_target/CMakeLists.txt` & `python_prtree-0.6.1/third/pybind11/tests/test_cmake_build/subdirectory_target/CMakeLists.txt`

 * *Files 12% similar despite different names*

```diff
@@ -1,20 +1,26 @@
-cmake_minimum_required(VERSION 3.4)
+cmake_minimum_required(VERSION 3.5)
 
-# The `cmake_minimum_required(VERSION 3.4...3.18)` syntax does not work with
+# The `cmake_minimum_required(VERSION 3.5...3.27)` syntax does not work with
 # some versions of VS that have a patched CMake 3.11. This forces us to emulate
 # the behavior using the following workaround:
-if(${CMAKE_VERSION} VERSION_LESS 3.18)
+if(${CMAKE_VERSION} VERSION_LESS 3.27)
   cmake_policy(VERSION ${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION})
 else()
-  cmake_policy(VERSION 3.18)
+  cmake_policy(VERSION 3.27)
 endif()
 
 project(test_subdirectory_target CXX)
 
+# Allow PYTHON_EXECUTABLE if in FINDPYTHON mode and building pybind11's tests
+# (makes transition easier while we support both modes).
+if(DEFINED PYTHON_EXECUTABLE AND NOT DEFINED Python_EXECUTABLE)
+  set(Python_EXECUTABLE "${PYTHON_EXECUTABLE}")
+endif()
+
 add_subdirectory("${pybind11_SOURCE_DIR}" pybind11)
 
 add_library(test_subdirectory_target MODULE ../main.cpp)
 set_target_properties(test_subdirectory_target PROPERTIES OUTPUT_NAME test_cmake_build)
 
 target_link_libraries(test_subdirectory_target PRIVATE pybind11::module)
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_const_name.cpp` & `python_prtree-0.6.1/third/pybind11/tests/test_const_name.cpp`

 * *Files 22% similar despite different names*

```diff
@@ -1,70 +1,55 @@
 // Copyright (c) 2021 The Pybind Development Team.
 // All rights reserved. Use of this source code is governed by a
 // BSD-style license that can be found in the LICENSE file.
 
 #include "pybind11_tests.h"
 
-#if defined(_MSC_VER) && _MSC_VER < 1910
-
-// MSVC 2015 fails in bizarre ways.
-#    define PYBIND11_SKIP_TEST_CONST_NAME
-
-#else // Only test with MSVC 2017 or newer.
-
 // IUT = Implementation Under Test
-#    define CONST_NAME_TESTS(TEST_FUNC, IUT)                                                      \
-        std::string TEST_FUNC(int selector) {                                                     \
-            switch (selector) {                                                                   \
-                case 0:                                                                           \
-                    return IUT("").text;                                                          \
-                case 1:                                                                           \
-                    return IUT("A").text;                                                         \
-                case 2:                                                                           \
-                    return IUT("Bd").text;                                                        \
-                case 3:                                                                           \
-                    return IUT("Cef").text;                                                       \
-                case 4:                                                                           \
-                    return IUT<int>().text; /*NOLINT(bugprone-macro-parentheses)*/                \
-                case 5:                                                                           \
-                    return IUT<std::string>().text; /*NOLINT(bugprone-macro-parentheses)*/        \
-                case 6:                                                                           \
-                    return IUT<true>("T1", "T2").text; /*NOLINT(bugprone-macro-parentheses)*/     \
-                case 7:                                                                           \
-                    return IUT<false>("U1", "U2").text; /*NOLINT(bugprone-macro-parentheses)*/    \
-                case 8:                                                                           \
-                    /*NOLINTNEXTLINE(bugprone-macro-parentheses)*/                                \
-                    return IUT<true>(IUT("D1"), IUT("D2")).text;                                  \
-                case 9:                                                                           \
-                    /*NOLINTNEXTLINE(bugprone-macro-parentheses)*/                                \
-                    return IUT<false>(IUT("E1"), IUT("E2")).text;                                 \
-                case 10:                                                                          \
-                    return IUT("KeepAtEnd").text;                                                 \
-                default:                                                                          \
-                    break;                                                                        \
-            }                                                                                     \
-            throw std::runtime_error("Invalid selector value.");                                  \
-        }
+#define CONST_NAME_TESTS(TEST_FUNC, IUT)                                                          \
+    std::string TEST_FUNC(int selector) {                                                         \
+        switch (selector) {                                                                       \
+            case 0:                                                                               \
+                return IUT("").text;                                                              \
+            case 1:                                                                               \
+                return IUT("A").text;                                                             \
+            case 2:                                                                               \
+                return IUT("Bd").text;                                                            \
+            case 3:                                                                               \
+                return IUT("Cef").text;                                                           \
+            case 4:                                                                               \
+                return IUT<int>().text; /*NOLINT(bugprone-macro-parentheses)*/                    \
+            case 5:                                                                               \
+                return IUT<std::string>().text; /*NOLINT(bugprone-macro-parentheses)*/            \
+            case 6:                                                                               \
+                return IUT<true>("T1", "T2").text; /*NOLINT(bugprone-macro-parentheses)*/         \
+            case 7:                                                                               \
+                return IUT<false>("U1", "U2").text; /*NOLINT(bugprone-macro-parentheses)*/        \
+            case 8:                                                                               \
+                /*NOLINTNEXTLINE(bugprone-macro-parentheses)*/                                    \
+                return IUT<true>(IUT("D1"), IUT("D2")).text;                                      \
+            case 9:                                                                               \
+                /*NOLINTNEXTLINE(bugprone-macro-parentheses)*/                                    \
+                return IUT<false>(IUT("E1"), IUT("E2")).text;                                     \
+            case 10:                                                                              \
+                return IUT("KeepAtEnd").text;                                                     \
+            default:                                                                              \
+                break;                                                                            \
+        }                                                                                         \
+        throw std::runtime_error("Invalid selector value.");                                      \
+    }
 
 CONST_NAME_TESTS(const_name_tests, py::detail::const_name)
 
-#    ifdef PYBIND11_DETAIL_UNDERSCORE_BACKWARD_COMPATIBILITY
+#ifdef PYBIND11_DETAIL_UNDERSCORE_BACKWARD_COMPATIBILITY
 CONST_NAME_TESTS(underscore_tests, py::detail::_)
-#    endif
-
-#endif // MSVC >= 2017
+#endif
 
 TEST_SUBMODULE(const_name, m) {
-#ifdef PYBIND11_SKIP_TEST_CONST_NAME
-    m.attr("const_name_tests") = "PYBIND11_SKIP_TEST_CONST_NAME";
-#else
     m.def("const_name_tests", const_name_tests);
-#endif
 
-#ifdef PYBIND11_SKIP_TEST_CONST_NAME
-    m.attr("underscore_tests") = "PYBIND11_SKIP_TEST_CONST_NAME";
-#elif defined(PYBIND11_DETAIL_UNDERSCORE_BACKWARD_COMPATIBILITY)
+#if defined(PYBIND11_DETAIL_UNDERSCORE_BACKWARD_COMPATIBILITY)
     m.def("underscore_tests", underscore_tests);
 #else
     m.attr("underscore_tests") = "PYBIND11_DETAIL_UNDERSCORE_BACKWARD_COMPATIBILITY not defined.";
 #endif
 }
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_constants_and_functions.cpp` & `python_prtree-0.6.1/third/pybind11/tests/test_constants_and_functions.cpp`

 * *Files 24% similar despite different names*

```diff
@@ -27,16 +27,16 @@
     const char *data = "\x01\x00\x02\x00";
     return std::string(data, 4);
 }
 
 std::string print_bytes(const py::bytes &bytes) {
     std::string ret = "bytes[";
     const auto value = static_cast<std::string>(bytes);
-    for (size_t i = 0; i < value.length(); ++i) {
-        ret += std::to_string(static_cast<int>(value[i])) + " ";
+    for (char c : value) {
+        ret += std::to_string(static_cast<int>(c)) + ' ';
     }
     ret.back() = ']';
     return ret;
 }
 
 // Test that we properly handle C++17 exception specifiers (which are part of the function
 // signature in C++17).  These should all still work before C++17, but don't affect the function
@@ -48,41 +48,39 @@
 #if defined(__INTEL_COMPILER) && defined(PYBIND11_CPP17)
 int f1(int x) noexcept(true) { return x + 1; }
 #else
 int f1(int x) noexcept { return x + 1; }
 #endif
 int f2(int x) noexcept(true) { return x + 2; }
 int f3(int x) noexcept(false) { return x + 3; }
-#if defined(__GNUG__) && !defined(__INTEL_COMPILER)
-#    pragma GCC diagnostic push
-#    pragma GCC diagnostic ignored "-Wdeprecated"
+PYBIND11_WARNING_PUSH
+PYBIND11_WARNING_DISABLE_GCC("-Wdeprecated")
+#if defined(__clang_major__) && __clang_major__ >= 5
+PYBIND11_WARNING_DISABLE_CLANG("-Wdeprecated-dynamic-exception-spec")
+#else
+PYBIND11_WARNING_DISABLE_CLANG("-Wdeprecated")
 #endif
 // NOLINTNEXTLINE(modernize-use-noexcept)
 int f4(int x) throw() { return x + 4; } // Deprecated equivalent to noexcept(true)
-#if defined(__GNUG__) && !defined(__INTEL_COMPILER)
-#    pragma GCC diagnostic pop
-#endif
+PYBIND11_WARNING_POP
 struct C {
     int m1(int x) noexcept { return x - 1; }
     int m2(int x) const noexcept { return x - 2; }
     int m3(int x) noexcept(true) { return x - 3; }
     int m4(int x) const noexcept(true) { return x - 4; }
     int m5(int x) noexcept(false) { return x - 5; }
     int m6(int x) const noexcept(false) { return x - 6; }
-#if defined(__GNUG__) && !defined(__INTEL_COMPILER)
-#    pragma GCC diagnostic push
-#    pragma GCC diagnostic ignored "-Wdeprecated"
-#endif
+    PYBIND11_WARNING_PUSH
+    PYBIND11_WARNING_DISABLE_GCC("-Wdeprecated")
+    PYBIND11_WARNING_DISABLE_CLANG("-Wdeprecated")
     // NOLINTNEXTLINE(modernize-use-noexcept)
     int m7(int x) throw() { return x - 7; }
     // NOLINTNEXTLINE(modernize-use-noexcept)
     int m8(int x) const throw() { return x - 8; }
-#if defined(__GNUG__) && !defined(__INTEL_COMPILER)
-#    pragma GCC diagnostic pop
-#endif
+    PYBIND11_WARNING_POP
 };
 } // namespace test_exc_sp
 
 TEST_SUBMODULE(constants_and_functions, m) {
     // test_constants
     m.attr("some_constant") = py::int_(14);
 
@@ -122,41 +120,39 @@
         .def("m4", &C::m4)
         .def("m5", &C::m5)
         .def("m6", &C::m6)
         .def("m7", &C::m7)
         .def("m8", &C::m8);
     m.def("f1", f1);
     m.def("f2", f2);
-#if defined(__INTEL_COMPILER)
-#    pragma warning push
-#    pragma warning disable 878 // incompatible exception specifications
-#endif
+
+    PYBIND11_WARNING_PUSH
+    PYBIND11_WARNING_DISABLE_INTEL(878) // incompatible exception specifications
     m.def("f3", f3);
-#if defined(__INTEL_COMPILER)
-#    pragma warning pop
-#endif
+    PYBIND11_WARNING_POP
+
     m.def("f4", f4);
 
     // test_function_record_leaks
-    struct LargeCapture {
+    m.def("register_large_capture_with_invalid_arguments", [](py::module_ m) {
         // This should always be enough to trigger the alternative branch
         // where `sizeof(capture) > sizeof(rec->data)`
-        uint64_t zeros[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
-    };
-    m.def("register_large_capture_with_invalid_arguments", [](py::module_ m) {
-        LargeCapture capture; // VS 2015's MSVC is acting up if we create the array here
+        uint64_t capture[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
+#if defined(__GNUC__) && __GNUC__ == 4 // CentOS7
+        py::detail::silence_unused_warnings(capture);
+#endif
         m.def(
-            "should_raise",
-            [capture](int) { return capture.zeros[9] + 33; },
-            py::kw_only(),
-            py::arg());
+            "should_raise", [capture](int) { return capture[9] + 33; }, py::kw_only(), py::arg());
     });
     m.def("register_with_raising_repr", [](py::module_ m, const py::object &default_value) {
         m.def(
             "should_raise",
             [](int, int, const py::object &) { return 42; },
             "some docstring",
             py::arg_v("x", 42),
             py::arg_v("y", 42, "<the answer>"),
             py::arg_v("z", default_value));
     });
+
+    // test noexcept(true) lambda (#4565)
+    m.def("l1", []() noexcept(true) { return 0; });
 }
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_constants_and_functions.py` & `python_prtree-0.6.1/third/pybind11/tests/test_constants_and_functions.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 import pytest
 
 m = pytest.importorskip("pybind11_tests.constants_and_functions")
 
 
 def test_constants():
     assert m.some_constant == 14
@@ -47,7 +46,11 @@
         def __repr__(self):
             raise RuntimeError("Surprise!")
 
     with pytest.raises(RuntimeError):
         m.register_large_capture_with_invalid_arguments(m)
     with pytest.raises(RuntimeError):
         m.register_with_raising_repr(m, RaisingRepr())
+
+
+def test_noexcept_lambda():
+    assert m.l1() == 0
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_copy_move.py` & `python_prtree-0.6.1/third/pybind11/tests/test_copy_move.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 import pytest
 
 from pybind11_tests import copy_move_policies as m
 
 
 def test_lacking_copy_ctor():
     with pytest.raises(RuntimeError) as excinfo:
@@ -120,7 +119,14 @@
 def test_move_fallback():
     """#389: rvp::move should fall-through to copy on non-movable objects"""
 
     m1 = m.get_moveissue1(1)
     assert m1.value == 1
     m2 = m.get_moveissue2(2)
     assert m2.value == 2
+
+
+def test_pytype_rvalue_cast():
+    """Make sure that cast from pytype rvalue to other pytype works"""
+
+    value = m.get_pytype_rvalue_castissue(1.0)
+    assert value == 1
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_custom_type_casters.cpp` & `python_prtree-0.6.1/third/pybind11/tests/test_custom_type_casters.cpp`

 * *Files 9% similar despite different names*

```diff
@@ -17,15 +17,15 @@
 };
 class ArgInspector2 {
 public:
     std::string arg = "(default arg inspector 2)";
 };
 class ArgAlwaysConverts {};
 
-namespace pybind11 {
+namespace PYBIND11_NAMESPACE {
 namespace detail {
 template <>
 struct type_caster<ArgInspector1> {
 public:
     // Classic
 #ifdef PYBIND11_DETAIL_UNDERSCORE_BACKWARD_COMPATIBILITY
     PYBIND11_TYPE_CASTER(ArgInspector1, _("ArgInspector1"));
@@ -70,15 +70,15 @@
     bool load(handle, bool convert) { return convert; }
 
     static handle cast(const ArgAlwaysConverts &, return_value_policy, handle) {
         return py::none().release();
     }
 };
 } // namespace detail
-} // namespace pybind11
+} // namespace PYBIND11_NAMESPACE
 
 // test_custom_caster_destruction
 class DestructionTester {
 public:
     DestructionTester() { print_default_created(this); }
     ~DestructionTester() { print_destroyed(this); }
     DestructionTester(const DestructionTester &) { print_copy_created(this); }
@@ -88,55 +88,65 @@
         return *this;
     }
     DestructionTester &operator=(DestructionTester &&) noexcept {
         print_move_assigned(this);
         return *this;
     }
 };
-namespace pybind11 {
+namespace PYBIND11_NAMESPACE {
 namespace detail {
 template <>
 struct type_caster<DestructionTester> {
     PYBIND11_TYPE_CASTER(DestructionTester, const_name("DestructionTester"));
     bool load(handle, bool) { return true; }
 
     static handle cast(const DestructionTester &, return_value_policy, handle) {
         return py::bool_(true).release();
     }
 };
 } // namespace detail
-} // namespace pybind11
+} // namespace PYBIND11_NAMESPACE
 
 // Define type caster outside of `pybind11::detail` and then alias it.
 namespace other_lib {
 struct MyType {};
 // Corrupt `py` shorthand alias for surrounding context.
 namespace py {}
 // Corrupt unqualified relative `pybind11` namespace.
-namespace pybind11 {}
+namespace PYBIND11_NAMESPACE {}
 // Correct alias.
 namespace py_ = ::pybind11;
 // Define caster. This is effectively no-op, we only ensure it compiles and we
 // don't have any symbol collision when using macro mixin.
 struct my_caster {
     PYBIND11_TYPE_CASTER(MyType, py_::detail::const_name("MyType"));
     bool load(py_::handle, bool) { return true; }
 
     static py_::handle cast(const MyType &, py_::return_value_policy, py_::handle) {
         return py_::bool_(true).release();
     }
 };
 } // namespace other_lib
 // Effectively "alias" it into correct namespace (via inheritance).
-namespace pybind11 {
+namespace PYBIND11_NAMESPACE {
 namespace detail {
 template <>
 struct type_caster<other_lib::MyType> : public other_lib::my_caster {};
 } // namespace detail
-} // namespace pybind11
+} // namespace PYBIND11_NAMESPACE
+
+// This simply is required to compile
+namespace ADL_issue {
+template <typename OutStringType = std::string, typename... Args>
+OutStringType concat(Args &&...) {
+    return OutStringType();
+}
+
+struct test {};
+} // namespace ADL_issue
 
 TEST_SUBMODULE(custom_type_casters, m) {
     // test_custom_type_casters
 
     // test_noconvert_args
     //
     // Test converting.  The ArgAlwaysConverts is just there to make the first no-conversion pass
@@ -202,8 +212,10 @@
         []() -> const DestructionTester * { return new DestructionTester(); },
         py::return_value_policy::take_ownership); // Likewise (const doesn't inhibit destruction)
     m.def("destruction_tester_cstats",
           &ConstructorStats::get<DestructionTester>,
           py::return_value_policy::reference);
 
     m.def("other_lib_type", [](other_lib::MyType x) { return x; });
+
+    m.def("_adl_issue", [](const ADL_issue::test &) {});
 }
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_custom_type_casters.py` & `python_prtree-0.6.1/third/pybind11/tests/test_custom_type_casters.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 import pytest
 
 from pybind11_tests import custom_type_casters as m
 
 
 def test_noconvert_args(msg):
     a = m.ArgInspector()
@@ -15,24 +14,24 @@
     assert (
         msg(a.g("this is a", "this is b"))
         == """
         loading ArgInspector1 argument WITHOUT conversion allowed.  Argument value = this is a
         loading ArgInspector1 argument WITH conversion allowed.  Argument value = this is b
         13
         loading ArgInspector2 argument WITH conversion allowed.  Argument value = (default arg inspector 2)
-    """  # noqa: E501 line too long
+    """
     )
     assert (
         msg(a.g("this is a", "this is b", 42))
         == """
         loading ArgInspector1 argument WITHOUT conversion allowed.  Argument value = this is a
         loading ArgInspector1 argument WITH conversion allowed.  Argument value = this is b
         42
         loading ArgInspector2 argument WITH conversion allowed.  Argument value = (default arg inspector 2)
-    """  # noqa: E501 line too long
+    """
     )
     assert (
         msg(a.g("this is a", "this is b", 42, "this is d"))
         == """
         loading ArgInspector1 argument WITHOUT conversion allowed.  Argument value = this is a
         loading ArgInspector1 argument WITH conversion allowed.  Argument value = this is b
         42
@@ -72,15 +71,15 @@
     assert (
         msg(excinfo.value)
         == """
         ints_preferred(): incompatible function arguments. The following argument types are supported:
             1. (i: int) -> int
 
         Invoked with: 4.0
-    """  # noqa: E501 line too long
+    """
     )
 
     assert m.ints_only(4) == 2
     with pytest.raises(TypeError) as excinfo:
         m.ints_only(4.0)
     assert (
         msg(excinfo.value)
@@ -91,20 +90,22 @@
         Invoked with: 4.0
     """
     )
 
 
 def test_custom_caster_destruction():
     """Tests that returning a pointer to a type that gets converted with a custom type caster gets
-    destroyed when the function has py::return_value_policy::take_ownership policy applied."""
+    destroyed when the function has py::return_value_policy::take_ownership policy applied.
+    """
 
     cstats = m.destruction_tester_cstats()
     # This one *doesn't* have take_ownership: the pointer should be used but not destroyed:
     z = m.custom_caster_no_destroy()
-    assert cstats.alive() == 1 and cstats.default_constructions == 1
+    assert cstats.alive() == 1
+    assert cstats.default_constructions == 1
     assert z
 
     # take_ownership applied: this constructs a new object, casts it, then destroys it:
     z = m.custom_caster_destroy()
     assert z
     assert cstats.default_constructions == 2
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_custom_type_setup.cpp` & `python_prtree-0.6.1/third/pybind11/tests/test_custom_type_setup.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_custom_type_setup.py` & `python_prtree-0.6.1/third/pybind11/tests/test_custom_type_setup.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,19 +1,17 @@
-# -*- coding: utf-8 -*-
-
 import gc
 import weakref
 
 import pytest
 
 import env  # noqa: F401
 from pybind11_tests import custom_type_setup as m
 
 
-@pytest.fixture
+@pytest.fixture()
 def gc_tester():
     """Tests that an object is garbage collected.
 
     Assumes that any unreferenced objects are fully collected after calling
     `gc.collect()`.  That is true on CPython, but does not appear to reliably
     hold on PyPy.
     """
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_docstring_options.py` & `python_prtree-0.6.1/third/pybind11/tests/test_docstring_options.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 from pybind11_tests import docstring_options as m
 
 
 def test_docstring_options():
     # options.disable_function_signatures()
     assert not m.test_function1.__doc__
 
@@ -36,7 +35,30 @@
 
     # when all options are disabled, no docstring (instead of an empty one) should be generated
     assert m.test_function8.__doc__ is None
 
     # Suppression of user-defined docstrings for non-function objects
     assert not m.DocstringTestFoo.__doc__
     assert not m.DocstringTestFoo.value_prop.__doc__
+
+    # Check existig behaviour of enum docstings
+    assert (
+        m.DocstringTestEnum1.__doc__
+        == "Enum docstring\n\nMembers:\n\n  Member1\n\n  Member2"
+    )
+
+    # options.enable_enum_members_docstring()
+    assert (
+        m.DocstringTestEnum2.__doc__
+        == "Enum docstring\n\nMembers:\n\n  Member1\n\n  Member2"
+    )
+
+    # options.disable_enum_members_docstring()
+    assert m.DocstringTestEnum3.__doc__ == "Enum docstring"
+
+    # options.disable_user_defined_docstrings()
+    assert m.DocstringTestEnum4.__doc__ == "Members:\n\n  Member1\n\n  Member2"
+
+    # options.disable_user_defined_docstrings()
+    # options.disable_enum_members_docstring()
+    # When all options are disabled, no docstring (instead of an empty one) should be generated
+    assert m.DocstringTestEnum5.__doc__ is None
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_eigen.cpp` & `python_prtree-0.6.1/third/pybind11/tests/test_eigen_matrix.cpp`

 * *Files 9% similar despite different names*

```diff
@@ -3,26 +3,21 @@
 
     Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
 
     All rights reserved. Use of this source code is governed by a
     BSD-style license that can be found in the LICENSE file.
 */
 
-#include <pybind11/eigen.h>
+#include <pybind11/eigen/matrix.h>
 #include <pybind11/stl.h>
 
 #include "constructor_stats.h"
 #include "pybind11_tests.h"
 
-#if defined(_MSC_VER)
-#    if _MSC_VER < 1910                 // VS 2015's MSVC
-#        pragma warning(disable : 4127) // C4127: conditional expression is constant
-#    endif
-#    pragma warning(disable : 4996) // C4996: std::unary_negation is deprecated
-#endif
+PYBIND11_WARNING_DISABLE_MSVC(4996)
 
 #include <Eigen/Cholesky>
 
 using MatrixXdR = Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor>;
 
 // Sets/resets a testing reference matrix to have values of 10*r + c, where r and c are the
 // (1-based) row/column number.
@@ -80,15 +75,15 @@
 
     Eigen::Matrix4d a = Eigen::Matrix4d::Zero();
     Eigen::Matrix4d b = Eigen::Matrix4d::Identity();
 
     EIGEN_MAKE_ALIGNED_OPERATOR_NEW;
 };
 
-TEST_SUBMODULE(eigen, m) {
+TEST_SUBMODULE(eigen_matrix, m) {
     using FixedMatrixR = Eigen::Matrix<float, 5, 6, Eigen::RowMajor>;
     using FixedMatrixC = Eigen::Matrix<float, 5, 6>;
     using DenseMatrixR = Eigen::Matrix<float, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor>;
     using DenseMatrixC = Eigen::Matrix<float, Eigen::Dynamic, Eigen::Dynamic>;
     using FourRowMatrixC = Eigen::Matrix<float, 4, Eigen::Dynamic>;
     using FourColMatrixC = Eigen::Matrix<float, Eigen::Dynamic, 4>;
     using FourRowMatrixR = Eigen::Matrix<float, 4, Eigen::Dynamic>;
@@ -196,19 +191,48 @@
     m.def("diagonal_1",
           [](const Eigen::Ref<const Eigen::MatrixXd> &x) { return x.diagonal<1>(); });
     m.def("diagonal_n",
           [](const Eigen::Ref<const Eigen::MatrixXd> &x, int index) { return x.diagonal(index); });
 
     // Return a block of a matrix (gives non-standard strides)
     m.def("block",
-          [](const Eigen::Ref<const Eigen::MatrixXd> &x,
-             int start_row,
-             int start_col,
-             int block_rows,
-             int block_cols) { return x.block(start_row, start_col, block_rows, block_cols); });
+          [m](const py::object &x_obj,
+              int start_row,
+              int start_col,
+              int block_rows,
+              int block_cols) {
+              return m.attr("_block")(x_obj, x_obj, start_row, start_col, block_rows, block_cols);
+          });
+
+    m.def(
+        "_block",
+        [](const py::object &x_obj,
+           const Eigen::Ref<const Eigen::MatrixXd> &x,
+           int start_row,
+           int start_col,
+           int block_rows,
+           int block_cols) {
+            // See PR #4217 for background. This test is a bit over the top, but might be useful
+            // as a concrete example to point to when explaining the dangling reference trap.
+            auto i0 = py::make_tuple(0, 0);
+            auto x0_orig = x_obj[*i0].cast<double>();
+            if (x(0, 0) != x0_orig) {
+                throw std::runtime_error(
+                    "Something in the type_caster for Eigen::Ref is terribly wrong.");
+            }
+            double x0_mod = x0_orig + 1;
+            x_obj[*i0] = x0_mod;
+            auto copy_detected = (x(0, 0) != x0_mod);
+            x_obj[*i0] = x0_orig;
+            if (copy_detected) {
+                throw std::runtime_error("type_caster for Eigen::Ref made a copy.");
+            }
+            return x.block(start_row, start_col, block_rows, block_cols);
+        },
+        py::keep_alive<0, 1>());
 
     // test_eigen_return_references, test_eigen_keepalive
     // return value referencing/copying tests:
     class ReturnTester {
         Eigen::MatrixXd mat = create();
 
     public:
@@ -302,14 +326,31 @@
     m.def("fixed_mutator_c", [](const Eigen::Ref<FixedMatrixC> &) {});
     m.def("fixed_mutator_a", [](const py::EigenDRef<FixedMatrixC> &) {});
     // test_dense
     m.def("dense_r", [mat]() -> DenseMatrixR { return DenseMatrixR(mat); });
     m.def("dense_c", [mat]() -> DenseMatrixC { return DenseMatrixC(mat); });
     m.def("dense_copy_r", [](const DenseMatrixR &m) -> DenseMatrixR { return m; });
     m.def("dense_copy_c", [](const DenseMatrixC &m) -> DenseMatrixC { return m; });
+    // test_defaults
+    bool have_numpy = true;
+    try {
+        py::module_::import("numpy");
+    } catch (const py::error_already_set &) {
+        have_numpy = false;
+    }
+    if (have_numpy) {
+        py::module_::import("numpy");
+        Eigen::Matrix<double, 3, 3> defaultMatrix = Eigen::Matrix3d::Identity();
+        m.def(
+            "defaults_mat", [](const Eigen::Matrix3d &) {}, py::arg("mat") = defaultMatrix);
+
+        Eigen::VectorXd defaultVector = Eigen::VectorXd::Ones(32);
+        m.def(
+            "defaults_vec", [](const Eigen::VectorXd &) {}, py::arg("vec") = defaultMatrix);
+    }
     // test_sparse, test_sparse_signature
     m.def("sparse_r", [mat]() -> SparseMatrixR {
         // NOLINTNEXTLINE(clang-analyzer-core.uninitialized.UndefReturn)
         return Eigen::SparseView<Eigen::MatrixXf>(mat);
     });
     m.def("sparse_c",
           [mat]() -> SparseMatrixC { return Eigen::SparseView<Eigen::MatrixXf>(mat); });
@@ -344,18 +385,21 @@
     m.def(
         "get_elem_rm_nocopy",
         [](Eigen::Ref<const Eigen::Matrix<long, -1, -1, Eigen::RowMajor>> &m) -> long {
             return m(2, 1);
         },
         py::arg{}.noconvert());
 
-    // test_issue738
-    // Issue #738: 1xN or Nx1 2D matrices were neither accepted nor properly copied with an
+    // test_issue738, test_zero_length
+    // Issue #738: 1N or N1 2D matrices were neither accepted nor properly copied with an
     // incompatible stride value on the length-1 dimension--but that should be allowed (without
     // requiring a copy!) because the stride value can be safely ignored on a size-1 dimension.
+    // Similarly, 0N or N0 matrices were not accepted--again, these should be allowed since
+    // they contain no data. This particularly affects numpy  1.23, which sets the strides to
+    // 0 if any dimension size is 0.
     m.def("iss738_f1",
           &adjust_matrix<const Eigen::Ref<const Eigen::MatrixXd> &>,
           py::arg{}.noconvert());
     m.def("iss738_f2",
           &adjust_matrix<const Eigen::Ref<const Eigen::Matrix<double, -1, -1, Eigen::RowMajor>> &>,
           py::arg{}.noconvert());
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_eigen.py` & `python_prtree-0.6.1/third/pybind11/tests/test_eigen_matrix.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,14 +1,13 @@
-# -*- coding: utf-8 -*-
 import pytest
 
 from pybind11_tests import ConstructorStats
 
 np = pytest.importorskip("numpy")
-m = pytest.importorskip("pybind11_tests.eigen")
+m = pytest.importorskip("pybind11_tests.eigen_matrix")
 
 
 ref = np.array(
     [
         [0.0, 3, 0, 0, 0, 11],
         [22, 0, 0, 0, 17, 11],
         [7, 5, 0, 1, 0, 11],
@@ -197,51 +196,58 @@
         m.double_threer(second_row)
     assert (
         msg(excinfo.value)
         == """
         double_threer(): incompatible function arguments. The following argument types are supported:
             1. (arg0: numpy.ndarray[numpy.float32[1, 3], flags.writeable]) -> None
 
-        Invoked with: """  # noqa: E501 line too long
+        Invoked with: """
         + repr(np.array([5.0, 4.0, 3.0], dtype="float32"))
     )
 
     with pytest.raises(TypeError) as excinfo:
         m.double_threec(second_col)
     assert (
         msg(excinfo.value)
         == """
         double_threec(): incompatible function arguments. The following argument types are supported:
             1. (arg0: numpy.ndarray[numpy.float32[3, 1], flags.writeable]) -> None
 
-        Invoked with: """  # noqa: E501 line too long
+        Invoked with: """
         + repr(np.array([7.0, 4.0, 1.0], dtype="float32"))
     )
 
 
+def test_block_runtime_error_type_caster_eigen_ref_made_a_copy():
+    with pytest.raises(RuntimeError) as excinfo:
+        m.block(ref, 0, 0, 0, 0)
+    assert str(excinfo.value) == "type_caster for Eigen::Ref made a copy."
+
+
 def test_nonunit_stride_to_python():
     assert np.all(m.diagonal(ref) == ref.diagonal())
     assert np.all(m.diagonal_1(ref) == ref.diagonal(1))
     for i in range(-5, 7):
-        assert np.all(
-            m.diagonal_n(ref, i) == ref.diagonal(i)
-        ), "m.diagonal_n({})".format(i)
+        assert np.all(m.diagonal_n(ref, i) == ref.diagonal(i)), f"m.diagonal_n({i})"
 
-    assert np.all(m.block(ref, 2, 1, 3, 3) == ref[2:5, 1:4])
-    assert np.all(m.block(ref, 1, 4, 4, 2) == ref[1:, 4:])
-    assert np.all(m.block(ref, 1, 4, 3, 2) == ref[1:4, 4:])
+    # Must be order="F", otherwise the type_caster will make a copy and
+    # m.block() will return a dangling reference (heap-use-after-free).
+    rof = np.asarray(ref, order="F")
+    assert np.all(m.block(rof, 2, 1, 3, 3) == rof[2:5, 1:4])
+    assert np.all(m.block(rof, 1, 4, 4, 2) == rof[1:, 4:])
+    assert np.all(m.block(rof, 1, 4, 3, 2) == rof[1:4, 4:])
 
 
 def test_eigen_ref_to_python():
     chols = [m.cholesky1, m.cholesky2, m.cholesky3, m.cholesky4]
     for i, chol in enumerate(chols, start=1):
         mymat = chol(np.array([[1.0, 2, 4], [2, 13, 23], [4, 23, 77]]))
         assert np.all(
             mymat == np.array([[1, 0, 0], [2, 3, 0], [4, 5, 6]])
-        ), "cholesky{}".format(i)
+        ), f"cholesky{i}"
 
 
 def assign_both(a1, a2, r, c, v):
     a1[r, c] = v
     a2[r, c] = v
 
 
@@ -250,119 +256,137 @@
     z[r, c] = v
     return z
 
 
 def test_eigen_return_references():
     """Tests various ways of returning references and non-referencing copies"""
 
-    master = np.ones((10, 10))
+    primary = np.ones((10, 10))
     a = m.ReturnTester()
     a_get1 = a.get()
-    assert not a_get1.flags.owndata and a_get1.flags.writeable
-    assign_both(a_get1, master, 3, 3, 5)
+    assert not a_get1.flags.owndata
+    assert a_get1.flags.writeable
+    assign_both(a_get1, primary, 3, 3, 5)
     a_get2 = a.get_ptr()
-    assert not a_get2.flags.owndata and a_get2.flags.writeable
-    assign_both(a_get1, master, 2, 3, 6)
+    assert not a_get2.flags.owndata
+    assert a_get2.flags.writeable
+    assign_both(a_get1, primary, 2, 3, 6)
 
     a_view1 = a.view()
-    assert not a_view1.flags.owndata and not a_view1.flags.writeable
+    assert not a_view1.flags.owndata
+    assert not a_view1.flags.writeable
     with pytest.raises(ValueError):
         a_view1[2, 3] = 4
     a_view2 = a.view_ptr()
-    assert not a_view2.flags.owndata and not a_view2.flags.writeable
+    assert not a_view2.flags.owndata
+    assert not a_view2.flags.writeable
     with pytest.raises(ValueError):
         a_view2[2, 3] = 4
 
     a_copy1 = a.copy_get()
-    assert a_copy1.flags.owndata and a_copy1.flags.writeable
-    np.testing.assert_array_equal(a_copy1, master)
+    assert a_copy1.flags.owndata
+    assert a_copy1.flags.writeable
+    np.testing.assert_array_equal(a_copy1, primary)
     a_copy1[7, 7] = -44  # Shouldn't affect anything else
-    c1want = array_copy_but_one(master, 7, 7, -44)
+    c1want = array_copy_but_one(primary, 7, 7, -44)
     a_copy2 = a.copy_view()
-    assert a_copy2.flags.owndata and a_copy2.flags.writeable
-    np.testing.assert_array_equal(a_copy2, master)
+    assert a_copy2.flags.owndata
+    assert a_copy2.flags.writeable
+    np.testing.assert_array_equal(a_copy2, primary)
     a_copy2[4, 4] = -22  # Shouldn't affect anything else
-    c2want = array_copy_but_one(master, 4, 4, -22)
+    c2want = array_copy_but_one(primary, 4, 4, -22)
 
     a_ref1 = a.ref()
-    assert not a_ref1.flags.owndata and a_ref1.flags.writeable
-    assign_both(a_ref1, master, 1, 1, 15)
+    assert not a_ref1.flags.owndata
+    assert a_ref1.flags.writeable
+    assign_both(a_ref1, primary, 1, 1, 15)
     a_ref2 = a.ref_const()
-    assert not a_ref2.flags.owndata and not a_ref2.flags.writeable
+    assert not a_ref2.flags.owndata
+    assert not a_ref2.flags.writeable
     with pytest.raises(ValueError):
         a_ref2[5, 5] = 33
     a_ref3 = a.ref_safe()
-    assert not a_ref3.flags.owndata and a_ref3.flags.writeable
-    assign_both(a_ref3, master, 0, 7, 99)
+    assert not a_ref3.flags.owndata
+    assert a_ref3.flags.writeable
+    assign_both(a_ref3, primary, 0, 7, 99)
     a_ref4 = a.ref_const_safe()
-    assert not a_ref4.flags.owndata and not a_ref4.flags.writeable
+    assert not a_ref4.flags.owndata
+    assert not a_ref4.flags.writeable
     with pytest.raises(ValueError):
         a_ref4[7, 0] = 987654321
 
     a_copy3 = a.copy_ref()
-    assert a_copy3.flags.owndata and a_copy3.flags.writeable
-    np.testing.assert_array_equal(a_copy3, master)
+    assert a_copy3.flags.owndata
+    assert a_copy3.flags.writeable
+    np.testing.assert_array_equal(a_copy3, primary)
     a_copy3[8, 1] = 11
-    c3want = array_copy_but_one(master, 8, 1, 11)
+    c3want = array_copy_but_one(primary, 8, 1, 11)
     a_copy4 = a.copy_ref_const()
-    assert a_copy4.flags.owndata and a_copy4.flags.writeable
-    np.testing.assert_array_equal(a_copy4, master)
+    assert a_copy4.flags.owndata
+    assert a_copy4.flags.writeable
+    np.testing.assert_array_equal(a_copy4, primary)
     a_copy4[8, 4] = 88
-    c4want = array_copy_but_one(master, 8, 4, 88)
+    c4want = array_copy_but_one(primary, 8, 4, 88)
 
     a_block1 = a.block(3, 3, 2, 2)
-    assert not a_block1.flags.owndata and a_block1.flags.writeable
+    assert not a_block1.flags.owndata
+    assert a_block1.flags.writeable
     a_block1[0, 0] = 55
-    master[3, 3] = 55
+    primary[3, 3] = 55
     a_block2 = a.block_safe(2, 2, 3, 2)
-    assert not a_block2.flags.owndata and a_block2.flags.writeable
+    assert not a_block2.flags.owndata
+    assert a_block2.flags.writeable
     a_block2[2, 1] = -123
-    master[4, 3] = -123
+    primary[4, 3] = -123
     a_block3 = a.block_const(6, 7, 4, 3)
-    assert not a_block3.flags.owndata and not a_block3.flags.writeable
+    assert not a_block3.flags.owndata
+    assert not a_block3.flags.writeable
     with pytest.raises(ValueError):
         a_block3[2, 2] = -44444
 
     a_copy5 = a.copy_block(2, 2, 2, 3)
-    assert a_copy5.flags.owndata and a_copy5.flags.writeable
-    np.testing.assert_array_equal(a_copy5, master[2:4, 2:5])
+    assert a_copy5.flags.owndata
+    assert a_copy5.flags.writeable
+    np.testing.assert_array_equal(a_copy5, primary[2:4, 2:5])
     a_copy5[1, 1] = 777
-    c5want = array_copy_but_one(master[2:4, 2:5], 1, 1, 777)
+    c5want = array_copy_but_one(primary[2:4, 2:5], 1, 1, 777)
 
     a_corn1 = a.corners()
-    assert not a_corn1.flags.owndata and a_corn1.flags.writeable
+    assert not a_corn1.flags.owndata
+    assert a_corn1.flags.writeable
     a_corn1 *= 50
     a_corn1[1, 1] = 999
-    master[0, 0] = 50
-    master[0, 9] = 50
-    master[9, 0] = 50
-    master[9, 9] = 999
+    primary[0, 0] = 50
+    primary[0, 9] = 50
+    primary[9, 0] = 50
+    primary[9, 9] = 999
     a_corn2 = a.corners_const()
-    assert not a_corn2.flags.owndata and not a_corn2.flags.writeable
+    assert not a_corn2.flags.owndata
+    assert not a_corn2.flags.writeable
     with pytest.raises(ValueError):
         a_corn2[1, 0] = 51
 
     # All of the changes made all the way along should be visible everywhere
     # now (except for the copies, of course)
-    np.testing.assert_array_equal(a_get1, master)
-    np.testing.assert_array_equal(a_get2, master)
-    np.testing.assert_array_equal(a_view1, master)
-    np.testing.assert_array_equal(a_view2, master)
-    np.testing.assert_array_equal(a_ref1, master)
-    np.testing.assert_array_equal(a_ref2, master)
-    np.testing.assert_array_equal(a_ref3, master)
-    np.testing.assert_array_equal(a_ref4, master)
-    np.testing.assert_array_equal(a_block1, master[3:5, 3:5])
-    np.testing.assert_array_equal(a_block2, master[2:5, 2:4])
-    np.testing.assert_array_equal(a_block3, master[6:10, 7:10])
+    np.testing.assert_array_equal(a_get1, primary)
+    np.testing.assert_array_equal(a_get2, primary)
+    np.testing.assert_array_equal(a_view1, primary)
+    np.testing.assert_array_equal(a_view2, primary)
+    np.testing.assert_array_equal(a_ref1, primary)
+    np.testing.assert_array_equal(a_ref2, primary)
+    np.testing.assert_array_equal(a_ref3, primary)
+    np.testing.assert_array_equal(a_ref4, primary)
+    np.testing.assert_array_equal(a_block1, primary[3:5, 3:5])
+    np.testing.assert_array_equal(a_block2, primary[2:5, 2:4])
+    np.testing.assert_array_equal(a_block3, primary[6:10, 7:10])
     np.testing.assert_array_equal(
-        a_corn1, master[0 :: master.shape[0] - 1, 0 :: master.shape[1] - 1]
+        a_corn1, primary[0 :: primary.shape[0] - 1, 0 :: primary.shape[1] - 1]
     )
     np.testing.assert_array_equal(
-        a_corn2, master[0 :: master.shape[0] - 1, 0 :: master.shape[1] - 1]
+        a_corn2, primary[0 :: primary.shape[0] - 1, 0 :: primary.shape[1] - 1]
     )
 
     np.testing.assert_array_equal(a_copy1, c1want)
     np.testing.assert_array_equal(a_copy2, c2want)
     np.testing.assert_array_equal(a_copy3, c3want)
     np.testing.assert_array_equal(a_copy4, c4want)
     np.testing.assert_array_equal(a_copy5, c5want)
@@ -493,18 +517,22 @@
     zc = m.get_cm_ref()
     zcro = m.get_cm_const_ref()
     zr = m.get_rm_ref()
     zrro = m.get_rm_const_ref()
 
     assert [zc[1, 2], zcro[1, 2], zr[1, 2], zrro[1, 2]] == [23] * 4
 
-    assert not zc.flags.owndata and zc.flags.writeable
-    assert not zr.flags.owndata and zr.flags.writeable
-    assert not zcro.flags.owndata and not zcro.flags.writeable
-    assert not zrro.flags.owndata and not zrro.flags.writeable
+    assert not zc.flags.owndata
+    assert zc.flags.writeable
+    assert not zr.flags.owndata
+    assert zr.flags.writeable
+    assert not zcro.flags.owndata
+    assert not zcro.flags.writeable
+    assert not zrro.flags.owndata
+    assert not zrro.flags.writeable
 
     zc[1, 2] = 99
     expect = np.array([[11.0, 12, 13], [21, 22, 99], [31, 32, 33]])
     # We should have just changed zc, of course, but also zcro and the original eigen matrix
     assert np.all(zc == expect)
     assert np.all(zcro == expect)
     assert np.all(m.get_cm_ref() == expect)
@@ -520,15 +548,16 @@
     with pytest.raises(ValueError):
         zrro[1, 2] = 6
 
     # We should be able to explicitly copy like this (and since we're copying,
     # the const should drop away)
     y1 = np.array(m.get_cm_const_ref())
 
-    assert y1.flags.owndata and y1.flags.writeable
+    assert y1.flags.owndata
+    assert y1.flags.writeable
     # We should get copies of the eigen data, which was modified above:
     assert y1[1, 2] == 99
     y1[1, 2] += 12
     assert y1[1, 2] == 111
     assert zc[1, 2] == 99  # Make sure we aren't referencing the original
 
 
@@ -575,15 +604,17 @@
     assert np.all(y2 == yexpect)
     assert np.all(y == yexpect)
 
 
 def test_nocopy_wrapper():
     # get_elem requires a column-contiguous matrix reference, but should be
     # callable with other types of matrix (via copying):
-    int_matrix_colmajor = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]], order="F")
+    int_matrix_colmajor = np.array(
+        [[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype="l", order="F"
+    )
     dbl_matrix_colmajor = np.array(
         int_matrix_colmajor, dtype="double", order="F", copy=True
     )
     int_matrix_rowmajor = np.array(int_matrix_colmajor, order="C", copy=True)
     dbl_matrix_rowmajor = np.array(
         int_matrix_rowmajor, dtype="double", order="C", copy=True
     )
@@ -593,46 +624,46 @@
     assert m.get_elem(dbl_matrix_colmajor) == 8
     assert m.get_elem(int_matrix_rowmajor) == 8
     assert m.get_elem(dbl_matrix_rowmajor) == 8
 
     # All but the second should fail with m.get_elem_nocopy:
     with pytest.raises(TypeError) as excinfo:
         m.get_elem_nocopy(int_matrix_colmajor)
-    assert "get_elem_nocopy(): incompatible function arguments." in str(
-        excinfo.value
-    ) and ", flags.f_contiguous" in str(excinfo.value)
+    assert "get_elem_nocopy(): incompatible function arguments." in str(excinfo.value)
+    assert ", flags.f_contiguous" in str(excinfo.value)
     assert m.get_elem_nocopy(dbl_matrix_colmajor) == 8
     with pytest.raises(TypeError) as excinfo:
         m.get_elem_nocopy(int_matrix_rowmajor)
-    assert "get_elem_nocopy(): incompatible function arguments." in str(
-        excinfo.value
-    ) and ", flags.f_contiguous" in str(excinfo.value)
+    assert "get_elem_nocopy(): incompatible function arguments." in str(excinfo.value)
+    assert ", flags.f_contiguous" in str(excinfo.value)
     with pytest.raises(TypeError) as excinfo:
         m.get_elem_nocopy(dbl_matrix_rowmajor)
-    assert "get_elem_nocopy(): incompatible function arguments." in str(
-        excinfo.value
-    ) and ", flags.f_contiguous" in str(excinfo.value)
+    assert "get_elem_nocopy(): incompatible function arguments." in str(excinfo.value)
+    assert ", flags.f_contiguous" in str(excinfo.value)
 
     # For the row-major test, we take a long matrix in row-major, so only the third is allowed:
     with pytest.raises(TypeError) as excinfo:
         m.get_elem_rm_nocopy(int_matrix_colmajor)
     assert "get_elem_rm_nocopy(): incompatible function arguments." in str(
         excinfo.value
-    ) and ", flags.c_contiguous" in str(excinfo.value)
+    )
+    assert ", flags.c_contiguous" in str(excinfo.value)
     with pytest.raises(TypeError) as excinfo:
         m.get_elem_rm_nocopy(dbl_matrix_colmajor)
     assert "get_elem_rm_nocopy(): incompatible function arguments." in str(
         excinfo.value
-    ) and ", flags.c_contiguous" in str(excinfo.value)
+    )
+    assert ", flags.c_contiguous" in str(excinfo.value)
     assert m.get_elem_rm_nocopy(int_matrix_rowmajor) == 8
     with pytest.raises(TypeError) as excinfo:
         m.get_elem_rm_nocopy(dbl_matrix_rowmajor)
     assert "get_elem_rm_nocopy(): incompatible function arguments." in str(
         excinfo.value
-    ) and ", flags.c_contiguous" in str(excinfo.value)
+    )
+    assert ", flags.c_contiguous" in str(excinfo.value)
 
 
 def test_eigen_ref_life_support():
     """Ensure the lifetime of temporary arrays created by the `Ref` caster
 
     The `Ref` caster sometimes creates a copy which needs to stay alive. This needs to
     happen both for directs casts (just the array) or indirectly (e.g. list of arrays).
@@ -683,14 +714,19 @@
         """
         double_mat_rm(arg0: numpy.ndarray[numpy.float32[m, n]])"""
         """ -> numpy.ndarray[numpy.float32[m, n]]
     """
     )
 
 
+def test_defaults(doc):
+    assert "\n" not in str(doc(m.defaults_mat))
+    assert "\n" not in str(doc(m.defaults_vec))
+
+
 def test_named_arguments():
     a = np.array([[1.0, 2], [3, 4], [5, 6]])
     b = np.ones((2, 1))
 
     assert np.all(m.matrix_multiply(a, b) == np.array([[3.0], [7], [11]]))
     assert np.all(m.matrix_multiply(A=a, B=b) == np.array([[3.0], [7], [11]]))
     assert np.all(m.matrix_multiply(B=b, A=a) == np.array([[3.0], [7], [11]]))
@@ -720,21 +756,21 @@
 
 def test_sparse_signature(doc):
     pytest.importorskip("scipy")
     assert (
         doc(m.sparse_copy_r)
         == """
         sparse_copy_r(arg0: scipy.sparse.csr_matrix[numpy.float32]) -> scipy.sparse.csr_matrix[numpy.float32]
-    """  # noqa: E501 line too long
+    """
     )
     assert (
         doc(m.sparse_copy_c)
         == """
         sparse_copy_c(arg0: scipy.sparse.csc_matrix[numpy.float32]) -> scipy.sparse.csc_matrix[numpy.float32]
-    """  # noqa: E501 line too long
+    """
     )
 
 
 def test_issue738():
     """Ignore strides on a length-1 dimension (even if they would be incompatible length > 1)"""
     assert np.all(m.iss738_f1(np.array([[1.0, 2, 3]])) == np.array([[1.0, 102, 203]]))
     assert np.all(
@@ -743,14 +779,21 @@
 
     assert np.all(m.iss738_f2(np.array([[1.0, 2, 3]])) == np.array([[1.0, 102, 203]]))
     assert np.all(
         m.iss738_f2(np.array([[1.0], [2], [3]])) == np.array([[1.0], [12], [23]])
     )
 
 
+@pytest.mark.parametrize("func", [m.iss738_f1, m.iss738_f2])
+@pytest.mark.parametrize("sizes", [(0, 2), (2, 0)])
+def test_zero_length(func, sizes):
+    """Ignore strides on a length-0 dimension (even if they would be incompatible length > 1)"""
+    assert np.all(func(np.zeros(sizes)) == np.zeros(sizes))
+
+
 def test_issue1105():
     """Issue 1105: 1xN or Nx1 input arrays weren't accepted for eigen
     compile-time row vectors or column vector"""
     assert m.iss1105_row(np.ones((1, 7)))
     assert m.iss1105_col(np.ones((7, 1)))
 
     # These should still fail (incompatible dimensions):
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_embed/CMakeLists.txt` & `python_prtree-0.6.1/third/pybind11/tests/test_embed/CMakeLists.txt`

 * *Files 0% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 if("${PYTHON_MODULE_EXTENSION}" MATCHES "pypy" OR "${Python_INTERPRETER_ID}" STREQUAL "PyPy")
   message(STATUS "Skipping embed test on PyPy")
   add_custom_target(cpptest) # Dummy target on PyPy. Embedding is not supported.
   set(_suppress_unused_variable_warning "${DOWNLOAD_CATCH}")
   return()
 endif()
 
-find_package(Catch 2.13.5)
+find_package(Catch 2.13.9)
 
 if(CATCH_FOUND)
   message(STATUS "Building interpreter tests using Catch v${CATCH_VERSION}")
 else()
   message(STATUS "Catch not detected. Interpreter tests will be skipped. Install Catch headers"
                  " manually or use `cmake -DDOWNLOAD_CATCH=ON` to fetch them automatically.")
   return()
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_embed/external_module.cpp` & `python_prtree-0.6.1/third/pybind11/tests/test_embed/external_module.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_embed/test_interpreter.cpp` & `python_prtree-0.6.1/third/pybind11/tests/test_embed/test_interpreter.cpp`

 * *Files 20% similar despite different names*

```diff
@@ -1,25 +1,28 @@
 #include <pybind11/embed.h>
 
-#ifdef _MSC_VER
 // Silence MSVC C++17 deprecation warning from Catch regarding std::uncaught_exceptions (up to
 // catch 2.0.1; this should be fixed in the next catch release after 2.0.1).
-#    pragma warning(disable : 4996)
-#endif
+PYBIND11_WARNING_DISABLE_MSVC(4996)
 
 #include <catch.hpp>
 #include <cstdlib>
 #include <fstream>
 #include <functional>
 #include <thread>
 #include <utility>
 
 namespace py = pybind11;
 using namespace py::literals;
 
+size_t get_sys_path_size() {
+    auto sys_path = py::module::import("sys").attr("path");
+    return py::len(sys_path);
+}
+
 class Widget {
 public:
     explicit Widget(std::string message) : message(std::move(message)) {}
     virtual ~Widget() = default;
 
     std::string the_message() const { return message; }
     virtual int the_answer() const = 0;
@@ -71,14 +74,21 @@
 PYBIND11_EMBEDDED_MODULE(throw_exception, ) { throw std::runtime_error("C++ Error"); }
 
 PYBIND11_EMBEDDED_MODULE(throw_error_already_set, ) {
     auto d = py::dict();
     d["missing"].cast<py::object>();
 }
 
+TEST_CASE("PYTHONPATH is used to update sys.path") {
+    // The setup for this TEST_CASE is in catch.cpp!
+    auto sys_path = py::str(py::module_::import("sys").attr("path")).cast<std::string>();
+    REQUIRE_THAT(sys_path,
+                 Catch::Matchers::Contains("pybind11_test_embed_PYTHONPATH_2099743835476552"));
+}
+
 TEST_CASE("Pass classes and data between modules defined in C++ and Python") {
     auto module_ = py::module_::import("test_interpreter");
     REQUIRE(py::hasattr(module_, "DerivedWidget"));
 
     auto locals = py::dict("hello"_a = "Hello, World!", "x"_a = 5, **module_.attr("__dict__"));
     py::exec(R"(
         widget = DerivedWidget("{} - {}".format(hello, x))
@@ -122,15 +132,14 @@
         p_obj2->func();
     }
 }
 
 TEST_CASE("Import error handling") {
     REQUIRE_NOTHROW(py::module_::import("widget_module"));
     REQUIRE_THROWS_WITH(py::module_::import("throw_exception"), "ImportError: C++ Error");
-#if PY_VERSION_HEX >= 0x03030000
     REQUIRE_THROWS_WITH(py::module_::import("throw_error_already_set"),
                         Catch::Contains("ImportError: initialization failed"));
 
     auto locals = py::dict("is_keyerror"_a = false, "message"_a = "not set");
     py::exec(R"(
         try:
             import throw_error_already_set
@@ -138,18 +147,14 @@
             is_keyerror = type(e.__cause__) == KeyError
             message = str(e.__cause__)
     )",
              py::globals(),
              locals);
     REQUIRE(locals["is_keyerror"].cast<bool>() == true);
     REQUIRE(locals["message"].cast<std::string>() == "'missing'");
-#else
-    REQUIRE_THROWS_WITH(py::module_::import("throw_error_already_set"),
-                        Catch::Contains("ImportError: KeyError"));
-#endif
 }
 
 TEST_CASE("There can be only one interpreter") {
     static_assert(std::is_move_constructible<py::scoped_interpreter>::value, "");
     static_assert(!std::is_move_assignable<py::scoped_interpreter>::value, "");
     static_assert(!std::is_copy_constructible<py::scoped_interpreter>::value, "");
     static_assert(!std::is_copy_assignable<py::scoped_interpreter>::value, "");
@@ -162,28 +167,112 @@
     {
         auto pyi1 = py::scoped_interpreter();
         auto pyi2 = std::move(pyi1);
     }
     py::initialize_interpreter();
 }
 
-bool has_pybind11_internals_builtin() {
-    auto builtins = py::handle(PyEval_GetBuiltins());
-    return builtins.contains(PYBIND11_INTERNALS_ID);
-};
+#if PY_VERSION_HEX >= PYBIND11_PYCONFIG_SUPPORT_PY_VERSION_HEX
+TEST_CASE("Custom PyConfig") {
+    py::finalize_interpreter();
+    PyConfig config;
+    PyConfig_InitPythonConfig(&config);
+    REQUIRE_NOTHROW(py::scoped_interpreter{&config});
+    {
+        py::scoped_interpreter p{&config};
+        REQUIRE(py::module_::import("widget_module").attr("add")(1, 41).cast<int>() == 42);
+    }
+    py::initialize_interpreter();
+}
+
+TEST_CASE("scoped_interpreter with PyConfig_InitIsolatedConfig and argv") {
+    py::finalize_interpreter();
+    {
+        PyConfig config;
+        PyConfig_InitIsolatedConfig(&config);
+        char *argv[] = {strdup("a.out")};
+        py::scoped_interpreter argv_scope{&config, 1, argv};
+        std::free(argv[0]);
+        auto module = py::module::import("test_interpreter");
+        auto py_widget = module.attr("DerivedWidget")("The question");
+        const auto &cpp_widget = py_widget.cast<const Widget &>();
+        REQUIRE(cpp_widget.argv0() == "a.out");
+    }
+    py::initialize_interpreter();
+}
+
+TEST_CASE("scoped_interpreter with PyConfig_InitPythonConfig and argv") {
+    py::finalize_interpreter();
+    {
+        PyConfig config;
+        PyConfig_InitPythonConfig(&config);
+
+        // `initialize_interpreter() overrides the default value for config.parse_argv (`1`) by
+        // changing it to `0`. This test exercises `scoped_interpreter` with the default config.
+        char *argv[] = {strdup("a.out"), strdup("arg1")};
+        py::scoped_interpreter argv_scope(&config, 2, argv);
+        std::free(argv[0]);
+        std::free(argv[1]);
+        auto module = py::module::import("test_interpreter");
+        auto py_widget = module.attr("DerivedWidget")("The question");
+        const auto &cpp_widget = py_widget.cast<const Widget &>();
+        REQUIRE(cpp_widget.argv0() == "arg1");
+    }
+    py::initialize_interpreter();
+}
+#endif
+
+TEST_CASE("Add program dir to path pre-PyConfig") {
+    py::finalize_interpreter();
+    size_t path_size_add_program_dir_to_path_false = 0;
+    {
+        py::scoped_interpreter scoped_interp{true, 0, nullptr, false};
+        path_size_add_program_dir_to_path_false = get_sys_path_size();
+    }
+    {
+        py::scoped_interpreter scoped_interp{};
+        REQUIRE(get_sys_path_size() == path_size_add_program_dir_to_path_false + 1);
+    }
+    py::initialize_interpreter();
+}
+
+#if PY_VERSION_HEX >= PYBIND11_PYCONFIG_SUPPORT_PY_VERSION_HEX
+TEST_CASE("Add program dir to path using PyConfig") {
+    py::finalize_interpreter();
+    size_t path_size_add_program_dir_to_path_false = 0;
+    {
+        PyConfig config;
+        PyConfig_InitPythonConfig(&config);
+        py::scoped_interpreter scoped_interp{&config, 0, nullptr, false};
+        path_size_add_program_dir_to_path_false = get_sys_path_size();
+    }
+    {
+        PyConfig config;
+        PyConfig_InitPythonConfig(&config);
+        py::scoped_interpreter scoped_interp{&config};
+        REQUIRE(get_sys_path_size() == path_size_add_program_dir_to_path_false + 1);
+    }
+    py::initialize_interpreter();
+}
+#endif
+
+bool has_state_dict_internals_obj() {
+    return bool(
+        py::detail::get_internals_obj_from_state_dict(py::detail::get_python_state_dict()));
+}
 
 bool has_pybind11_internals_static() {
     auto **&ipp = py::detail::get_internals_pp();
     return (ipp != nullptr) && (*ipp != nullptr);
 }
 
 TEST_CASE("Restart the interpreter") {
     // Verify pre-restart state.
     REQUIRE(py::module_::import("widget_module").attr("add")(1, 2).cast<int>() == 3);
-    REQUIRE(has_pybind11_internals_builtin());
+    REQUIRE(has_state_dict_internals_obj());
     REQUIRE(has_pybind11_internals_static());
     REQUIRE(py::module_::import("external_module").attr("A")(123).attr("value").cast<int>()
             == 123);
 
     // local and foreign module internals should point to the same internals:
     REQUIRE(reinterpret_cast<uintptr_t>(*py::detail::get_internals_pp())
             == py::module_::import("external_module").attr("internals_at")().cast<uintptr_t>());
@@ -192,39 +281,39 @@
     py::finalize_interpreter();
     REQUIRE(Py_IsInitialized() == 0);
 
     py::initialize_interpreter();
     REQUIRE(Py_IsInitialized() == 1);
 
     // Internals are deleted after a restart.
-    REQUIRE_FALSE(has_pybind11_internals_builtin());
+    REQUIRE_FALSE(has_state_dict_internals_obj());
     REQUIRE_FALSE(has_pybind11_internals_static());
     pybind11::detail::get_internals();
-    REQUIRE(has_pybind11_internals_builtin());
+    REQUIRE(has_state_dict_internals_obj());
     REQUIRE(has_pybind11_internals_static());
     REQUIRE(reinterpret_cast<uintptr_t>(*py::detail::get_internals_pp())
             == py::module_::import("external_module").attr("internals_at")().cast<uintptr_t>());
 
     // Make sure that an interpreter with no get_internals() created until finalize still gets the
     // internals destroyed
     py::finalize_interpreter();
     py::initialize_interpreter();
     bool ran = false;
     py::module_::import("__main__").attr("internals_destroy_test")
         = py::capsule(&ran, [](void *ran) {
               py::detail::get_internals();
               *static_cast<bool *>(ran) = true;
           });
-    REQUIRE_FALSE(has_pybind11_internals_builtin());
+    REQUIRE_FALSE(has_state_dict_internals_obj());
     REQUIRE_FALSE(has_pybind11_internals_static());
     REQUIRE_FALSE(ran);
     py::finalize_interpreter();
     REQUIRE(ran);
     py::initialize_interpreter();
-    REQUIRE_FALSE(has_pybind11_internals_builtin());
+    REQUIRE_FALSE(has_state_dict_internals_obj());
     REQUIRE_FALSE(has_pybind11_internals_static());
 
     // C++ modules can be reloaded.
     auto cpp_module = py::module_::import("widget_module");
     REQUIRE(cpp_module.attr("add")(1, 2).cast<int>() == 3);
 
     // C++ type information is reloaded and can be used in python modules.
@@ -238,25 +327,25 @@
     py::module_::import("__main__").attr("main_tag") = "main interpreter";
     {
         auto m = py::module_::import("widget_module");
         m.attr("extension_module_tag") = "added to module in main interpreter";
 
         REQUIRE(m.attr("add")(1, 2).cast<int>() == 3);
     }
-    REQUIRE(has_pybind11_internals_builtin());
+    REQUIRE(has_state_dict_internals_obj());
     REQUIRE(has_pybind11_internals_static());
 
     /// Create and switch to a subinterpreter.
     auto *main_tstate = PyThreadState_Get();
     auto *sub_tstate = Py_NewInterpreter();
 
     // Subinterpreters get their own copy of builtins. detail::get_internals() still
     // works by returning from the static variable, i.e. all interpreters share a single
     // global pybind11::internals;
-    REQUIRE_FALSE(has_pybind11_internals_builtin());
+    REQUIRE_FALSE(has_state_dict_internals_obj());
     REQUIRE(has_pybind11_internals_static());
 
     // Modules tags should be gone.
     REQUIRE_FALSE(py::hasattr(py::module_::import("__main__"), "tag"));
     {
         auto m = py::module_::import("widget_module");
         REQUIRE_FALSE(py::hasattr(m, "extension_module_tag"));
@@ -287,15 +376,14 @@
     REQUIRE_FALSE(has_pybind11_internals_static());
 
     constexpr auto num_threads = 10;
     auto locals = py::dict("count"_a = 0);
 
     {
         py::gil_scoped_release gil_release{};
-        REQUIRE(has_pybind11_internals_static());
 
         auto threads = std::vector<std::thread>();
         for (auto i = 0; i < num_threads; ++i) {
             threads.emplace_back([&]() {
                 py::gil_scoped_acquire gil{};
                 locals["count"] = locals["count"].cast<int>() + 1;
             });
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_enum.cpp` & `python_prtree-0.6.1/third/pybind11/tests/test_enum.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_enum.py` & `python_prtree-0.6.1/third/pybind11/tests/test_enum.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,11 @@
-# -*- coding: utf-8 -*-
+# ruff: noqa: SIM201 SIM300 SIM202
+
 import pytest
 
-import env
 from pybind11_tests import enums as m
 
 
 def test_unscoped_enum():
     assert str(m.UnscopedEnum.EOne) == "UnscopedEnum.EOne"
     assert str(m.UnscopedEnum.ETwo) == "UnscopedEnum.ETwo"
     assert str(m.EOne) == "UnscopedEnum.EOne"
@@ -56,17 +56,15 @@
 
 Members:
 
   EOne : Docstring for EOne
 
   ETwo : Docstring for ETwo
 
-  EThree : Docstring for EThree""".split(
-        "\n"
-    ):
+  EThree : Docstring for EThree""".split("\n"):
         assert docstring_line in m.UnscopedEnum.__doc__
 
     # Unscoped enums will accept ==/!= int comparisons
     y = m.UnscopedEnum.ETwo
     assert y == 2
     assert 2 == y
     assert y != 3
@@ -237,36 +235,35 @@
     assert str(excinfo.value) == 'SimpleEnum: element "ONE" already exists!'
 
 
 def test_char_underlying_enum():  # Issue #1331/PR #1334:
     assert type(m.ScopedCharEnum.Positive.__int__()) is int
     assert int(m.ScopedChar16Enum.Zero) == 0
     assert hash(m.ScopedChar32Enum.Positive) == 1
-    if env.PY2:
-        assert m.ScopedCharEnum.Positive.__getstate__() == 1  # long
-    else:
-        assert type(m.ScopedCharEnum.Positive.__getstate__()) is int
+    assert type(m.ScopedCharEnum.Positive.__getstate__()) is int
     assert m.ScopedWCharEnum(1) == m.ScopedWCharEnum.Positive
     with pytest.raises(TypeError):
         # Even if the underlying type is char, only an int can be used to construct the enum:
         m.ScopedCharEnum("0")
 
 
 def test_bool_underlying_enum():
     assert type(m.ScopedBoolEnum.TRUE.__int__()) is int
     assert int(m.ScopedBoolEnum.FALSE) == 0
     assert hash(m.ScopedBoolEnum.TRUE) == 1
-    if env.PY2:
-        assert m.ScopedBoolEnum.TRUE.__getstate__() == 1  # long
-    else:
-        assert type(m.ScopedBoolEnum.TRUE.__getstate__()) is int
+    assert type(m.ScopedBoolEnum.TRUE.__getstate__()) is int
     assert m.ScopedBoolEnum(1) == m.ScopedBoolEnum.TRUE
     # Enum could construct with a bool
     # (bool is a strict subclass of int, and False will be converted to 0)
     assert m.ScopedBoolEnum(False) == m.ScopedBoolEnum.FALSE
 
 
 def test_docstring_signatures():
     for enum_type in [m.ScopedEnum, m.UnscopedEnum]:
         for attr in enum_type.__dict__.values():
             # Issue #2623/PR #2637: Add argument names to enum_ methods
             assert "arg0" not in (attr.__doc__ or "")
+
+
+def test_str_signature():
+    for enum_type in [m.ScopedEnum, m.UnscopedEnum]:
+        assert enum_type.__str__.__doc__.startswith("__str__")
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_eval.cpp` & `python_prtree-0.6.1/third/pybind11/tests/test_eval.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_eval.py` & `python_prtree-0.6.1/third/pybind11/tests/test_eval.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 import os
 
 import pytest
 
 import env  # noqa: F401
 from pybind11_tests import eval_ as m
 
@@ -14,15 +13,15 @@
 
     assert m.test_eval()
     assert m.test_eval_single_statement()
 
     assert m.test_eval_failure()
 
 
-@pytest.mark.xfail("env.PYPY and not env.PY2", raises=RuntimeError)
+@pytest.mark.xfail("env.PYPY", raises=RuntimeError)
 def test_eval_file():
     filename = os.path.join(os.path.dirname(__file__), "test_eval_call.py")
     assert m.test_eval_file(filename)
 
     assert m.test_eval_file_failure()
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_factory_constructors.cpp` & `python_prtree-0.6.1/third/pybind11/tests/test_factory_constructors.cpp`

 * *Files 1% similar despite different names*

```diff
@@ -377,21 +377,14 @@
             return p;
         }
         static void operator delete(void *p, size_t) {
             py::print("noisy delete");
             ::operator delete(p);
         }
         static void operator delete(void *, void *) { py::print("noisy placement delete"); }
-#if defined(_MSC_VER) && _MSC_VER < 1910
-        // MSVC 2015 bug: the above "noisy delete" isn't invoked (fixed in MSVC 2017)
-        static void operator delete(void *p) {
-            py::print("noisy delete");
-            ::operator delete(p);
-        }
-#endif
     };
 
     py::class_<NoisyAlloc> pyNoisyAlloc(m, "NoisyAlloc");
     // Since these overloads have the same number of arguments, the dispatcher will try each of
     // them until the arguments convert.  Thus we can get a pre-allocation here when passing a
     // single non-integer:
     ignoreOldStyleInitWarnings([&pyNoisyAlloc]() {
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_factory_constructors.py` & `python_prtree-0.6.1/third/pybind11/tests/test_factory_constructors.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,13 +1,11 @@
-# -*- coding: utf-8 -*-
 import re
 
 import pytest
 
-import env  # noqa: F401
 from pybind11_tests import ConstructorStats
 from pybind11_tests import factory_constructors as m
 from pybind11_tests.factory_constructors import tag
 
 
 def test_init_factory_basic():
     """Tests py::init_factory() wrapper around various ways of returning the object"""
@@ -75,34 +73,34 @@
     assert (
         msg(excinfo.value)
         == """
         __init__(): incompatible constructor arguments. The following argument types are supported:
             1. m.factory_constructors.TestFactory1(arg0: m.factory_constructors.tag.unique_ptr_tag, arg1: int)
             2. m.factory_constructors.TestFactory1(arg0: str)
             3. m.factory_constructors.TestFactory1(arg0: m.factory_constructors.tag.pointer_tag)
-            4. m.factory_constructors.TestFactory1(arg0: handle, arg1: int, arg2: handle)
+            4. m.factory_constructors.TestFactory1(arg0: object, arg1: int, arg2: object)
 
         Invoked with: 'invalid', 'constructor', 'arguments'
-    """  # noqa: E501 line too long
+    """
     )
 
     assert (
         msg(m.TestFactory1.__init__.__doc__)
         == """
         __init__(*args, **kwargs)
         Overloaded function.
 
         1. __init__(self: m.factory_constructors.TestFactory1, arg0: m.factory_constructors.tag.unique_ptr_tag, arg1: int) -> None
 
         2. __init__(self: m.factory_constructors.TestFactory1, arg0: str) -> None
 
         3. __init__(self: m.factory_constructors.TestFactory1, arg0: m.factory_constructors.tag.pointer_tag) -> None
 
-        4. __init__(self: m.factory_constructors.TestFactory1, arg0: handle, arg1: int, arg2: handle) -> None
-    """  # noqa: E501 line too long
+        4. __init__(self: m.factory_constructors.TestFactory1, arg0: object, arg1: int, arg2: object) -> None
+    """
     )
 
 
 def test_init_factory_casting():
     """Tests py::init_factory() wrapper with various upcasting and downcasting returns"""
 
     cstats = [
@@ -461,20 +459,18 @@
         ---
         ~NoisyAlloc()  # Destructor
         noisy delete   # operator delete
     """
     )
 
 
-@pytest.mark.skipif("env.PY2")
 def test_invalid_self():
-    """Tests invocation of the pybind-registered base class with an invalid `self` argument.  You
-    can only actually do this on Python 3: Python 2 raises an exception itself if you try."""
+    """Tests invocation of the pybind-registered base class with an invalid `self` argument."""
 
-    class NotPybindDerived(object):
+    class NotPybindDerived:
         pass
 
     # Attempts to initialize with an invalid type passed as `self`:
     class BrokenTF1(m.TestFactory1):
         def __init__(self, bad):
             if bad == 1:
                 a = m.TestFactory2(tag.pointer, 1)
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_iostream.cpp` & `python_prtree-0.6.1/third/pybind11/tests/test_iostream.cpp`

 * *Files 12% similar despite different names*

```diff
@@ -3,18 +3,14 @@
 
     Copyright (c) 2017 Henry F. Schreiner
 
     All rights reserved. Use of this source code is governed by a
     BSD-style license that can be found in the LICENSE file.
 */
 
-#if defined(_MSC_VER) && _MSC_VER < 1910 // VS 2015's MSVC
-#    pragma warning(disable : 4702)      // unreachable code in system header (xatomic.h(382))
-#endif
-
 #include <pybind11/iostream.h>
 
 #include "pybind11_tests.h"
 
 #include <atomic>
 #include <iostream>
 #include <mutex>
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_iostream.py` & `python_prtree-0.6.1/third/pybind11/tests/test_iostream.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,174 +1,138 @@
-# -*- coding: utf-8 -*-
-import sys
-from contextlib import contextmanager
+from contextlib import redirect_stderr, redirect_stdout
+from io import StringIO
 
 from pybind11_tests import iostream as m
 
-try:
-    # Python 3
-    from io import StringIO
-except ImportError:
-    # Python 2
-    try:
-        from cStringIO import StringIO
-    except ImportError:
-        from StringIO import StringIO
-
-try:
-    # Python 3.4
-    from contextlib import redirect_stdout
-except ImportError:
-
-    @contextmanager
-    def redirect_stdout(target):
-        original = sys.stdout
-        sys.stdout = target
-        yield
-        sys.stdout = original
-
-
-try:
-    # Python 3.5
-    from contextlib import redirect_stderr
-except ImportError:
-
-    @contextmanager
-    def redirect_stderr(target):
-        original = sys.stderr
-        sys.stderr = target
-        yield
-        sys.stderr = original
-
 
 def test_captured(capsys):
     msg = "I've been redirected to Python, I hope!"
     m.captured_output(msg)
     stdout, stderr = capsys.readouterr()
     assert stdout == msg
-    assert stderr == ""
+    assert not stderr
 
     m.captured_output_default(msg)
     stdout, stderr = capsys.readouterr()
     assert stdout == msg
-    assert stderr == ""
+    assert not stderr
 
     m.captured_err(msg)
     stdout, stderr = capsys.readouterr()
-    assert stdout == ""
+    assert not stdout
     assert stderr == msg
 
 
 def test_captured_large_string(capsys):
     # Make this bigger than the buffer used on the C++ side: 1024 chars
     msg = "I've been redirected to Python, I hope!"
     msg = msg * (1024 // len(msg) + 1)
 
     m.captured_output_default(msg)
     stdout, stderr = capsys.readouterr()
     assert stdout == msg
-    assert stderr == ""
+    assert not stderr
 
 
 def test_captured_utf8_2byte_offset0(capsys):
     msg = "\u07FF"
     msg = "" + msg * (1024 // len(msg) + 1)
 
     m.captured_output_default(msg)
     stdout, stderr = capsys.readouterr()
     assert stdout == msg
-    assert stderr == ""
+    assert not stderr
 
 
 def test_captured_utf8_2byte_offset1(capsys):
     msg = "\u07FF"
     msg = "1" + msg * (1024 // len(msg) + 1)
 
     m.captured_output_default(msg)
     stdout, stderr = capsys.readouterr()
     assert stdout == msg
-    assert stderr == ""
+    assert not stderr
 
 
 def test_captured_utf8_3byte_offset0(capsys):
     msg = "\uFFFF"
     msg = "" + msg * (1024 // len(msg) + 1)
 
     m.captured_output_default(msg)
     stdout, stderr = capsys.readouterr()
     assert stdout == msg
-    assert stderr == ""
+    assert not stderr
 
 
 def test_captured_utf8_3byte_offset1(capsys):
     msg = "\uFFFF"
     msg = "1" + msg * (1024 // len(msg) + 1)
 
     m.captured_output_default(msg)
     stdout, stderr = capsys.readouterr()
     assert stdout == msg
-    assert stderr == ""
+    assert not stderr
 
 
 def test_captured_utf8_3byte_offset2(capsys):
     msg = "\uFFFF"
     msg = "12" + msg * (1024 // len(msg) + 1)
 
     m.captured_output_default(msg)
     stdout, stderr = capsys.readouterr()
     assert stdout == msg
-    assert stderr == ""
+    assert not stderr
 
 
 def test_captured_utf8_4byte_offset0(capsys):
     msg = "\U0010FFFF"
     msg = "" + msg * (1024 // len(msg) + 1)
 
     m.captured_output_default(msg)
     stdout, stderr = capsys.readouterr()
     assert stdout == msg
-    assert stderr == ""
+    assert not stderr
 
 
 def test_captured_utf8_4byte_offset1(capsys):
     msg = "\U0010FFFF"
     msg = "1" + msg * (1024 // len(msg) + 1)
 
     m.captured_output_default(msg)
     stdout, stderr = capsys.readouterr()
     assert stdout == msg
-    assert stderr == ""
+    assert not stderr
 
 
 def test_captured_utf8_4byte_offset2(capsys):
     msg = "\U0010FFFF"
     msg = "12" + msg * (1024 // len(msg) + 1)
 
     m.captured_output_default(msg)
     stdout, stderr = capsys.readouterr()
     assert stdout == msg
-    assert stderr == ""
+    assert not stderr
 
 
 def test_captured_utf8_4byte_offset3(capsys):
     msg = "\U0010FFFF"
     msg = "123" + msg * (1024 // len(msg) + 1)
 
     m.captured_output_default(msg)
     stdout, stderr = capsys.readouterr()
     assert stdout == msg
-    assert stderr == ""
+    assert not stderr
 
 
 def test_guard_capture(capsys):
     msg = "I've been redirected to Python, I hope!"
     m.guard_output(msg)
     stdout, stderr = capsys.readouterr()
     assert stdout == msg
-    assert stderr == ""
+    assert not stderr
 
 
 def test_series_captured(capture):
     with capture:
         m.captured_output("a")
         m.captured_output("b")
     assert capture == "ab"
@@ -177,15 +141,15 @@
 def test_flush(capfd):
     msg = "(not flushed)"
     msg2 = "(flushed)"
 
     with m.ostream_redirect():
         m.noisy_function(msg, flush=False)
         stdout, stderr = capfd.readouterr()
-        assert stdout == ""
+        assert not stdout
 
         m.noisy_function(msg2, flush=True)
         stdout, stderr = capfd.readouterr()
         assert stdout == msg + msg2
 
         m.noisy_function(msg, flush=False)
 
@@ -196,42 +160,42 @@
 def test_not_captured(capfd):
     msg = "Something that should not show up in log"
     stream = StringIO()
     with redirect_stdout(stream):
         m.raw_output(msg)
     stdout, stderr = capfd.readouterr()
     assert stdout == msg
-    assert stderr == ""
-    assert stream.getvalue() == ""
+    assert not stderr
+    assert not stream.getvalue()
 
     stream = StringIO()
     with redirect_stdout(stream):
         m.captured_output(msg)
     stdout, stderr = capfd.readouterr()
-    assert stdout == ""
-    assert stderr == ""
+    assert not stdout
+    assert not stderr
     assert stream.getvalue() == msg
 
 
 def test_err(capfd):
     msg = "Something that should not show up in log"
     stream = StringIO()
     with redirect_stderr(stream):
         m.raw_err(msg)
     stdout, stderr = capfd.readouterr()
-    assert stdout == ""
+    assert not stdout
     assert stderr == msg
-    assert stream.getvalue() == ""
+    assert not stream.getvalue()
 
     stream = StringIO()
     with redirect_stderr(stream):
         m.captured_err(msg)
     stdout, stderr = capfd.readouterr()
-    assert stdout == ""
-    assert stderr == ""
+    assert not stdout
+    assert not stderr
     assert stream.getvalue() == msg
 
 
 def test_multi_captured(capfd):
     stream = StringIO()
     with redirect_stdout(stream):
         m.captured_output("a")
@@ -253,61 +217,57 @@
 def test_redirect(capfd):
     msg = "Should not be in log!"
     stream = StringIO()
     with redirect_stdout(stream):
         m.raw_output(msg)
     stdout, stderr = capfd.readouterr()
     assert stdout == msg
-    assert stream.getvalue() == ""
+    assert not stream.getvalue()
 
     stream = StringIO()
-    with redirect_stdout(stream):
-        with m.ostream_redirect():
-            m.raw_output(msg)
+    with redirect_stdout(stream), m.ostream_redirect():
+        m.raw_output(msg)
     stdout, stderr = capfd.readouterr()
-    assert stdout == ""
+    assert not stdout
     assert stream.getvalue() == msg
 
     stream = StringIO()
     with redirect_stdout(stream):
         m.raw_output(msg)
     stdout, stderr = capfd.readouterr()
     assert stdout == msg
-    assert stream.getvalue() == ""
+    assert not stream.getvalue()
 
 
 def test_redirect_err(capfd):
     msg = "StdOut"
     msg2 = "StdErr"
 
     stream = StringIO()
-    with redirect_stderr(stream):
-        with m.ostream_redirect(stdout=False):
-            m.raw_output(msg)
-            m.raw_err(msg2)
+    with redirect_stderr(stream), m.ostream_redirect(stdout=False):
+        m.raw_output(msg)
+        m.raw_err(msg2)
     stdout, stderr = capfd.readouterr()
     assert stdout == msg
-    assert stderr == ""
+    assert not stderr
     assert stream.getvalue() == msg2
 
 
 def test_redirect_both(capfd):
     msg = "StdOut"
     msg2 = "StdErr"
 
     stream = StringIO()
     stream2 = StringIO()
-    with redirect_stdout(stream):
-        with redirect_stderr(stream2):
-            with m.ostream_redirect():
-                m.raw_output(msg)
-                m.raw_err(msg2)
+    with redirect_stdout(stream), redirect_stderr(stream2), m.ostream_redirect():
+        m.raw_output(msg)
+        m.raw_err(msg2)
     stdout, stderr = capfd.readouterr()
-    assert stdout == ""
-    assert stderr == ""
+    assert not stdout
+    assert not stderr
     assert stream.getvalue() == msg
     assert stream2.getvalue() == msg2
 
 
 def test_threading():
     with m.ostream_redirect(stdout=True, stderr=False):
         # start some threads
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_kwargs_and_defaults.cpp` & `python_prtree-0.6.1/third/pybind11/tests/test_kwargs_and_defaults.cpp`

 * *Files 16% similar despite different names*

```diff
@@ -38,16 +38,70 @@
             return ret;
         },
         py::arg("myList") = list);
 
     m.def("kw_func_udl", kw_func, "x"_a, "y"_a = 300);
     m.def("kw_func_udl_z", kw_func, "x"_a, "y"_a = 0);
 
+    // test line breaks in default argument representation
+    struct CustomRepr {
+        std::string repr_string;
+
+        explicit CustomRepr(const std::string &repr) : repr_string(repr) {}
+
+        std::string __repr__() const { return repr_string; }
+    };
+
+    py::class_<CustomRepr>(m, "CustomRepr")
+        .def(py::init<const std::string &>())
+        .def("__repr__", &CustomRepr::__repr__);
+
+    m.def(
+        "kw_lb_func0",
+        [](const CustomRepr &) {},
+        py::arg("custom") = CustomRepr("  array([[A, B], [C, D]])  "));
+    m.def(
+        "kw_lb_func1",
+        [](const CustomRepr &) {},
+        py::arg("custom") = CustomRepr("  array([[A, B],\n[C, D]])  "));
+    m.def(
+        "kw_lb_func2",
+        [](const CustomRepr &) {},
+        py::arg("custom") = CustomRepr("\v\n   array([[A, B], [C, D]])"));
+    m.def(
+        "kw_lb_func3",
+        [](const CustomRepr &) {},
+        py::arg("custom") = CustomRepr("array([[A, B], [C, D]])   \f\n"));
+    m.def(
+        "kw_lb_func4",
+        [](const CustomRepr &) {},
+        py::arg("custom") = CustomRepr("array([[A, B],\n\f\n[C, D]])"));
+    m.def(
+        "kw_lb_func5",
+        [](const CustomRepr &) {},
+        py::arg("custom") = CustomRepr("array([[A, B],\r  [C, D]])"));
+    m.def(
+        "kw_lb_func6", [](const CustomRepr &) {}, py::arg("custom") = CustomRepr(" \v\t "));
+    m.def(
+        "kw_lb_func7",
+        [](const std::string &) {},
+        py::arg("str_arg") = "First line.\n  Second line.");
+    m.def(
+        "kw_lb_func8", [](const CustomRepr &) {}, py::arg("custom") = CustomRepr(""));
+
     // test_args_and_kwargs
-    m.def("args_function", [](py::args args) -> py::tuple { return std::move(args); });
+    m.def("args_function", [](py::args args) -> py::tuple {
+        PYBIND11_WARNING_PUSH
+
+#ifdef PYBIND11_DETECTED_CLANG_WITH_MISLEADING_CALL_STD_MOVE_EXPLICITLY_WARNING
+        PYBIND11_WARNING_DISABLE_CLANG("-Wreturn-std-move")
+#endif
+        return args;
+        PYBIND11_WARNING_POP
+    });
     m.def("args_kwargs_function", [](const py::args &args, const py::kwargs &kwargs) {
         return py::make_tuple(args, kwargs);
     });
 
     // test_mixed_args_and_kwargs
     m.def("mixed_plus_args",
           [](int i, double j, const py::args &args) { return py::make_tuple(i, j, args); });
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_kwargs_and_defaults.py` & `python_prtree-0.6.1/third/pybind11/tests/test_kwargs_and_defaults.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,37 +1,71 @@
-# -*- coding: utf-8 -*-
 import pytest
 
-import env  # noqa: F401
 from pybind11_tests import kwargs_and_defaults as m
 
 
 def test_function_signatures(doc):
     assert doc(m.kw_func0) == "kw_func0(arg0: int, arg1: int) -> str"
     assert doc(m.kw_func1) == "kw_func1(x: int, y: int) -> str"
     assert doc(m.kw_func2) == "kw_func2(x: int = 100, y: int = 200) -> str"
     assert doc(m.kw_func3) == "kw_func3(data: str = 'Hello world!') -> None"
-    assert doc(m.kw_func4) == "kw_func4(myList: List[int] = [13, 17]) -> str"
+    assert doc(m.kw_func4) == "kw_func4(myList: list[int] = [13, 17]) -> str"
     assert doc(m.kw_func_udl) == "kw_func_udl(x: int, y: int = 300) -> str"
     assert doc(m.kw_func_udl_z) == "kw_func_udl_z(x: int, y: int = 0) -> str"
     assert doc(m.args_function) == "args_function(*args) -> tuple"
     assert (
         doc(m.args_kwargs_function) == "args_kwargs_function(*args, **kwargs) -> tuple"
     )
     assert (
         doc(m.KWClass.foo0)
         == "foo0(self: m.kwargs_and_defaults.KWClass, arg0: int, arg1: float) -> None"
     )
     assert (
         doc(m.KWClass.foo1)
         == "foo1(self: m.kwargs_and_defaults.KWClass, x: int, y: float) -> None"
     )
+    assert (
+        doc(m.kw_lb_func0)
+        == "kw_lb_func0(custom: m.kwargs_and_defaults.CustomRepr = array([[A, B], [C, D]])) -> None"
+    )
+    assert (
+        doc(m.kw_lb_func1)
+        == "kw_lb_func1(custom: m.kwargs_and_defaults.CustomRepr = array([[A, B], [C, D]])) -> None"
+    )
+    assert (
+        doc(m.kw_lb_func2)
+        == "kw_lb_func2(custom: m.kwargs_and_defaults.CustomRepr = array([[A, B], [C, D]])) -> None"
+    )
+    assert (
+        doc(m.kw_lb_func3)
+        == "kw_lb_func3(custom: m.kwargs_and_defaults.CustomRepr = array([[A, B], [C, D]])) -> None"
+    )
+    assert (
+        doc(m.kw_lb_func4)
+        == "kw_lb_func4(custom: m.kwargs_and_defaults.CustomRepr = array([[A, B], [C, D]])) -> None"
+    )
+    assert (
+        doc(m.kw_lb_func5)
+        == "kw_lb_func5(custom: m.kwargs_and_defaults.CustomRepr = array([[A, B], [C, D]])) -> None"
+    )
+    assert (
+        doc(m.kw_lb_func6)
+        == "kw_lb_func6(custom: m.kwargs_and_defaults.CustomRepr = ) -> None"
+    )
+    assert (
+        doc(m.kw_lb_func7)
+        == "kw_lb_func7(str_arg: str = 'First line.\\n  Second line.') -> None"
+    )
+    assert (
+        doc(m.kw_lb_func8)
+        == "kw_lb_func8(custom: m.kwargs_and_defaults.CustomRepr = ) -> None"
+    )
 
 
-def test_named_arguments(msg):
+def test_named_arguments():
     assert m.kw_func0(5, 10) == "x=5, y=10"
 
     assert m.kw_func1(5, 10) == "x=5, y=10"
     assert m.kw_func1(5, y=10) == "x=5, y=10"
     assert m.kw_func1(y=10, x=5) == "x=5, y=10"
 
     assert m.kw_func2() == "x=100, y=200"
@@ -41,31 +75,30 @@
     assert m.kw_func2(5, 10) == "x=5, y=10"
     assert m.kw_func2(x=5, y=10) == "x=5, y=10"
 
     with pytest.raises(TypeError) as excinfo:
         # noinspection PyArgumentList
         m.kw_func2(x=5, y=10, z=12)
     assert excinfo.match(
-        r"(?s)^kw_func2\(\): incompatible.*Invoked with: kwargs: ((x=5|y=10|z=12)(, |$))"
-        + "{3}$"
+        r"(?s)^kw_func2\(\): incompatible.*Invoked with: kwargs: ((x=5|y=10|z=12)(, |$)){3}$"
     )
 
     assert m.kw_func4() == "{13 17}"
     assert m.kw_func4(myList=[1, 2, 3]) == "{1 2 3}"
 
     assert m.kw_func_udl(x=5, y=10) == "x=5, y=10"
     assert m.kw_func_udl_z(x=5) == "x=5, y=0"
 
 
 def test_arg_and_kwargs():
     args = "arg1_value", "arg2_value", 3
     assert m.args_function(*args) == args
 
     args = "a1", "a2"
-    kwargs = dict(arg3="a3", arg4=4)
+    kwargs = {"arg3": "a3", "arg4": 4}
     assert m.args_kwargs_function(*args, **kwargs) == (args, kwargs)
 
 
 def test_mixed_args_and_kwargs(msg):
     mpa = m.mixed_plus_args
     mpk = m.mixed_plus_kwargs
     mpak = m.mixed_plus_args_kwargs
@@ -78,26 +111,26 @@
     assert (
         msg(excinfo.value)
         == """
         mixed_plus_args(): incompatible function arguments. The following argument types are supported:
             1. (arg0: int, arg1: float, *args) -> tuple
 
         Invoked with: 1
-    """  # noqa: E501 line too long
+    """
     )
     with pytest.raises(TypeError) as excinfo:
         assert mpa()
     assert (
         msg(excinfo.value)
         == """
         mixed_plus_args(): incompatible function arguments. The following argument types are supported:
             1. (arg0: int, arg1: float, *args) -> tuple
 
         Invoked with:
-    """  # noqa: E501 line too long
+    """
     )
 
     assert mpk(-2, 3.5, pi=3.14159, e=2.71828) == (
         -2,
         3.5,
         {"e": 2.71828, "pi": 3.14159},
     )
@@ -123,26 +156,26 @@
     assert (
         msg(excinfo.value)
         == """
         mixed_plus_args_kwargs_defaults(): incompatible function arguments. The following argument types are supported:
             1. (i: int = 1, j: float = 3.14159, *args, **kwargs) -> tuple
 
         Invoked with: 1; kwargs: i=1
-    """  # noqa: E501 line too long
+    """
     )
     with pytest.raises(TypeError) as excinfo:
         assert mpakd(1, 2, j=1)
     assert (
         msg(excinfo.value)
         == """
         mixed_plus_args_kwargs_defaults(): incompatible function arguments. The following argument types are supported:
             1. (i: int = 1, j: float = 3.14159, *args, **kwargs) -> tuple
 
         Invoked with: 1, 2; kwargs: j=1
-    """  # noqa: E501 line too long
+    """
     )
 
     # Arguments after a py::args are automatically keyword-only (pybind 2.9+)
     assert m.args_kwonly(2, 2.5, z=22) == (2, 2.5, (), 22)
     assert m.args_kwonly(2, 2.5, "a", "b", "c", z=22) == (2, 2.5, ("a", "b", "c"), 22)
     assert m.args_kwonly(z=22, i=4, j=16) == (4, 16, (), 22)
 
@@ -175,15 +208,15 @@
     assert (
         m.args_kwonly_kwargs.__doc__
         == "args_kwonly_kwargs(i: int, j: float, *args, z: int, **kwargs) -> tuple\n"
     )
 
     assert (
         m.args_kwonly_kwargs_defaults.__doc__
-        == "args_kwonly_kwargs_defaults(i: int = 1, j: float = 3.14159, *args, z: int = 42, **kwargs) -> tuple\n"  # noqa: E501 line too long
+        == "args_kwonly_kwargs_defaults(i: int = 1, j: float = 3.14159, *args, z: int = 42, **kwargs) -> tuple\n"
     )
     assert m.args_kwonly_kwargs_defaults() == (1, 3.14159, (), 42, {})
     assert m.args_kwonly_kwargs_defaults(2) == (2, 3.14159, (), 42, {})
     assert m.args_kwonly_kwargs_defaults(z=-99) == (1, 3.14159, (), -99, {})
     assert m.args_kwonly_kwargs_defaults(5, 6, 7, 8) == (5, 6, (7, 8), 42, {})
     assert m.args_kwonly_kwargs_defaults(5, 6, 7, m=8) == (5, 6, (7,), 42, {"m": 8})
     assert m.args_kwonly_kwargs_defaults(5, 6, 7, m=8, z=9) == (5, 6, (7,), 9, {"m": 8})
@@ -231,23 +264,23 @@
 
     # https://github.com/pybind/pybind11/pull/3402#issuecomment-963341987
     x = m.first_arg_kw_only(i=1)
     x.method()
     x.method(i=1, j=2)
     assert (
         m.first_arg_kw_only.__init__.__doc__
-        == "__init__(self: pybind11_tests.kwargs_and_defaults.first_arg_kw_only, *, i: int = 0) -> None\n"  # noqa: E501 line too long
+        == "__init__(self: pybind11_tests.kwargs_and_defaults.first_arg_kw_only, *, i: int = 0) -> None\n"
     )
     assert (
         m.first_arg_kw_only.method.__doc__
-        == "method(self: pybind11_tests.kwargs_and_defaults.first_arg_kw_only, *, i: int = 1, j: int = 2) -> None\n"  # noqa: E501 line too long
+        == "method(self: pybind11_tests.kwargs_and_defaults.first_arg_kw_only, *, i: int = 1, j: int = 2) -> None\n"
     )
 
 
-def test_positional_only_args(msg):
+def test_positional_only_args():
     assert m.pos_only_all(1, 2) == (1, 2)
     assert m.pos_only_all(2, 1) == (2, 1)
 
     with pytest.raises(TypeError) as excinfo:
         m.pos_only_all(i=1, j=2)
     assert "incompatible function arguments" in str(excinfo.value)
 
@@ -281,15 +314,15 @@
     with pytest.raises(TypeError) as excinfo:
         m.pos_only_def_mix(1, j=4)
     assert "incompatible function arguments" in str(excinfo.value)
 
     # Mix it with args and kwargs:
     assert (
         m.args_kwonly_full_monty.__doc__
-        == "args_kwonly_full_monty(arg0: int = 1, arg1: int = 2, /, j: float = 3.14159, *args, z: int = 42, **kwargs) -> tuple\n"  # noqa: E501 line too long
+        == "args_kwonly_full_monty(arg0: int = 1, arg1: int = 2, /, j: float = 3.14159, *args, z: int = 42, **kwargs) -> tuple\n"
     )
     assert m.args_kwonly_full_monty() == (1, 2, 3.14159, (), 42, {})
     assert m.args_kwonly_full_monty(8) == (8, 2, 3.14159, (), 42, {})
     assert m.args_kwonly_full_monty(8, 9) == (8, 9, 3.14159, (), 42, {})
     assert m.args_kwonly_full_monty(8, 9, 10) == (8, 9, 10.0, (), 42, {})
     assert m.args_kwonly_full_monty(3, 4, 5, 6, 7, m=8, z=9) == (
         3,
@@ -324,30 +357,29 @@
     )
 
     # pos_only at the beginning of the argument list was "broken" in how it was displayed (though
     # this is fairly useless in practice).  Related to:
     # https://github.com/pybind/pybind11/pull/3402#issuecomment-963341987
     assert (
         m.first_arg_kw_only.pos_only.__doc__
-        == "pos_only(self: pybind11_tests.kwargs_and_defaults.first_arg_kw_only, /, i: int, j: int) -> None\n"  # noqa: E501 line too long
+        == "pos_only(self: pybind11_tests.kwargs_and_defaults.first_arg_kw_only, /, i: int, j: int) -> None\n"
     )
 
 
 def test_signatures():
-    assert "kw_only_all(*, i: int, j: int) -> tuple\n" == m.kw_only_all.__doc__
-    assert "kw_only_mixed(i: int, *, j: int) -> tuple\n" == m.kw_only_mixed.__doc__
-    assert "pos_only_all(i: int, j: int, /) -> tuple\n" == m.pos_only_all.__doc__
-    assert "pos_only_mix(i: int, /, j: int) -> tuple\n" == m.pos_only_mix.__doc__
+    assert m.kw_only_all.__doc__ == "kw_only_all(*, i: int, j: int) -> tuple\n"
+    assert m.kw_only_mixed.__doc__ == "kw_only_mixed(i: int, *, j: int) -> tuple\n"
+    assert m.pos_only_all.__doc__ == "pos_only_all(i: int, j: int, /) -> tuple\n"
+    assert m.pos_only_mix.__doc__ == "pos_only_mix(i: int, /, j: int) -> tuple\n"
     assert (
-        "pos_kw_only_mix(i: int, /, j: int, *, k: int) -> tuple\n"
-        == m.pos_kw_only_mix.__doc__
+        m.pos_kw_only_mix.__doc__
+        == "pos_kw_only_mix(i: int, /, j: int, *, k: int) -> tuple\n"
     )
 
 
-@pytest.mark.xfail("env.PYPY and env.PY2", reason="PyPy2 doesn't double count")
 def test_args_refcount():
     """Issue/PR #1216 - py::args elements get double-inc_ref()ed when combined with regular
     arguments"""
     refcount = m.arg_refcount_h
 
     myval = 54321
     expected = refcount(myval)
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_local_bindings.cpp` & `python_prtree-0.6.1/third/pybind11/tests/test_local_bindings.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_local_bindings.py` & `python_prtree-0.6.1/third/pybind11/tests/test_local_bindings.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 import pytest
 
 import env  # noqa: F401
 from pybind11_tests import local_bindings as m
 
 
 def test_load_external():
@@ -127,15 +126,16 @@
         str(excinfo.value) == 'generic_type: type "NonLocalMap2" is already registered!'
     )
 
 
 def test_mixed_local_global():
     """Local types take precedence over globally registered types: a module with a `module_local`
     type can be registered even if the type is already registered globally.  With the module,
-    casting will go to the local type; outside the module casting goes to the global type."""
+    casting will go to the local type; outside the module casting goes to the global type.
+    """
     import pybind11_cross_module_tests as cm
 
     m.register_mixed_global()
     m.register_mixed_local()
 
     a = []
     a.append(m.MixedGlobalLocal(1))
@@ -196,15 +196,15 @@
     assert (
         msg(excinfo.value)
         == """
     load_vector_via_binding(): incompatible function arguments. The following argument types are supported:
         1. (arg0: pybind11_cross_module_tests.VectorInt) -> int
 
     Invoked with: [1, 2, 3]
-    """  # noqa: E501 line too long
+    """
     )
 
 
 def test_cross_module_calls():
     import pybind11_cross_module_tests as cm
 
     v1 = m.LocalVec()
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_methods_and_attributes.cpp` & `python_prtree-0.6.1/third/pybind11/tests/test_methods_and_attributes.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -173,14 +173,46 @@
 struct RValueRefParam {
     std::size_t func1(std::string &&s) { return s.size(); }
     std::size_t func2(std::string &&s) const { return s.size(); }
     std::size_t func3(std::string &&s) & { return s.size(); }
     std::size_t func4(std::string &&s) const & { return s.size(); }
 };
 
+namespace pybind11_tests {
+namespace exercise_is_setter {
+
+struct FieldBase {
+    int int_value() const { return int_value_; }
+
+    FieldBase &SetIntValue(int int_value) {
+        int_value_ = int_value;
+        return *this;
+    }
+
+private:
+    int int_value_ = -99;
+};
+
+struct Field : FieldBase {};
+
+void add_bindings(py::module &m) {
+    py::module sm = m.def_submodule("exercise_is_setter");
+    // NOTE: FieldBase is not wrapped, therefore ...
+    py::class_<Field>(sm, "Field")
+        .def(py::init<>())
+        .def_property(
+            "int_value",
+            &Field::int_value,
+            &Field::SetIntValue // ... the `FieldBase &` return value here cannot be converted.
+        );
+}
+
+} // namespace exercise_is_setter
+} // namespace pybind11_tests
+
 TEST_SUBMODULE(methods_and_attributes, m) {
     // test_methods_and_attributes
     py::class_<ExampleMandA> emna(m, "ExampleMandA");
     emna.def(py::init<>())
         .def(py::init<int>())
         .def(py::init<std::string &&>())
         .def(py::init<const ExampleMandA &>())
@@ -357,18 +389,18 @@
 
     class CppDerivedDynamicClass : public DynamicClass {};
     py::class_<CppDerivedDynamicClass, DynamicClass>(m, "CppDerivedDynamicClass").def(py::init());
 #endif
 
     // test_bad_arg_default
     // Issue/PR #648: bad arg default debugging output
-#if !defined(NDEBUG)
-    m.attr("debug_enabled") = true;
+#if defined(PYBIND11_DETAILED_ERROR_MESSAGES)
+    m.attr("detailed_error_messages_enabled") = true;
 #else
-    m.attr("debug_enabled") = false;
+    m.attr("detailed_error_messages_enabled") = false;
 #endif
     m.def("bad_arg_def_named", [] {
         auto m = py::module_::import("pybind11_tests");
         m.def(
             "should_fail",
             [](int, UnregisteredType) {},
             py::arg(),
@@ -452,8 +484,10 @@
 
     py::class_<RValueRefParam>(m, "RValueRefParam")
         .def(py::init<>())
         .def("func1", &RValueRefParam::func1)
         .def("func2", &RValueRefParam::func2)
         .def("func3", &RValueRefParam::func3)
         .def("func4", &RValueRefParam::func4);
+
+    pybind11_tests::exercise_is_setter::add_bindings(m);
 }
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_methods_and_attributes.py` & `python_prtree-0.6.1/third/pybind11/tests/test_methods_and_attributes.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,14 +1,25 @@
-# -*- coding: utf-8 -*-
+import sys
+
 import pytest
 
 import env  # noqa: F401
 from pybind11_tests import ConstructorStats
 from pybind11_tests import methods_and_attributes as m
 
+NO_GETTER_MSG = (
+    "unreadable attribute" if sys.version_info < (3, 11) else "object has no getter"
+)
+NO_SETTER_MSG = (
+    "can't set attribute" if sys.version_info < (3, 11) else "object has no setter"
+)
+NO_DELETER_MSG = (
+    "can't delete attribute" if sys.version_info < (3, 11) else "object has no deleter"
+)
+
 
 def test_methods_and_attributes():
     instance1 = m.ExampleMandA()
     instance2 = m.ExampleMandA(32)
 
     instance1.add1(instance2)
     instance1.add2(instance2)
@@ -99,55 +110,55 @@
         instance.def_property_readonly = 3
 
     instance.def_property = 3
     assert instance.def_property == 3
 
     with pytest.raises(AttributeError) as excinfo:
         dummy = instance.def_property_writeonly  # unused var
-    assert "unreadable attribute" in str(excinfo.value)
+    assert NO_GETTER_MSG in str(excinfo.value)
 
     instance.def_property_writeonly = 4
     assert instance.def_property_readonly == 4
 
     with pytest.raises(AttributeError) as excinfo:
         dummy = instance.def_property_impossible  # noqa: F841 unused var
-    assert "unreadable attribute" in str(excinfo.value)
+    assert NO_GETTER_MSG in str(excinfo.value)
 
     with pytest.raises(AttributeError) as excinfo:
         instance.def_property_impossible = 5
-    assert "can't set attribute" in str(excinfo.value)
+    assert NO_SETTER_MSG in str(excinfo.value)
 
 
 def test_static_properties():
     assert m.TestProperties.def_readonly_static == 1
     with pytest.raises(AttributeError) as excinfo:
         m.TestProperties.def_readonly_static = 2
-    assert "can't set attribute" in str(excinfo.value)
+    assert NO_SETTER_MSG in str(excinfo.value)
 
     m.TestProperties.def_readwrite_static = 2
     assert m.TestProperties.def_readwrite_static == 2
 
     with pytest.raises(AttributeError) as excinfo:
         dummy = m.TestProperties.def_writeonly_static  # unused var
-    assert "unreadable attribute" in str(excinfo.value)
+    assert NO_GETTER_MSG in str(excinfo.value)
 
     m.TestProperties.def_writeonly_static = 3
     assert m.TestProperties.def_readonly_static == 3
 
     assert m.TestProperties.def_property_readonly_static == 3
     with pytest.raises(AttributeError) as excinfo:
         m.TestProperties.def_property_readonly_static = 99
-    assert "can't set attribute" in str(excinfo.value)
+    assert NO_SETTER_MSG in str(excinfo.value)
 
     m.TestProperties.def_property_static = 4
     assert m.TestProperties.def_property_static == 4
 
     with pytest.raises(AttributeError) as excinfo:
         dummy = m.TestProperties.def_property_writeonly_static
-    assert "unreadable attribute" in str(excinfo.value)
+    assert NO_GETTER_MSG in str(excinfo.value)
 
     m.TestProperties.def_property_writeonly_static = 5
     assert m.TestProperties.def_property_static == 5
 
     # Static property read and write via instance
     instance = m.TestProperties()
 
@@ -157,35 +168,35 @@
 
     instance.def_readwrite_static = 2
     assert m.TestProperties.def_readwrite_static == 2
     assert instance.def_readwrite_static == 2
 
     with pytest.raises(AttributeError) as excinfo:
         dummy = instance.def_property_writeonly_static  # noqa: F841 unused var
-    assert "unreadable attribute" in str(excinfo.value)
+    assert NO_GETTER_MSG in str(excinfo.value)
 
     instance.def_property_writeonly_static = 4
     assert instance.def_property_static == 4
 
     # It should be possible to override properties in derived classes
     assert m.TestPropertiesOverride().def_readonly == 99
     assert m.TestPropertiesOverride.def_readonly_static == 99
 
     # Only static attributes can be deleted
     del m.TestPropertiesOverride.def_readonly_static
+    assert hasattr(m.TestPropertiesOverride, "def_readonly_static")
     assert (
-        hasattr(m.TestPropertiesOverride, "def_readonly_static")
-        and m.TestPropertiesOverride.def_readonly_static
+        m.TestPropertiesOverride.def_readonly_static
         is m.TestProperties.def_readonly_static
     )
     assert "def_readonly_static" not in m.TestPropertiesOverride.__dict__
     properties_override = m.TestPropertiesOverride()
     with pytest.raises(AttributeError) as excinfo:
         del properties_override.def_readonly
-    assert "can't delete attribute" in str(excinfo.value)
+    assert NO_DELETER_MSG in str(excinfo.value)
 
 
 def test_static_cls():
     """Static property getter and setters expect the type object as the their only argument"""
 
     instance = m.TestProperties()
     assert m.TestProperties.static_cls is m.TestProperties
@@ -213,46 +224,47 @@
     # Regular `type` replaces the property instead of calling `__set__()`
     m.MetaclassOverride.readonly = 2
     assert m.MetaclassOverride.readonly == 2
     assert isinstance(m.MetaclassOverride.__dict__["readonly"], int)
 
 
 def test_no_mixed_overloads():
-    from pybind11_tests import debug_enabled
+    from pybind11_tests import detailed_error_messages_enabled
 
     with pytest.raises(RuntimeError) as excinfo:
         m.ExampleMandA.add_mixed_overloads1()
-    assert str(
-        excinfo.value
-    ) == "overloading a method with both static and instance methods is not supported; " + (
-        "compile in debug mode for more details"
-        if not debug_enabled
-        else "error while attempting to bind static method ExampleMandA.overload_mixed1"
-        "(arg0: float) -> str"
+    assert (
+        str(excinfo.value)
+        == "overloading a method with both static and instance methods is not supported; "
+        + (
+            "#define PYBIND11_DETAILED_ERROR_MESSAGES or compile in debug mode for more details"
+            if not detailed_error_messages_enabled
+            else "error while attempting to bind static method ExampleMandA.overload_mixed1"
+            "(arg0: float) -> str"
+        )
     )
 
     with pytest.raises(RuntimeError) as excinfo:
         m.ExampleMandA.add_mixed_overloads2()
-    assert str(
-        excinfo.value
-    ) == "overloading a method with both static and instance methods is not supported; " + (
-        "compile in debug mode for more details"
-        if not debug_enabled
-        else "error while attempting to bind instance method ExampleMandA.overload_mixed2"
-        "(self: pybind11_tests.methods_and_attributes.ExampleMandA, arg0: int, arg1: int)"
-        " -> str"
+    assert (
+        str(excinfo.value)
+        == "overloading a method with both static and instance methods is not supported; "
+        + (
+            "#define PYBIND11_DETAILED_ERROR_MESSAGES or compile in debug mode for more details"
+            if not detailed_error_messages_enabled
+            else "error while attempting to bind instance method ExampleMandA.overload_mixed2"
+            "(self: pybind11_tests.methods_and_attributes.ExampleMandA, arg0: int, arg1: int)"
+            " -> str"
+        )
     )
 
 
 @pytest.mark.parametrize("access", ["ro", "rw", "static_ro", "static_rw"])
 def test_property_return_value_policies(access):
-    if not access.startswith("static"):
-        obj = m.TestPropRVP()
-    else:
-        obj = m.TestPropRVP
+    obj = m.TestPropRVP() if not access.startswith("static") else m.TestPropRVP
 
     ref = getattr(obj, access + "_ref")
     assert ref.value == 1
     ref.value = 2
     assert getattr(obj, access + "_ref").value == 2
     ref.value = 1  # restore original value for static properties
 
@@ -341,34 +353,34 @@
 
     assert cstats.alive() == 2
     del i1, i2
     assert cstats.alive() == 0
 
 
 def test_bad_arg_default(msg):
-    from pybind11_tests import debug_enabled
+    from pybind11_tests import detailed_error_messages_enabled
 
     with pytest.raises(RuntimeError) as excinfo:
         m.bad_arg_def_named()
     assert msg(excinfo.value) == (
         "arg(): could not convert default argument 'a: UnregisteredType' in function "
         "'should_fail' into a Python object (type not registered yet?)"
-        if debug_enabled
+        if detailed_error_messages_enabled
         else "arg(): could not convert default argument into a Python object (type not registered "
-        "yet?). Compile in debug mode for more information."
+        "yet?). #define PYBIND11_DETAILED_ERROR_MESSAGES or compile in debug mode for more information."
     )
 
     with pytest.raises(RuntimeError) as excinfo:
         m.bad_arg_def_unnamed()
     assert msg(excinfo.value) == (
         "arg(): could not convert default argument 'UnregisteredType' in function "
         "'should_fail' into a Python object (type not registered yet?)"
-        if debug_enabled
+        if detailed_error_messages_enabled
         else "arg(): could not convert default argument into a Python object (type not registered "
-        "yet?). Compile in debug mode for more information."
+        "yet?). #define PYBIND11_DETAILED_ERROR_MESSAGES or compile in debug mode for more information."
     )
 
 
 def test_accepts_none(msg):
     a = m.NoneTester()
     assert m.no_none1(a) == 42
     assert m.no_none2(a) == 42
@@ -490,36 +502,36 @@
 
 
 def test_overload_ordering():
     "Check to see if the normal overload order (first defined) and prepend overload order works"
     assert m.overload_order("string") == 1
     assert m.overload_order(0) == 4
 
-    # Different for Python 2 vs. 3
-    uni_name = type(u"").__name__
-
     assert "1. overload_order(arg0: int) -> int" in m.overload_order.__doc__
-    assert (
-        "2. overload_order(arg0: {}) -> int".format(uni_name)
-        in m.overload_order.__doc__
-    )
-    assert (
-        "3. overload_order(arg0: {}) -> int".format(uni_name)
-        in m.overload_order.__doc__
-    )
+    assert "2. overload_order(arg0: str) -> int" in m.overload_order.__doc__
+    assert "3. overload_order(arg0: str) -> int" in m.overload_order.__doc__
     assert "4. overload_order(arg0: int) -> int" in m.overload_order.__doc__
 
     with pytest.raises(TypeError) as err:
         m.overload_order(1.1)
 
     assert "1. (arg0: int) -> int" in str(err.value)
-    assert "2. (arg0: {}) -> int".format(uni_name) in str(err.value)
-    assert "3. (arg0: {}) -> int".format(uni_name) in str(err.value)
+    assert "2. (arg0: str) -> int" in str(err.value)
+    assert "3. (arg0: str) -> int" in str(err.value)
     assert "4. (arg0: int) -> int" in str(err.value)
 
 
 def test_rvalue_ref_param():
     r = m.RValueRefParam()
     assert r.func1("123") == 3
     assert r.func2("1234") == 4
     assert r.func3("12345") == 5
     assert r.func4("123456") == 6
+
+
+def test_is_setter():
+    fld = m.exercise_is_setter.Field()
+    assert fld.int_value == -99
+    setter_return = fld.int_value = 100
+    assert isinstance(setter_return, int)
+    assert setter_return == 100
+    assert fld.int_value == 100
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_modules.cpp` & `python_prtree-0.6.1/third/pybind11/tests/test_modules.cpp`

 * *Files 8% similar despite different names*

```diff
@@ -116,8 +116,10 @@
             py::class_<DupeException>(dm, "DupeException");
             failures.append("DupeException2");
         } catch (std::runtime_error &) {
         }
 
         return failures;
     });
+
+    m.def("def_submodule", [](py::module_ m, const char *name) { return m.def_submodule(name); });
 }
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_multiple_inheritance.cpp` & `python_prtree-0.6.1/third/pybind11/tests/test_multiple_inheritance.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_multiple_inheritance.py` & `python_prtree-0.6.1/third/pybind11/tests/test_multiple_inheritance.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,24 +1,22 @@
-# -*- coding: utf-8 -*-
 import pytest
 
 import env  # noqa: F401
 from pybind11_tests import ConstructorStats
 from pybind11_tests import multiple_inheritance as m
 
 
 def test_multiple_inheritance_cpp():
     mt = m.MIType(3, 4)
 
     assert mt.foo() == 3
     assert mt.bar() == 4
 
 
-@pytest.mark.skipif("env.PYPY and env.PY2")
-@pytest.mark.xfail("env.PYPY and not env.PY2")
+@pytest.mark.xfail("env.PYPY")
 def test_multiple_inheritance_mix1():
     class Base1:
         def __init__(self, i):
             self.i = i
 
         def foo(self):
             return self.i
@@ -49,23 +47,22 @@
 
     mt = MITypePy(3, 4)
 
     assert mt.foo() == 3
     assert mt.bar() == 4
 
 
-@pytest.mark.skipif("env.PYPY and env.PY2")
-@pytest.mark.xfail("env.PYPY and not env.PY2")
+@pytest.mark.xfail("env.PYPY")
 def test_multiple_inheritance_python():
     class MI1(m.Base1, m.Base2):
         def __init__(self, i, j):
             m.Base1.__init__(self, i)
             m.Base2.__init__(self, j)
 
-    class B1(object):
+    class B1:
         def v(self):
             return 1
 
     class MI2(B1, m.Base1, m.Base2):
         def __init__(self, i, j):
             B1.__init__(self)
             m.Base1.__init__(self, i)
@@ -92,15 +89,15 @@
             m.Base2.__init__(self, i)
             B1.__init__(self)
 
     class B2(B1):
         def v(self):
             return 2
 
-    class B3(object):
+    class B3:
         def v(self):
             return 3
 
     class B4(B3, B2):
         def v(self):
             return 4
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_numpy_array.cpp` & `python_prtree-0.6.1/third/pybind11/tests/test_numpy_array.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -158,15 +158,15 @@
 
 // note: declaration at local scope would create a dangling reference!
 static int data_i = 42;
 
 TEST_SUBMODULE(numpy_array, sm) {
     try {
         py::module_::import("numpy");
-    } catch (...) {
+    } catch (const py::error_already_set &) {
         return;
     }
 
     // test_dtypes
     py::class_<DtypeCheck>(sm, "DtypeCheck")
         .def_readonly("numpy", &DtypeCheck::numpy)
         .def_readonly("pybind11", &DtypeCheck::pybind11)
@@ -517,8 +517,36 @@
         "a"_a.noconvert());
 
     // Check that types returns correct npy format descriptor
     sm.def("test_fmt_desc_float", [](const py::array_t<float> &) {});
     sm.def("test_fmt_desc_double", [](const py::array_t<double> &) {});
     sm.def("test_fmt_desc_const_float", [](const py::array_t<const float> &) {});
     sm.def("test_fmt_desc_const_double", [](const py::array_t<const double> &) {});
+
+    sm.def("round_trip_float", [](double d) { return d; });
+
+    sm.def("pass_array_pyobject_ptr_return_sum_str_values",
+           [](const py::array_t<PyObject *> &objs) {
+               std::string sum_str_values;
+               for (const auto &obj : objs) {
+                   sum_str_values += py::str(obj.attr("value"));
+               }
+               return sum_str_values;
+           });
+
+    sm.def("pass_array_pyobject_ptr_return_as_list",
+           [](const py::array_t<PyObject *> &objs) -> py::list { return objs; });
+
+    sm.def("return_array_pyobject_ptr_cpp_loop", [](const py::list &objs) {
+        py::size_t arr_size = py::len(objs);
+        py::array_t<PyObject *> arr_from_list(static_cast<py::ssize_t>(arr_size));
+        PyObject **data = arr_from_list.mutable_data();
+        for (py::size_t i = 0; i < arr_size; i++) {
+            assert(data[i] == nullptr);
+            data[i] = py::cast<PyObject *>(objs[i].attr("value"));
+        }
+        return arr_from_list;
+    });
+
+    sm.def("return_array_pyobject_ptr_from_list",
+           [](const py::list &objs) -> py::array_t<PyObject *> { return objs; });
 }
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_numpy_array.py` & `python_prtree-0.6.1/third/pybind11/tests/test_numpy_array.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 import pytest
 
 import env  # noqa: F401
 from pybind11_tests import numpy_array as m
 
 np = pytest.importorskip("numpy")
 
@@ -15,21 +14,19 @@
         assert size_check.size_cpp == size_check.size_numpy, size_check
     # - Concrete sizes.
     for check in m.get_concrete_dtype_checks():
         print(check)
         assert check.numpy == check.pybind11, check
         if check.numpy.num != check.pybind11.num:
             print(
-                "NOTE: typenum mismatch for {}: {} != {}".format(
-                    check, check.numpy.num, check.pybind11.num
-                )
+                f"NOTE: typenum mismatch for {check}: {check.numpy.num} != {check.pybind11.num}"
             )
 
 
-@pytest.fixture(scope="function")
+@pytest.fixture()
 def arr():
     return np.array([[1, 2, 3], [4, 5, 6]], "=u2")
 
 
 def test_array_attributes():
     a = np.array(0, "f8")
     assert m.ndim(a) == 0
@@ -66,15 +63,15 @@
     assert m.size(a) == 6
     assert m.itemsize(a) == 2
     assert m.nbytes(a) == 12
     assert not m.owndata(a)
 
 
 @pytest.mark.parametrize(
-    "args, ret", [([], 0), ([0], 0), ([1], 3), ([0, 1], 1), ([1, 2], 5)]
+    ("args", "ret"), [([], 0), ([0], 0), ([1], 3), ([0, 1], 1), ([1, 2], 5)]
 )
 def test_index_offset(arr, args, ret):
     assert m.index_at(arr, *args) == ret
     assert m.index_at_t(arr, *args) == ret
     assert m.offset_at(arr, *args) == ret * arr.dtype.itemsize
     assert m.offset_at_t(arr, *args) == ret * arr.dtype.itemsize
 
@@ -92,15 +89,15 @@
     ):
         with pytest.raises(IndexError) as excinfo:
             func(arr, 1, 2, 3)
         assert str(excinfo.value) == "too many indices for an array: 3 (ndim = 2)"
 
 
 @pytest.mark.parametrize(
-    "args, ret",
+    ("args", "ret"),
     [
         ([], [1, 2, 3, 4, 5, 6]),
         ([1], [4, 5, 6]),
         ([0, 1], [2, 3, 4, 5, 6]),
         ([1, 2], [6]),
     ],
 )
@@ -113,17 +110,15 @@
 
 
 @pytest.mark.parametrize("dim", [0, 1, 3])
 def test_at_fail(arr, dim):
     for func in m.at_t, m.mutate_at_t:
         with pytest.raises(IndexError) as excinfo:
             func(arr, *([0] * dim))
-        assert str(excinfo.value) == "index dimension mismatch: {} (ndim = 2)".format(
-            dim
-        )
+        assert str(excinfo.value) == f"index dimension mismatch: {dim} (ndim = 2)"
 
 
 def test_at(arr):
     assert m.at_t(arr, 0, 2) == 3
     assert m.at_t(arr, 1, 0) == 4
 
     assert all(m.mutate_at_t(arr, 0, 2).ravel() == [1, 2, 4, 4, 5, 6])
@@ -189,44 +184,45 @@
     assert m.scalar_int().ndim == 0
     assert m.scalar_int().shape == ()
     assert m.scalar_int() == 42
 
 
 def test_wrap():
     def assert_references(a, b, base=None):
-        from distutils.version import LooseVersion
-
         if base is None:
             base = a
         assert a is not b
         assert a.__array_interface__["data"][0] == b.__array_interface__["data"][0]
         assert a.shape == b.shape
         assert a.strides == b.strides
         assert a.flags.c_contiguous == b.flags.c_contiguous
         assert a.flags.f_contiguous == b.flags.f_contiguous
         assert a.flags.writeable == b.flags.writeable
         assert a.flags.aligned == b.flags.aligned
-        if LooseVersion(np.__version__) >= LooseVersion("1.14.0"):
+        # 1.13 supported Python 3.6
+        if tuple(int(x) for x in np.__version__.split(".")[:2]) >= (1, 14):
             assert a.flags.writebackifcopy == b.flags.writebackifcopy
         else:
             assert a.flags.updateifcopy == b.flags.updateifcopy
         assert np.all(a == b)
         assert not b.flags.owndata
         assert b.base is base
         if a.flags.writeable and a.ndim == 2:
             a[0, 0] = 1234
             assert b[0, 0] == 1234
 
     a1 = np.array([1, 2], dtype=np.int16)
-    assert a1.flags.owndata and a1.base is None
+    assert a1.flags.owndata
+    assert a1.base is None
     a2 = m.wrap(a1)
     assert_references(a1, a2)
 
     a1 = np.array([[1, 2], [3, 4]], dtype=np.float32, order="F")
-    assert a1.flags.owndata and a1.base is None
+    assert a1.flags.owndata
+    assert a1.base is None
     a2 = m.wrap(a1)
     assert_references(a1, a2)
 
     a1 = np.array([[1, 2], [3, 4]], dtype=np.float32, order="C")
     a1.flags.writeable = False
     a2 = m.wrap(a1)
     assert_references(a1, a2)
@@ -298,15 +294,15 @@
     assert defaults["array"].dtype == np.array([]).dtype
     assert defaults["array_t<int32>"].dtype == np.int32
     assert defaults["array_t<double>"].dtype == np.float64
 
     results = m.converting_constructors([1, 2, 3])
     for a in results.values():
         np.testing.assert_array_equal(a, [1, 2, 3])
-    assert results["array"].dtype == np.int_
+    assert results["array"].dtype == np.dtype(int)
     assert results["array_t<int32>"].dtype == np.int32
     assert results["array_t<double>"].dtype == np.float64
 
 
 def test_overload_resolution(msg):
     # Exact overload matches:
     assert m.overloaded(np.array([1], dtype="float64")) == "double"
@@ -453,21 +449,23 @@
     # total size change should succced with refcheck off
     m.array_resize3(a, 4, False)
     assert a.size == 64
     # ... and fail with refcheck on
     try:
         m.array_resize3(a, 3, True)
     except ValueError as e:
-        assert str(e).startswith("cannot resize an array")
+        assert str(e).startswith("cannot resize an array")  # noqa: PT017
     # transposed array doesn't own data
     b = a.transpose()
     try:
         m.array_resize3(b, 3, False)
     except ValueError as e:
-        assert str(e).startswith("cannot resize this array: it does not own its data")
+        assert str(e).startswith(  # noqa: PT017
+            "cannot resize this array: it does not own its data"
+        )
     # ... but reshape should be fine
     m.array_reshape2(b)
     assert b.shape == (8, 8)
 
 
 @pytest.mark.xfail("env.PYPY")
 def test_array_create_and_resize():
@@ -534,15 +532,20 @@
     assert "numpy.ndarray[numpy.float" in test_func.__doc__
 
 
 @pytest.mark.parametrize("forcecast", [False, True])
 @pytest.mark.parametrize("contiguity", [None, "C", "F"])
 @pytest.mark.parametrize("noconvert", [False, True])
 @pytest.mark.filterwarnings(
-    "ignore:Casting complex values to real discards the imaginary part:numpy.ComplexWarning"
+    "ignore:Casting complex values to real discards the imaginary part:"
+    + (
+        "numpy.exceptions.ComplexWarning"
+        if hasattr(np, "exceptions")
+        else "numpy.ComplexWarning"
+    )
 )
 def test_argument_conversions(forcecast, contiguity, noconvert):
     function_name = "accept_double"
     if contiguity == "C":
         function_name += "_c_style"
     elif contiguity == "F":
         function_name += "_f_style"
@@ -581,13 +584,91 @@
                         function(array)
 
 
 @pytest.mark.xfail("env.PYPY")
 def test_dtype_refcount_leak():
     from sys import getrefcount
 
-    dtype = np.dtype(np.float_)
+    # Was np.float_ but that alias for float64 was removed in NumPy 2.
+    dtype = np.dtype(np.float64)
     a = np.array([1], dtype=dtype)
     before = getrefcount(dtype)
     m.ndim(a)
     after = getrefcount(dtype)
     assert after == before
+
+
+def test_round_trip_float():
+    arr = np.zeros((), np.float64)
+    arr[()] = 37.2
+    assert m.round_trip_float(arr) == 37.2
+
+
+# HINT: An easy and robust way (although only manual unfortunately) to check for
+#       ref-count leaks in the test_.*pyobject_ptr.* functions below is to
+#           * temporarily insert `while True:` (one-by-one),
+#           * run this test, and
+#           * run the Linux `top` command in another shell to visually monitor
+#             `RES` for a minute or two.
+#       If there is a leak, it is usually evident in seconds because the `RES`
+#       value increases without bounds. (Don't forget to Ctrl-C the test!)
+
+
+# For use as a temporary user-defined object, to maximize sensitivity of the tests below:
+#     * Ref-count leaks will be immediately evident.
+#     * Sanitizers are much more likely to detect heap-use-after-free due to
+#       other ref-count bugs.
+class PyValueHolder:
+    def __init__(self, value):
+        self.value = value
+
+
+def WrapWithPyValueHolder(*values):
+    return [PyValueHolder(v) for v in values]
+
+
+def UnwrapPyValueHolder(vhs):
+    return [vh.value for vh in vhs]
+
+
+def test_pass_array_pyobject_ptr_return_sum_str_values_ndarray():
+    # Intentionally all temporaries, do not change.
+    assert (
+        m.pass_array_pyobject_ptr_return_sum_str_values(
+            np.array(WrapWithPyValueHolder(-3, "four", 5.0), dtype=object)
+        )
+        == "-3four5.0"
+    )
+
+
+def test_pass_array_pyobject_ptr_return_sum_str_values_list():
+    # Intentionally all temporaries, do not change.
+    assert (
+        m.pass_array_pyobject_ptr_return_sum_str_values(
+            WrapWithPyValueHolder(2, "three", -4.0)
+        )
+        == "2three-4.0"
+    )
+
+
+def test_pass_array_pyobject_ptr_return_as_list():
+    # Intentionally all temporaries, do not change.
+    assert UnwrapPyValueHolder(
+        m.pass_array_pyobject_ptr_return_as_list(
+            np.array(WrapWithPyValueHolder(-1, "two", 3.0), dtype=object)
+        )
+    ) == [-1, "two", 3.0]
+
+
+@pytest.mark.parametrize(
+    ("return_array_pyobject_ptr", "unwrap"),
+    [
+        (m.return_array_pyobject_ptr_cpp_loop, list),
+        (m.return_array_pyobject_ptr_from_list, UnwrapPyValueHolder),
+    ],
+)
+def test_return_array_pyobject_ptr_cpp_loop(return_array_pyobject_ptr, unwrap):
+    # Intentionally all temporaries, do not change.
+    arr_from_list = return_array_pyobject_ptr(WrapWithPyValueHolder(6, "seven", -8.0))
+    assert isinstance(arr_from_list, np.ndarray)
+    assert arr_from_list.dtype == np.dtype("O")
+    assert unwrap(arr_from_list) == [6, "seven", -8.0]
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_numpy_dtypes.cpp` & `python_prtree-0.6.1/third/pybind11/tests/test_numpy_dtypes.cpp`

 * *Files 10% similar despite different names*

```diff
@@ -153,15 +153,15 @@
         nullptr, sizeof(T), py::format_descriptor<T>::format(), 1, {n}, {sizeof(T)}));
 }
 
 #define SET_TEST_VALS(s, i)                                                                       \
     do {                                                                                          \
         (s).bool_ = (i) % 2 != 0;                                                                 \
         (s).uint_ = (uint32_t) (i);                                                               \
-        (s).float_ = (float) (i) *1.5f;                                                           \
+        (s).float_ = (float) (i) * 1.5f;                                                          \
         (s).ldbl_ = (long double) (i) * -2.5L;                                                    \
     } while (0)
 
 template <typename S>
 py::array_t<S, 0> create_recarray(size_t n) {
     auto arr = mkarray_via_buffer<S>(n);
     auto req = arr.request();
@@ -285,26 +285,27 @@
     dict["offsets"] = offsets;
     formats.append(py::dtype("int32"));
     formats.append(py::dtype("float64"));
     dict["formats"] = formats;
     dict["itemsize"] = py::int_(20);
     list.append(py::dtype::from_args(dict));
     list.append(py::dtype(names, formats, offsets, 20));
-    list.append(py::dtype(py::buffer_info((void *) 0, sizeof(unsigned int), "I", 1)));
-    list.append(py::dtype(py::buffer_info((void *) 0, 0, "T{i:a:f:b:}", 1)));
+    list.append(py::dtype(py::buffer_info((void *) nullptr, sizeof(unsigned int), "I", 1)));
+    list.append(py::dtype(py::buffer_info((void *) nullptr, 0, "T{i:a:f:b:}", 1)));
+    list.append(py::dtype(py::detail::npy_api::NPY_DOUBLE_));
     return list;
 }
 
 struct A {};
 struct B {};
 
 TEST_SUBMODULE(numpy_dtypes, m) {
     try {
         py::module_::import("numpy");
-    } catch (...) {
+    } catch (const py::error_already_set &) {
         return;
     }
 
     // typeinfo may be registered before the dtype descriptor for scalar casts to work...
     py::class_<SimpleStruct>(m, "SimpleStruct")
         // Explicit construct to ensure zero-valued initialization.
         .def(py::init([]() { return SimpleStruct(); }))
@@ -400,18 +401,43 @@
                                 py::format_descriptor<ComplexStruct>::format()}) {
             l.append(py::cast(fmt));
         }
         return l;
     });
 
     // test_dtype
+    // Below we use `L` for unsigned long as unfortunately the only name that
+    // works reliably on Both NumPy 2.x and old NumPy 1.x.
     std::vector<const char *> dtype_names{
-        "byte",    "short",   "intc",        "int_",  "longlong",   "ubyte",       "ushort",
-        "uintc",   "uint",    "ulonglong",   "half",  "single",     "double",      "longdouble",
-        "csingle", "cdouble", "clongdouble", "bool_", "datetime64", "timedelta64", "object_"};
+        "byte",
+        "short",
+        "intc",
+        "long",
+        "longlong",
+        "ubyte",
+        "ushort",
+        "uintc",
+        "L",
+        "ulonglong",
+        "half",
+        "single",
+        "double",
+        "longdouble",
+        "csingle",
+        "cdouble",
+        "clongdouble",
+        "bool_",
+        "datetime64",
+        "timedelta64",
+        "object_",
+        // platform dependent aliases (int_ and uint are also NumPy version dependent on windows)
+        "int_",
+        "uint",
+        "intp",
+        "uintp"};
 
     m.def("print_dtypes", []() {
         py::list l;
         for (const py::handle &d : {py::dtype::of<SimpleStruct>(),
                                     py::dtype::of<PackedStruct>(),
                                     py::dtype::of<NestedStruct>(),
                                     py::dtype::of<PartialStruct>(),
@@ -436,14 +462,42 @@
     m.def("test_dtype_char_", [dtype_names]() {
         py::list list;
         for (const auto &dt_name : dtype_names) {
             list.append(py::dtype(dt_name).char_());
         }
         return list;
     });
+    m.def("test_dtype_num", [dtype_names]() {
+        py::list list;
+        for (const auto &dt_name : dtype_names) {
+            list.append(py::dtype(dt_name).num());
+        }
+        return list;
+    });
+    m.def("test_dtype_byteorder", [dtype_names]() {
+        py::list list;
+        for (const auto &dt_name : dtype_names) {
+            list.append(py::dtype(dt_name).byteorder());
+        }
+        return list;
+    });
+    m.def("test_dtype_alignment", [dtype_names]() {
+        py::list list;
+        for (const auto &dt_name : dtype_names) {
+            list.append(py::dtype(dt_name).alignment());
+        }
+        return list;
+    });
+    m.def("test_dtype_flags", [dtype_names]() {
+        py::list list;
+        for (const auto &dt_name : dtype_names) {
+            list.append(py::dtype(dt_name).flags());
+        }
+        return list;
+    });
     m.def("test_dtype_methods", []() {
         py::list list;
         auto dt1 = py::dtype::of<int32_t>();
         auto dt2 = py::dtype::of<SimpleStruct>();
         list.append(dt1);
         list.append(dt2);
         list.append(py::bool_(dt1.has_fields()));
@@ -577,9 +631,9 @@
     m.def("f_simple_pass_thru_vectorized", py::vectorize(f_simple_pass_thru));
 
     // test_register_dtype
     m.def("register_dtype",
           []() { PYBIND11_NUMPY_DTYPE(SimpleStruct, bool_, uint_, float_, ldbl_); });
 
     // test_str_leak
-    m.def("dtype_wrapper", [](py::object d) { return py::dtype::from_args(std::move(d)); });
+    m.def("dtype_wrapper", [](const py::object &d) { return py::dtype::from_args(d); });
 }
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_numpy_dtypes.py` & `python_prtree-0.6.1/third/pybind11/tests/test_numpy_dtypes.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,25 +1,25 @@
-# -*- coding: utf-8 -*-
 import re
 
 import pytest
 
 import env  # noqa: F401
+from pybind11_tests import PYBIND11_NUMPY_1_ONLY
 from pybind11_tests import numpy_dtypes as m
 
 np = pytest.importorskip("numpy")
 
 
 @pytest.fixture(scope="module")
 def simple_dtype():
     ld = np.dtype("longdouble")
     return np.dtype(
         {
             "names": ["bool_", "uint_", "float_", "ldbl_"],
-            "formats": ["?", "u4", "f4", "f{}".format(ld.itemsize)],
+            "formats": ["?", "u4", "f4", f"f{ld.itemsize}"],
             "offsets": [0, 4, 8, (16 if ld.alignment > 4 else 12)],
         }
     )
 
 
 @pytest.fixture(scope="module")
 def packed_dtype():
@@ -122,27 +122,23 @@
     from sys import byteorder
 
     e = "<" if byteorder == "little" else ">"
 
     assert [x.replace(" ", "") for x in m.print_dtypes()] == [
         simple_dtype_fmt(),
         packed_dtype_fmt(),
-        "[('a',{}),('b',{})]".format(simple_dtype_fmt(), packed_dtype_fmt()),
+        f"[('a',{simple_dtype_fmt()}),('b',{packed_dtype_fmt()})]",
         partial_dtype_fmt(),
         partial_nested_fmt(),
         "[('a','S3'),('b','S3')]",
         (
-            "{{'names':['a','b','c','d'],"
-            + "'formats':[('S4',(3,)),('"
-            + e
-            + "i4',(2,)),('u1',(3,)),('"
-            + e
-            + "f4',(4,2))],"
-            + "'offsets':[0,12,20,24],'itemsize':56}}"
-        ).format(e=e),
+            "{'names':['a','b','c','d'],"
+            f"'formats':[('S4',(3,)),('{e}i4',(2,)),('u1',(3,)),('{e}f4',(4,2))],"
+            "'offsets':[0,12,20,24],'itemsize':56}"
+        ),
         "[('e1','" + e + "i8'),('e2','u1')]",
         "[('x','i1'),('y','" + e + "u8')]",
         "[('cflt','" + e + "c8'),('cdbl','" + e + "c16')]",
     ]
 
     d1 = np.dtype(
         {
@@ -157,14 +153,15 @@
         np.dtype("int32"),
         np.dtype("float64"),
         np.dtype("bool"),
         d1,
         d1,
         np.dtype("uint32"),
         d2,
+        np.dtype("d"),
     ]
 
     assert m.test_dtype_methods() == [
         np.dtype("int32"),
         simple_dtype,
         False,
         True,
@@ -172,16 +169,28 @@
         simple_dtype.itemsize,
     ]
 
     assert m.trailing_padding_dtype() == m.buffer_to_dtype(
         np.zeros(1, m.trailing_padding_dtype())
     )
 
-    assert m.test_dtype_kind() == list("iiiiiuuuuuffffcccbMmO")
-    assert m.test_dtype_char_() == list("bhilqBHILQefdgFDG?MmO")
+    expected_chars = list("bhilqBHILQefdgFDG?MmO")
+    # Note that int_ and uint size and mapping is NumPy version dependent:
+    expected_chars += [np.dtype(_).char for _ in ("int_", "uint", "intp", "uintp")]
+    assert m.test_dtype_kind() == list("iiiiiuuuuuffffcccbMmOiuiu")
+    assert m.test_dtype_char_() == list(expected_chars)
+    assert m.test_dtype_num() == [np.dtype(ch).num for ch in expected_chars]
+    assert m.test_dtype_byteorder() == [np.dtype(ch).byteorder for ch in expected_chars]
+    assert m.test_dtype_alignment() == [np.dtype(ch).alignment for ch in expected_chars]
+    if not PYBIND11_NUMPY_1_ONLY:
+        assert m.test_dtype_flags() == [np.dtype(ch).flags for ch in expected_chars]
+    else:
+        assert m.test_dtype_flags() == [
+            chr(np.dtype(ch).flags) for ch in expected_chars
+        ]
 
 
 def test_recarray(simple_dtype, packed_dtype):
     elements = [(False, 0, 0.0, -0.0), (True, 1, 1.5, -2.5), (False, 2, 3.0, -5.0)]
 
     for func, dtype in [
         (m.create_rec_simple, simple_dtype),
@@ -282,27 +291,25 @@
 def test_array_array():
     from sys import byteorder
 
     e = "<" if byteorder == "little" else ">"
 
     arr = m.create_array_array(3)
     assert str(arr.dtype).replace(" ", "") == (
-        "{{'names':['a','b','c','d'],"
-        + "'formats':[('S4',(3,)),('"
-        + e
-        + "i4',(2,)),('u1',(3,)),('{e}f4',(4,2))],"
-        + "'offsets':[0,12,20,24],'itemsize':56}}"
-    ).format(e=e)
+        "{'names':['a','b','c','d'],"
+        f"'formats':[('S4',(3,)),('{e}i4',(2,)),('u1',(3,)),('{e}f4',(4,2))],"
+        "'offsets':[0,12,20,24],'itemsize':56}"
+    )
     assert m.print_array_array(arr) == [
         "a={{A,B,C,D},{K,L,M,N},{U,V,W,X}},b={0,1},"
-        + "c={0,1,2},d={{0,1},{10,11},{20,21},{30,31}}",
+        "c={0,1,2},d={{0,1},{10,11},{20,21},{30,31}}",
         "a={{W,X,Y,Z},{G,H,I,J},{Q,R,S,T}},b={1000,1001},"
-        + "c={10,11,12},d={{100,101},{110,111},{120,121},{130,131}}",
+        "c={10,11,12},d={{100,101},{110,111},{120,121},{130,131}}",
         "a={{S,T,U,V},{C,D,E,F},{M,N,O,P}},b={2000,2001},"
-        + "c={20,21,22},d={{200,201},{210,211},{220,221},{230,231}}",
+        "c={20,21,22},d={{200,201},{210,211},{220,221},{230,231}}",
     ]
     assert arr["a"].tolist() == [
         [b"ABCD", b"KLMN", b"UVWX"],
         [b"WXYZ", b"GHIJ", b"QRST"],
         [b"STUV", b"CDEF", b"MNOP"],
     ]
     assert arr["b"].tolist() == [[0, 1], [1000, 1001], [2000, 2001]]
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_numpy_vectorize.cpp` & `python_prtree-0.6.1/third/pybind11/tests/test_numpy_vectorize.cpp`

 * *Files 5% similar despite different names*

```diff
@@ -18,15 +18,15 @@
     py::print("my_func(x:int={}, y:float={:.0f}, z:float={:.0f})"_s.format(x, y, z));
     return (float) x * y * z;
 }
 
 TEST_SUBMODULE(numpy_vectorize, m) {
     try {
         py::module_::import("numpy");
-    } catch (...) {
+    } catch (const py::error_already_set &) {
         return;
     }
 
     // test_vectorize, test_docs, test_array_collapse
     // Vectorize all arguments of a function (though non-vector arguments are also allowed)
     m.def("vectorized_func", py::vectorize(my_func));
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_numpy_vectorize.py` & `python_prtree-0.6.1/third/pybind11/tests/test_numpy_vectorize.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 import pytest
 
 from pybind11_tests import numpy_vectorize as m
 
 np = pytest.importorskip("numpy")
 
 
@@ -146,15 +145,15 @@
 
 
 def test_docs(doc):
     assert (
         doc(m.vectorized_func)
         == """
         vectorized_func(arg0: numpy.ndarray[numpy.int32], arg1: numpy.ndarray[numpy.float32], arg2: numpy.ndarray[numpy.float64]) -> object
-    """  # noqa: E501 line too long
+    """
     )
 
 
 def test_trivial_broadcasting():
     trivial, vectorized_is_trivial = m.trivial, m.vectorized_is_trivial
 
     assert vectorized_is_trivial(1, 2, 3) == trivial.c_trivial
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_opaque_types.cpp` & `python_prtree-0.6.1/third/pybind11/tests/test_opaque_types.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_opaque_types.py` & `python_prtree-0.6.1/third/pybind11/tests/test_opaque_types.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,23 +1,22 @@
-# -*- coding: utf-8 -*-
 import pytest
 
 from pybind11_tests import ConstructorStats, UserType
 from pybind11_tests import opaque_types as m
 
 
 def test_string_list():
     lst = m.StringList()
     lst.push_back("Element 1")
     lst.push_back("Element 2")
     assert m.print_opaque_list(lst) == "Opaque list: [Element 1, Element 2]"
     assert lst.back() == "Element 2"
 
     for i, k in enumerate(lst, start=1):
-        assert k == "Element {}".format(i)
+        assert k == f"Element {i}"
     lst.pop_back()
     assert m.print_opaque_list(lst) == "Opaque list: [Element 1]"
 
     cvp = m.ClassWithSTLVecProperty()
     assert m.print_opaque_list(cvp.stringList) == "Opaque list: []"
 
     cvp.stringList = lst
@@ -36,15 +35,15 @@
     assert (
         msg(excinfo.value)
         == """
         get_void_ptr_value(): incompatible function arguments. The following argument types are supported:
             1. (arg0: capsule) -> int
 
         Invoked with: [1, 2, 3]
-    """  # noqa: E501 line too long
+    """
     )
 
     assert m.return_null_str() is None
     assert m.get_null_str_value(m.return_null_str()) is not None
 
     ptr = m.return_unique_ptr()
     assert "StringList" in repr(ptr)
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_operator_overloading.cpp` & `python_prtree-0.6.1/third/pybind11/tests/test_operator_overloading.cpp`

 * *Files 8% similar despite different names*

```diff
@@ -128,30 +128,26 @@
     }
 };
 } // namespace std
 
 // Not a good abs function, but easy to test.
 std::string abs(const Vector2 &) { return "abs(Vector2)"; }
 
-// MSVC & Intel warns about unknown pragmas, and warnings are errors.
-#if !defined(_MSC_VER) && !defined(__INTEL_COMPILER)
-#    pragma GCC diagnostic push
 // clang 7.0.0 and Apple LLVM 10.0.1 introduce `-Wself-assign-overloaded` to
 // `-Wall`, which is used here for overloading (e.g. `py::self += py::self `).
-// Here, we suppress the warning using `#pragma diagnostic`.
+// Here, we suppress the warning
 // Taken from: https://github.com/RobotLocomotion/drake/commit/aaf84b46
 // TODO(eric): This could be resolved using a function / functor (e.g. `py::self()`).
-#    if defined(__APPLE__) && defined(__clang__)
-#        if (__clang_major__ >= 10)
-#            pragma GCC diagnostic ignored "-Wself-assign-overloaded"
-#        endif
-#    elif defined(__clang__)
-#        if (__clang_major__ >= 7)
-#            pragma GCC diagnostic ignored "-Wself-assign-overloaded"
-#        endif
+#if defined(__APPLE__) && defined(__clang__)
+#    if (__clang_major__ >= 10)
+PYBIND11_WARNING_DISABLE_CLANG("-Wself-assign-overloaded")
+#    endif
+#elif defined(__clang__)
+#    if (__clang_major__ >= 7)
+PYBIND11_WARNING_DISABLE_CLANG("-Wself-assign-overloaded")
 #    endif
 #endif
 
 TEST_SUBMODULE(operators, m) {
 
     // test_operator_overloading
     py::class_<Vector2>(m, "Vector2")
@@ -279,10 +275,7 @@
         .def(py::self == py::self);
 
     // define __eq__ but not __hash__
     py::class_<HashMe>(m, "HashMe").def(py::self == py::self);
 
     m.def("get_unhashable_HashMe_set", []() { return std::unordered_set<HashMe>{{"one"}}; });
 }
-#if !defined(_MSC_VER) && !defined(__INTEL_COMPILER)
-#    pragma GCC diagnostic pop
-#endif
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_operator_overloading.py` & `python_prtree-0.6.1/third/pybind11/tests/test_operator_overloading.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,9 @@
-# -*- coding: utf-8 -*-
 import pytest
 
-import env
 from pybind11_tests import ConstructorStats
 from pybind11_tests import operators as m
 
 
 def test_operator_overloading():
     v1 = m.Vector2(1, 2)
     v2 = m.Vector(3, -1)
@@ -128,15 +126,14 @@
 
     assert abase.value == 42
     del abase, b
     pytest.gc_collect()
 
 
 def test_overriding_eq_reset_hash():
-
     assert m.Comparable(15) is not m.Comparable(15)
     assert m.Comparable(15) == m.Comparable(15)
 
     with pytest.raises(TypeError) as excinfo:
         hash(m.Comparable(15))
     assert str(excinfo.value).startswith("unhashable type:")
 
@@ -147,9 +144,8 @@
         assert hash(hashable(15)) == 15
         assert hash(hashable(15)) == hash(hashable(15))
 
 
 def test_return_set_of_unhashable():
     with pytest.raises(TypeError) as excinfo:
         m.get_unhashable_HashMe_set()
-    if not env.PY2:
-        assert str(excinfo.value.__cause__).startswith("unhashable type:")
+    assert str(excinfo.value.__cause__).startswith("unhashable type:")
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_pickling.cpp` & `python_prtree-0.6.1/third/pybind11/tests/test_pickling.cpp`

 * *Files 3% similar despite different names*

```diff
@@ -1,22 +1,19 @@
-// clang-format off
 /*
     tests/test_pickling.cpp -- pickle support
 
     Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
     Copyright (c) 2021 The Pybind Development Team.
 
     All rights reserved. Use of this source code is governed by a
     BSD-style license that can be found in the LICENSE file.
 */
 
 #include "pybind11_tests.h"
 
-// clang-format on
-
 #include <memory>
 #include <stdexcept>
 #include <utility>
 
 namespace exercise_trampoline {
 
 struct SimpleBase {
@@ -59,41 +56,41 @@
     m.def("check_dynamic_cast_SimpleCppDerived", [](const SimpleBase *base_ptr) {
         return dynamic_cast<const SimpleCppDerived *>(base_ptr) != nullptr;
     });
 }
 
 } // namespace exercise_trampoline
 
-// clang-format off
-
 TEST_SUBMODULE(pickling, m) {
+    m.def("simple_callable", []() { return 20220426; });
+
     // test_roundtrip
     class Pickleable {
     public:
-        explicit Pickleable(const std::string &value) : m_value(value) { }
+        explicit Pickleable(const std::string &value) : m_value(value) {}
         const std::string &value() const { return m_value; }
 
         void setExtra1(int extra1) { m_extra1 = extra1; }
         void setExtra2(int extra2) { m_extra2 = extra2; }
         int extra1() const { return m_extra1; }
         int extra2() const { return m_extra2; }
+
     private:
         std::string m_value;
         int m_extra1 = 0;
         int m_extra2 = 0;
     };
 
     class PickleableNew : public Pickleable {
     public:
         using Pickleable::Pickleable;
     };
 
     py::class_<Pickleable> pyPickleable(m, "Pickleable");
-    pyPickleable
-        .def(py::init<std::string>())
+    pyPickleable.def(py::init<std::string>())
         .def("value", &Pickleable::value)
         .def("extra1", &Pickleable::extra1)
         .def("extra2", &Pickleable::extra2)
         .def("setExtra1", &Pickleable::setExtra1)
         .def("setExtra2", &Pickleable::setExtra2)
         // For details on the methods below, refer to
         // http://docs.python.org/3/library/pickle.html#pickling-class-instances
@@ -101,15 +98,15 @@
             /* Return a tuple that fully encodes the state of the object */
             return py::make_tuple(p.value(), p.extra1(), p.extra2());
         });
     ignoreOldStyleInitWarnings([&pyPickleable]() {
         pyPickleable.def("__setstate__", [](Pickleable &p, const py::tuple &t) {
             if (t.size() != 3) {
                 throw std::runtime_error("Invalid state!");
-}
+            }
             /* Invoke the constructor (need to use in-place version) */
             new (&p) Pickleable(t[0].cast<std::string>());
 
             /* Assign any additional state */
             p.setExtra1(t[1].cast<int>());
             p.setExtra2(t[2].cast<int>());
         });
@@ -120,50 +117,51 @@
         .def(py::pickle(
             [](const PickleableNew &p) {
                 return py::make_tuple(p.value(), p.extra1(), p.extra2());
             },
             [](const py::tuple &t) {
                 if (t.size() != 3) {
                     throw std::runtime_error("Invalid state!");
-}
+                }
                 auto p = PickleableNew(t[0].cast<std::string>());
 
                 p.setExtra1(t[1].cast<int>());
                 p.setExtra2(t[2].cast<int>());
                 return p;
             }));
 
 #if !defined(PYPY_VERSION)
     // test_roundtrip_with_dict
     class PickleableWithDict {
     public:
-        explicit PickleableWithDict(const std::string &value) : value(value) { }
+        explicit PickleableWithDict(const std::string &value) : value(value) {}
 
         std::string value;
         int extra;
     };
 
     class PickleableWithDictNew : public PickleableWithDict {
     public:
         using PickleableWithDict::PickleableWithDict;
     };
 
-    py::class_<PickleableWithDict> pyPickleableWithDict(m, "PickleableWithDict", py::dynamic_attr());
+    py::class_<PickleableWithDict> pyPickleableWithDict(
+        m, "PickleableWithDict", py::dynamic_attr());
     pyPickleableWithDict.def(py::init<std::string>())
         .def_readwrite("value", &PickleableWithDict::value)
         .def_readwrite("extra", &PickleableWithDict::extra)
         .def("__getstate__", [](const py::object &self) {
             /* Also include __dict__ in state */
             return py::make_tuple(self.attr("value"), self.attr("extra"), self.attr("__dict__"));
         });
     ignoreOldStyleInitWarnings([&pyPickleableWithDict]() {
         pyPickleableWithDict.def("__setstate__", [](const py::object &self, const py::tuple &t) {
             if (t.size() != 3) {
                 throw std::runtime_error("Invalid state!");
-}
+            }
             /* Cast and construct */
             auto &p = self.cast<PickleableWithDict &>();
             new (&p) PickleableWithDict(t[0].cast<std::string>());
 
             /* Assign C++ state */
             p.extra = t[1].cast<int>();
 
@@ -172,20 +170,21 @@
         });
     });
 
     py::class_<PickleableWithDictNew, PickleableWithDict>(m, "PickleableWithDictNew")
         .def(py::init<std::string>())
         .def(py::pickle(
             [](const py::object &self) {
-                return py::make_tuple(self.attr("value"), self.attr("extra"), self.attr("__dict__"));
+                return py::make_tuple(
+                    self.attr("value"), self.attr("extra"), self.attr("__dict__"));
             },
             [](const py::tuple &t) {
                 if (t.size() != 3) {
                     throw std::runtime_error("Invalid state!");
-}
+                }
 
                 auto cpp_state = PickleableWithDictNew(t[0].cast<std::string>());
                 cpp_state.extra = t[1].cast<int>();
 
                 auto py_state = t[2].cast<py::dict>();
                 return std::make_pair(cpp_state, py_state);
             }));
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_pickling.py` & `python_prtree-0.6.1/third/pybind11/tests/test_pickling.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,17 +1,28 @@
-# -*- coding: utf-8 -*-
+import pickle
+import re
+
 import pytest
 
 import env
 from pybind11_tests import pickling as m
 
-try:
-    import cPickle as pickle  # Use cPickle on Python 2.7
-except ImportError:
-    import pickle
+
+def test_pickle_simple_callable():
+    assert m.simple_callable() == 20220426
+    if env.PYPY:
+        serialized = pickle.dumps(m.simple_callable)
+        deserialized = pickle.loads(serialized)
+        assert deserialized() == 20220426
+    else:
+        # To document broken behavior: currently it fails universally with
+        # all C Python versions.
+        with pytest.raises(TypeError) as excinfo:
+            pickle.dumps(m.simple_callable)
+        assert re.search("can.*t pickle .*PyCapsule.* object", str(excinfo.value))
 
 
 @pytest.mark.parametrize("cls_name", ["Pickleable", "PickleableNew"])
 def test_roundtrip(cls_name):
     cls = getattr(m, cls_name)
     p = cls("test_value")
     p.setExtra1(15)
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_pytypes.py` & `python_prtree-0.6.1/third/pybind11/tests/test_pytypes.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,31 +1,57 @@
-# -*- coding: utf-8 -*-
-from __future__ import division
-
+import contextlib
 import sys
+import types
 
 import pytest
 
 import env
-from pybind11_tests import debug_enabled
+from pybind11_tests import detailed_error_messages_enabled
 from pybind11_tests import pytypes as m
 
 
+def test_obj_class_name():
+    assert m.obj_class_name(None) == "NoneType"
+    assert m.obj_class_name(list) == "list"
+    assert m.obj_class_name([]) == "list"
+
+
+def test_handle_from_move_only_type_with_operator_PyObject():
+    assert m.handle_from_move_only_type_with_operator_PyObject_ncnst()
+    assert m.handle_from_move_only_type_with_operator_PyObject_const()
+
+
 def test_bool(doc):
     assert doc(m.get_bool) == "get_bool() -> bool"
 
 
 def test_int(doc):
     assert doc(m.get_int) == "get_int() -> int"
 
 
 def test_iterator(doc):
     assert doc(m.get_iterator) == "get_iterator() -> Iterator"
 
 
+@pytest.mark.parametrize(
+    ("pytype", "from_iter_func"),
+    [
+        (frozenset, m.get_frozenset_from_iterable),
+        (list, m.get_list_from_iterable),
+        (set, m.get_set_from_iterable),
+        (tuple, m.get_tuple_from_iterable),
+    ],
+)
+def test_from_iterable(pytype, from_iter_func):
+    my_iter = iter(range(10))
+    s = from_iter_func(my_iter)
+    assert type(s) == pytype
+    assert s == pytype(range(10))
+
+
 def test_iterable(doc):
     assert doc(m.get_iterable) == "get_iterable() -> Iterable"
 
 
 def test_float(doc):
     assert doc(m.get_float) == "get_float() -> float"
 
@@ -57,42 +83,74 @@
     """
     )
 
     assert doc(m.get_list) == "get_list() -> list"
     assert doc(m.print_list) == "print_list(arg0: list) -> None"
 
 
-def test_none(capture, doc):
+def test_none(doc):
     assert doc(m.get_none) == "get_none() -> None"
     assert doc(m.print_none) == "print_none(arg0: None) -> None"
 
 
 def test_set(capture, doc):
     s = m.get_set()
+    assert isinstance(s, set)
     assert s == {"key1", "key2", "key3"}
 
+    s.add("key4")
     with capture:
-        s.add("key4")
-        m.print_set(s)
+        m.print_anyset(s)
     assert (
         capture.unordered
         == """
         key: key1
         key: key2
         key: key3
         key: key4
     """
     )
 
-    assert not m.set_contains(set(), 42)
-    assert m.set_contains({42}, 42)
-    assert m.set_contains({"foo"}, "foo")
+    m.set_add(s, "key5")
+    assert m.anyset_size(s) == 5
 
-    assert doc(m.get_list) == "get_list() -> list"
-    assert doc(m.print_list) == "print_list(arg0: list) -> None"
+    m.set_clear(s)
+    assert m.anyset_empty(s)
+
+    assert not m.anyset_contains(set(), 42)
+    assert m.anyset_contains({42}, 42)
+    assert m.anyset_contains({"foo"}, "foo")
+
+    assert doc(m.get_set) == "get_set() -> set"
+    assert doc(m.print_anyset) == "print_anyset(arg0: Union[set, frozenset]) -> None"
+
+
+def test_frozenset(capture, doc):
+    s = m.get_frozenset()
+    assert isinstance(s, frozenset)
+    assert s == frozenset({"key1", "key2", "key3"})
+
+    with capture:
+        m.print_anyset(s)
+    assert (
+        capture.unordered
+        == """
+        key: key1
+        key: key2
+        key: key3
+    """
+    )
+    assert m.anyset_size(s) == 3
+    assert not m.anyset_empty(s)
+
+    assert not m.anyset_contains(frozenset(), 42)
+    assert m.anyset_contains(frozenset({42}), 42)
+    assert m.anyset_contains(frozenset({"foo"}), "foo")
+
+    assert doc(m.get_frozenset) == "get_frozenset() -> frozenset"
 
 
 def test_dict(capture, doc):
     d = m.get_dict()
     assert d == {"key": "value"}
 
     with capture:
@@ -112,22 +170,46 @@
 
     assert doc(m.get_dict) == "get_dict() -> dict"
     assert doc(m.print_dict) == "print_dict(arg0: dict) -> None"
 
     assert m.dict_keyword_constructor() == {"x": 1, "y": 2, "z": 3}
 
 
+class CustomContains:
+    d = {"key": None}
+
+    def __contains__(self, m):
+        return m in self.d
+
+
+@pytest.mark.parametrize(
+    ("arg", "func"),
+    [
+        (set(), m.anyset_contains),
+        ({}, m.dict_contains),
+        (CustomContains(), m.obj_contains),
+    ],
+)
+@pytest.mark.xfail("env.PYPY and sys.pypy_version_info < (7, 3, 10)", strict=False)
+def test_unhashable_exceptions(arg, func):
+    class Unhashable:
+        __hash__ = None
+
+    with pytest.raises(TypeError) as exc_info:
+        func(arg, Unhashable())
+    assert "unhashable type:" in str(exc_info.value)
+
+
 def test_tuple():
     assert m.tuple_no_args() == ()
     assert m.tuple_ssize_t() == ()
     assert m.tuple_size_t() == ()
     assert m.get_tuple() == (42, None, "spam")
 
 
-@pytest.mark.skipif("env.PY2")
 def test_simple_namespace():
     ns = m.get_simple_namespace()
     assert ns.attr == 42
     assert ns.x == "foo"
     assert ns.right == 2
     assert not hasattr(ns, "wrong")
 
@@ -136,15 +218,15 @@
     assert m.str_from_char_ssize_t().encode().decode() == "red"
     assert m.str_from_char_size_t().encode().decode() == "blue"
     assert m.str_from_string().encode().decode() == "baz"
     assert m.str_from_bytes().encode().decode() == "boo"
 
     assert doc(m.str_from_bytes) == "str_from_bytes() -> str"
 
-    class A(object):
+    class A:
         def __str__(self):
             return "this is a str"
 
         def __repr__(self):
             return "this is a repr"
 
     assert m.str_from_object(A()) == "this is a str"
@@ -154,46 +236,48 @@
     s1, s2 = m.str_format()
     assert s1 == "1 + 2 = 3"
     assert s1 == s2
 
     malformed_utf8 = b"\x80"
     if hasattr(m, "PYBIND11_STR_LEGACY_PERMISSIVE"):
         assert m.str_from_object(malformed_utf8) is malformed_utf8
-    elif env.PY2:
-        with pytest.raises(UnicodeDecodeError):
-            m.str_from_object(malformed_utf8)
     else:
         assert m.str_from_object(malformed_utf8) == "b'\\x80'"
-    if env.PY2:
-        with pytest.raises(UnicodeDecodeError):
-            m.str_from_handle(malformed_utf8)
-    else:
-        assert m.str_from_handle(malformed_utf8) == "b'\\x80'"
+    assert m.str_from_handle(malformed_utf8) == "b'\\x80'"
 
     assert m.str_from_string_from_str("this is a str") == "this is a str"
-    ucs_surrogates_str = u"\udcc3"
-    if env.PY2:
-        assert u"\udcc3" == m.str_from_string_from_str(ucs_surrogates_str)
-    else:
-        with pytest.raises(UnicodeEncodeError):
-            m.str_from_string_from_str(ucs_surrogates_str)
+    ucs_surrogates_str = "\udcc3"
+    with pytest.raises(UnicodeEncodeError):
+        m.str_from_string_from_str(ucs_surrogates_str)
+
+
+@pytest.mark.parametrize(
+    "func",
+    [
+        m.str_from_bytes_input,
+        m.str_from_cstr_input,
+        m.str_from_std_string_input,
+    ],
+)
+def test_surrogate_pairs_unicode_error(func):
+    input_str = "\ud83d\ude4f".encode("utf-8", "surrogatepass")
+    with pytest.raises(UnicodeDecodeError):
+        func(input_str)
 
 
 def test_bytes(doc):
     assert m.bytes_from_char_ssize_t().decode() == "green"
     assert m.bytes_from_char_size_t().decode() == "purple"
     assert m.bytes_from_string().decode() == "foo"
     assert m.bytes_from_str().decode() == "bar"
 
-    assert doc(m.bytes_from_str) == "bytes_from_str() -> {}".format(
-        "str" if env.PY2 else "bytes"
-    )
+    assert doc(m.bytes_from_str) == "bytes_from_str() -> bytes"
 
 
-def test_bytearray(doc):
+def test_bytearray():
     assert m.bytearray_from_char_ssize_t().decode() == "$%"
     assert m.bytearray_from_char_size_t().decode() == "@$!"
     assert m.bytearray_from_string().decode() == "foo"
     assert m.bytearray_size() == len("foo")
 
 
 def test_capsule(capture):
@@ -207,37 +291,87 @@
         == """
         creating capsule
         destructing capsule
     """
     )
 
     with capture:
+        a = m.return_renamed_capsule_with_destructor()
+        del a
+        pytest.gc_collect()
+    assert (
+        capture.unordered
+        == """
+        creating capsule
+        renaming capsule
+        destructing capsule
+    """
+    )
+
+    with capture:
         a = m.return_capsule_with_destructor_2()
         del a
         pytest.gc_collect()
     assert (
         capture.unordered
         == """
         creating capsule
         destructing capsule: 1234
     """
     )
 
     with capture:
+        a = m.return_capsule_with_destructor_3()
+        del a
+        pytest.gc_collect()
+    assert (
+        capture.unordered
+        == """
+        creating capsule
+        destructing capsule: 1233
+        original name: oname
+    """
+    )
+
+    with capture:
+        a = m.return_renamed_capsule_with_destructor_2()
+        del a
+        pytest.gc_collect()
+    assert (
+        capture.unordered
+        == """
+        creating capsule
+        renaming capsule
+        destructing capsule: 1234
+    """
+    )
+
+    with capture:
         a = m.return_capsule_with_name_and_destructor()
         del a
         pytest.gc_collect()
     assert (
         capture.unordered
         == """
         created capsule (1234, 'pointer type description')
         destructing capsule (1234, 'pointer type description')
     """
     )
 
+    with capture:
+        a = m.return_capsule_with_explicit_nullptr_dtor()
+        del a
+        pytest.gc_collect()
+    assert (
+        capture.unordered
+        == """
+        creating capsule with explicit nullptr dtor
+    """
+    )
+
 
 def test_accessors():
     class SubTestObject:
         attr_obj = 1
         attr_char = 2
 
     class TestObject:
@@ -260,55 +394,54 @@
     assert d["missing_attr_chain"] == "raised"
     assert d["is_none"] is False
     assert d["operator()"] == 2
     assert d["operator*"] == 7
     assert d["implicit_list"] == [1, 2, 3]
     assert all(x in TestObject.__dict__ for x in d["implicit_dict"])
 
-    assert m.tuple_accessor(tuple()) == (0, 1, 2)
+    assert m.tuple_accessor(()) == (0, 1, 2)
 
     d = m.accessor_assignment()
     assert d["get"] == 0
     assert d["deferred_get"] == 0
     assert d["set"] == 1
     assert d["deferred_set"] == 1
     assert d["var"] == 99
 
 
+def test_accessor_moves():
+    inc_refs = m.accessor_moves()
+    if inc_refs:
+        assert inc_refs == [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]
+    else:
+        pytest.skip("Not defined: PYBIND11_HANDLE_REF_DEBUG")
+
+
 def test_constructors():
     """C++ default and converting constructors are equivalent to type calls in Python"""
     types = [bytes, bytearray, str, bool, int, float, tuple, list, dict, set]
     expected = {t.__name__: t() for t in types}
-    if env.PY2:
-        # Note that bytes.__name__ == 'str' in Python 2.
-        # pybind11::str is unicode even under Python 2.
-        expected["bytes"] = bytes()
-        expected["str"] = unicode()  # noqa: F821
     assert m.default_constructors() == expected
 
     data = {
         bytes: b"41",  # Currently no supported or working conversions.
         bytearray: bytearray(b"41"),
         str: 42,
         bool: "Not empty",
         int: "42",
         float: "+1e3",
         tuple: range(3),
         list: range(3),
         dict: [("two", 2), ("one", 1), ("three", 3)],
         set: [4, 4, 5, 6, 6, 6],
+        frozenset: [4, 4, 5, 6, 6, 6],
         memoryview: b"abc",
     }
     inputs = {k.__name__: v for k, v in data.items()}
     expected = {k.__name__: k(v) for k, v in data.items()}
-    if env.PY2:  # Similar to the above. See comments above.
-        inputs["bytes"] = b"41"
-        inputs["str"] = 42
-        expected["bytes"] = b"41"
-        expected["str"] = u"42"
 
     assert m.converting_constructors(inputs) == expected
     assert m.cast_functions(inputs) == expected
 
     # Converting constructors and cast functions should just reference rather
     # than copy when no conversion is needed:
     noconv1 = m.converting_constructors(expected)
@@ -327,63 +460,56 @@
         ("ellipsis", 42),
         ("type", 42),
     ]
     for t, v in non_converting_test_cases:
         for move in [True, False]:
             with pytest.raises(TypeError) as excinfo:
                 m.nonconverting_constructor(t, v, move)
-            expected_error = "Object of type '{}' is not an instance of '{}'".format(
-                type(v).__name__, t
+            expected_error = (
+                f"Object of type '{type(v).__name__}' is not an instance of '{t}'"
             )
             assert str(excinfo.value) == expected_error
 
 
 def test_pybind11_str_raw_str():
     # specifically to exercise pybind11::str::raw_str
     cvt = m.convert_to_pybind11_str
-    assert cvt(u"Str") == u"Str"
-    assert cvt(b"Bytes") == u"Bytes" if env.PY2 else "b'Bytes'"
-    assert cvt(None) == u"None"
-    assert cvt(False) == u"False"
-    assert cvt(True) == u"True"
-    assert cvt(42) == u"42"
-    assert cvt(2 ** 65) == u"36893488147419103232"
-    assert cvt(-1.50) == u"-1.5"
-    assert cvt(()) == u"()"
-    assert cvt((18,)) == u"(18,)"
-    assert cvt([]) == u"[]"
-    assert cvt([28]) == u"[28]"
-    assert cvt({}) == u"{}"
-    assert cvt({3: 4}) == u"{3: 4}"
-    assert cvt(set()) == u"set([])" if env.PY2 else "set()"
-    assert cvt({3, 3}) == u"set([3])" if env.PY2 else "{3}"
+    assert cvt("Str") == "Str"
+    assert cvt(b"Bytes") == "b'Bytes'"
+    assert cvt(None) == "None"
+    assert cvt(False) == "False"
+    assert cvt(True) == "True"
+    assert cvt(42) == "42"
+    assert cvt(2**65) == "36893488147419103232"
+    assert cvt(-1.50) == "-1.5"
+    assert cvt(()) == "()"
+    assert cvt((18,)) == "(18,)"
+    assert cvt([]) == "[]"
+    assert cvt([28]) == "[28]"
+    assert cvt({}) == "{}"
+    assert cvt({3: 4}) == "{3: 4}"
+    assert cvt(set()) == "set()"
+    assert cvt({3}) == "{3}"
 
-    valid_orig = u""
+    valid_orig = ""
     valid_utf8 = valid_orig.encode("utf-8")
     valid_cvt = cvt(valid_utf8)
     if hasattr(m, "PYBIND11_STR_LEGACY_PERMISSIVE"):
         assert valid_cvt is valid_utf8
     else:
-        assert type(valid_cvt) is unicode if env.PY2 else str  # noqa: F821
-        if env.PY2:
-            assert valid_cvt == valid_orig
-        else:
-            assert valid_cvt == "b'\\xc7\\xb1'"
+        assert type(valid_cvt) is str
+        assert valid_cvt == "b'\\xc7\\xb1'"
 
     malformed_utf8 = b"\x80"
     if hasattr(m, "PYBIND11_STR_LEGACY_PERMISSIVE"):
         assert cvt(malformed_utf8) is malformed_utf8
     else:
-        if env.PY2:
-            with pytest.raises(UnicodeDecodeError):
-                cvt(malformed_utf8)
-        else:
-            malformed_cvt = cvt(malformed_utf8)
-            assert type(malformed_cvt) is str
-            assert malformed_cvt == "b'\\x80'"
+        malformed_cvt = cvt(malformed_utf8)
+        assert type(malformed_cvt) is str
+        assert malformed_cvt == "b'\\x80'"
 
 
 def test_implicit_casting():
     """Tests implicit casting when assigning or appending to dicts and lists."""
     z = m.get_implicit_casting()
     assert z["d"] == {
         "char*_i1": "abc",
@@ -418,28 +544,28 @@
     )
     assert capture.stderr == "this goes to stderr"
 
     with pytest.raises(RuntimeError) as excinfo:
         m.print_failure()
     assert str(excinfo.value) == "Unable to convert call argument " + (
         "'1' of type 'UnregisteredType' to Python object"
-        if debug_enabled
-        else "to Python object (compile in debug mode for details)"
+        if detailed_error_messages_enabled
+        else "'1' to Python object (#define PYBIND11_DETAILED_ERROR_MESSAGES or compile in debug mode for details)"
     )
 
 
 def test_hash():
-    class Hashable(object):
+    class Hashable:
         def __init__(self, value):
             self.value = value
 
         def __hash__(self):
             return self.value
 
-    class Unhashable(object):
+    class Unhashable:
         __hash__ = None
 
     assert m.hash_function(Hashable(42)) == 42
     with pytest.raises(TypeError):
         m.hash_function(Unhashable())
 
 
@@ -476,33 +602,28 @@
     with pytest.raises(TypeError) as excinfo:
         assert m.issue2361_dict_implicit_copy_none()
     assert "NoneType" in str(excinfo.value)
     assert "iterable" in str(excinfo.value)
 
 
 @pytest.mark.parametrize(
-    "method, args, fmt, expected_view",
+    ("method", "args", "fmt", "expected_view"),
     [
         (m.test_memoryview_object, (b"red",), "B", b"red"),
         (m.test_memoryview_buffer_info, (b"green",), "B", b"green"),
         (m.test_memoryview_from_buffer, (False,), "h", [3, 1, 4, 1, 5]),
         (m.test_memoryview_from_buffer, (True,), "H", [2, 7, 1, 8]),
         (m.test_memoryview_from_buffer_nativeformat, (), "@i", [4, 7, 5]),
     ],
 )
 def test_memoryview(method, args, fmt, expected_view):
     view = method(*args)
     assert isinstance(view, memoryview)
     assert view.format == fmt
-    if isinstance(expected_view, bytes) or not env.PY2:
-        view_as_list = list(view)
-    else:
-        # Using max to pick non-zero byte (big-endian vs little-endian).
-        view_as_list = [max(ord(c) for c in s) for s in view]
-    assert view_as_list == list(expected_view)
+    assert list(view) == list(expected_view)
 
 
 @pytest.mark.xfail("env.PYPY", reason="getrefcount is not available")
 @pytest.mark.parametrize(
     "method",
     [
         m.test_memoryview_object,
@@ -518,122 +639,133 @@
     assert list(view) == list(buf)
 
 
 def test_memoryview_from_buffer_empty_shape():
     view = m.test_memoryview_from_buffer_empty_shape()
     assert isinstance(view, memoryview)
     assert view.format == "B"
-    if env.PY2:
-        # Python 2 behavior is weird, but Python 3 (the future) is fine.
-        # PyPy3 has <memoryview, while CPython 2 has <memory
-        assert bytes(view).startswith(b"<memory")
-    else:
-        assert bytes(view) == b""
+    assert bytes(view) == b""
 
 
 def test_test_memoryview_from_buffer_invalid_strides():
     with pytest.raises(RuntimeError):
         m.test_memoryview_from_buffer_invalid_strides()
 
 
 def test_test_memoryview_from_buffer_nullptr():
-    if env.PY2:
+    with pytest.raises(ValueError):
         m.test_memoryview_from_buffer_nullptr()
-    else:
-        with pytest.raises(ValueError):
-            m.test_memoryview_from_buffer_nullptr()
 
 
-@pytest.mark.skipif("env.PY2")
 def test_memoryview_from_memory():
     view = m.test_memoryview_from_memory()
     assert isinstance(view, memoryview)
     assert view.format == "B"
     assert bytes(view) == b"\xff\xe1\xab\x37"
 
 
 def test_builtin_functions():
-    assert m.get_len([i for i in range(42)]) == 42
+    assert m.get_len(list(range(42))) == 42
     with pytest.raises(TypeError) as exc_info:
         m.get_len(i for i in range(42))
     assert str(exc_info.value) in [
         "object of type 'generator' has no len()",
         "'generator' has no length",
     ]  # PyPy
 
 
 def test_isinstance_string_types():
     assert m.isinstance_pybind11_bytes(b"")
-    assert not m.isinstance_pybind11_bytes(u"")
+    assert not m.isinstance_pybind11_bytes("")
 
-    assert m.isinstance_pybind11_str(u"")
+    assert m.isinstance_pybind11_str("")
     if hasattr(m, "PYBIND11_STR_LEGACY_PERMISSIVE"):
         assert m.isinstance_pybind11_str(b"")
     else:
         assert not m.isinstance_pybind11_str(b"")
 
 
 def test_pass_bytes_or_unicode_to_string_types():
     assert m.pass_to_pybind11_bytes(b"Bytes") == 5
     with pytest.raises(TypeError):
-        m.pass_to_pybind11_bytes(u"Str")
+        m.pass_to_pybind11_bytes("Str")
 
-    if hasattr(m, "PYBIND11_STR_LEGACY_PERMISSIVE") or env.PY2:
+    if hasattr(m, "PYBIND11_STR_LEGACY_PERMISSIVE"):
         assert m.pass_to_pybind11_str(b"Bytes") == 5
     else:
         with pytest.raises(TypeError):
             m.pass_to_pybind11_str(b"Bytes")
-    assert m.pass_to_pybind11_str(u"Str") == 3
+    assert m.pass_to_pybind11_str("Str") == 3
 
     assert m.pass_to_std_string(b"Bytes") == 5
-    assert m.pass_to_std_string(u"Str") == 3
+    assert m.pass_to_std_string("Str") == 3
 
     malformed_utf8 = b"\x80"
     if hasattr(m, "PYBIND11_STR_LEGACY_PERMISSIVE"):
         assert m.pass_to_pybind11_str(malformed_utf8) == 1
-    elif env.PY2:
-        with pytest.raises(UnicodeDecodeError):
-            m.pass_to_pybind11_str(malformed_utf8)
     else:
         with pytest.raises(TypeError):
             m.pass_to_pybind11_str(malformed_utf8)
 
 
 @pytest.mark.parametrize(
-    "create_weakref, create_weakref_with_callback",
+    ("create_weakref", "create_weakref_with_callback"),
     [
         (m.weakref_from_handle, m.weakref_from_handle_and_function),
         (m.weakref_from_object, m.weakref_from_object_and_function),
     ],
 )
 def test_weakref(create_weakref, create_weakref_with_callback):
     from weakref import getweakrefcount
 
     # Apparently, you cannot weakly reference an object()
-    class WeaklyReferenced(object):
+    class WeaklyReferenced:
         pass
 
-    def callback(wr):
-        # No `nonlocal` in Python 2
-        callback.called = True
+    callback_called = False
+
+    def callback(_):
+        nonlocal callback_called
+        callback_called = True
 
     obj = WeaklyReferenced()
     assert getweakrefcount(obj) == 0
     wr = create_weakref(obj)
     assert getweakrefcount(obj) == 1
 
     obj = WeaklyReferenced()
     assert getweakrefcount(obj) == 0
-    callback.called = False
     wr = create_weakref_with_callback(obj, callback)  # noqa: F841
     assert getweakrefcount(obj) == 1
-    assert not callback.called
+    assert not callback_called
     del obj
     pytest.gc_collect()
-    assert callback.called
+    assert callback_called
+
+
+@pytest.mark.parametrize(
+    ("create_weakref", "has_callback"),
+    [
+        (m.weakref_from_handle, False),
+        (m.weakref_from_object, False),
+        (m.weakref_from_handle_and_function, True),
+        (m.weakref_from_object_and_function, True),
+    ],
+)
+def test_weakref_err(create_weakref, has_callback):
+    class C:
+        __slots__ = []
+
+    def callback(_):
+        pass
+
+    ob = C()
+    # Should raise TypeError on CPython
+    with pytest.raises(TypeError) if not env.PYPY else contextlib.nullcontext():
+        _ = create_weakref(ob, callback) if has_callback else create_weakref(ob)
 
 
 def test_cpp_iterators():
     assert m.tuple_iterator() == 12
     assert m.dict_iterator() == 305 + 711
     assert m.passed_iterator(iter((-7, 3))) == -4
 
@@ -653,7 +785,170 @@
     assert m.list_item_get_size_t(lst) == 22
     assert m.list_item_set_size_t(lst) is None
     assert lst[4] == "richard"
     assert m.tuple_item_get_ssize_t(tup) == 29
     assert m.tuple_item_set_ssize_t() == ("emely", "edmond")
     assert m.tuple_item_get_size_t(tup) == 93
     assert m.tuple_item_set_size_t() == ("candy", "cat")
+
+
+def test_external_float_():
+    r1 = m.square_float_(2.0)
+    assert r1 == 4.0
+
+
+def test_tuple_rvalue_getter():
+    pop = 1000
+    tup = tuple(range(pop))
+    m.tuple_rvalue_getter(tup)
+
+
+def test_list_rvalue_getter():
+    pop = 1000
+    my_list = list(range(pop))
+    m.list_rvalue_getter(my_list)
+
+
+def test_populate_dict_rvalue():
+    pop = 1000
+    my_dict = {i: i for i in range(pop)}
+    assert m.populate_dict_rvalue(pop) == my_dict
+
+
+def test_populate_obj_str_attrs():
+    pop = 1000
+    o = types.SimpleNamespace(**{str(i): i for i in range(pop)})
+    new_o = m.populate_obj_str_attrs(o, pop)
+    new_attrs = {k: v for k, v in new_o.__dict__.items() if not k.startswith("_")}
+    assert all(isinstance(v, str) for v in new_attrs.values())
+    assert len(new_attrs) == pop
+
+
+@pytest.mark.parametrize(
+    ("a", "b"),
+    [("foo", "bar"), (1, 2), (1.0, 2.0), (list(range(3)), list(range(3, 6)))],
+)
+def test_inplace_append(a, b):
+    expected = a + b
+    assert m.inplace_append(a, b) == expected
+
+
+@pytest.mark.parametrize(
+    ("a", "b"), [(3, 2), (3.0, 2.0), (set(range(3)), set(range(2)))]
+)
+def test_inplace_subtract(a, b):
+    expected = a - b
+    assert m.inplace_subtract(a, b) == expected
+
+
+@pytest.mark.parametrize(("a", "b"), [(3, 2), (3.0, 2.0), ([1], 3)])
+def test_inplace_multiply(a, b):
+    expected = a * b
+    assert m.inplace_multiply(a, b) == expected
+
+
+@pytest.mark.parametrize(("a", "b"), [(6, 3), (6.0, 3.0)])
+def test_inplace_divide(a, b):
+    expected = a / b
+    assert m.inplace_divide(a, b) == expected
+
+
+@pytest.mark.parametrize(
+    ("a", "b"),
+    [
+        (False, True),
+        (
+            set(),
+            {
+                1,
+            },
+        ),
+    ],
+)
+def test_inplace_or(a, b):
+    expected = a | b
+    assert m.inplace_or(a, b) == expected
+
+
+@pytest.mark.parametrize(
+    ("a", "b"),
+    [
+        (True, False),
+        (
+            {1, 2, 3},
+            {
+                1,
+            },
+        ),
+    ],
+)
+def test_inplace_and(a, b):
+    expected = a & b
+    assert m.inplace_and(a, b) == expected
+
+
+@pytest.mark.parametrize(("a", "b"), [(8, 1), (-3, 2)])
+def test_inplace_lshift(a, b):
+    expected = a << b
+    assert m.inplace_lshift(a, b) == expected
+
+
+@pytest.mark.parametrize(("a", "b"), [(8, 1), (-2, 2)])
+def test_inplace_rshift(a, b):
+    expected = a >> b
+    assert m.inplace_rshift(a, b) == expected
+
+
+def test_tuple_nonempty_annotations(doc):
+    assert (
+        doc(m.annotate_tuple_float_str)
+        == "annotate_tuple_float_str(arg0: tuple[float, str]) -> None"
+    )
+
+
+def test_tuple_empty_annotations(doc):
+    assert (
+        doc(m.annotate_tuple_empty) == "annotate_tuple_empty(arg0: tuple[()]) -> None"
+    )
+
+
+def test_tuple_variable_length_annotations(doc):
+    assert (
+        doc(m.annotate_tuple_variable_length)
+        == "annotate_tuple_variable_length(arg0: tuple[float, ...]) -> None"
+    )
+
+
+def test_dict_annotations(doc):
+    assert (
+        doc(m.annotate_dict_str_int)
+        == "annotate_dict_str_int(arg0: dict[str, int]) -> None"
+    )
+
+
+def test_list_annotations(doc):
+    assert doc(m.annotate_list_int) == "annotate_list_int(arg0: list[int]) -> None"
+
+
+def test_set_annotations(doc):
+    assert doc(m.annotate_set_str) == "annotate_set_str(arg0: set[str]) -> None"
+
+
+def test_iterable_annotations(doc):
+    assert (
+        doc(m.annotate_iterable_str)
+        == "annotate_iterable_str(arg0: Iterable[str]) -> None"
+    )
+
+
+def test_iterator_annotations(doc):
+    assert (
+        doc(m.annotate_iterator_int)
+        == "annotate_iterator_int(arg0: Iterator[int]) -> None"
+    )
+
+
+def test_fn_annotations(doc):
+    assert (
+        doc(m.annotate_fn)
+        == "annotate_fn(arg0: Callable[[list[str], str], int]) -> None"
+    )
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_sequences_and_iterators.cpp` & `python_prtree-0.6.1/third/pybind11/tests/test_sequences_and_iterators.cpp`

 * *Files 6% similar despite different names*

```diff
@@ -24,14 +24,21 @@
 
 template <typename T>
 class NonZeroIterator {
     const T *ptr_;
 
 public:
     explicit NonZeroIterator(const T *ptr) : ptr_(ptr) {}
+
+    // Make the iterator non-copyable and movable
+    NonZeroIterator(const NonZeroIterator &) = delete;
+    NonZeroIterator(NonZeroIterator &&) noexcept = default;
+    NonZeroIterator &operator=(const NonZeroIterator &) = delete;
+    NonZeroIterator &operator=(NonZeroIterator &&) noexcept = default;
+
     const T &operator*() const { return *ptr_; }
     NonZeroIterator &operator++() {
         ++ptr_;
         return *this;
     }
 };
 
@@ -74,14 +81,15 @@
     void set(int value) { value_ = value; }
     ~NonCopyableInt() = default;
 
 private:
     int value_;
 };
 using NonCopyableIntPair = std::pair<NonCopyableInt, NonCopyableInt>;
+
 PYBIND11_MAKE_OPAQUE(std::vector<NonCopyableInt>);
 PYBIND11_MAKE_OPAQUE(std::vector<NonCopyableIntPair>);
 
 template <typename PythonType>
 py::list test_random_access_iterator(PythonType x) {
     if (x.size() < 5) {
         throw py::value_error("Please provide at least 5 elements for testing.");
@@ -371,14 +379,25 @@
         const std::pair<int, int> *begin() const { return data_.data(); }
         // .end() only required for py::make_iterator(self) overload
         const std::pair<int, int> *end() const { return data_.data() + data_.size(); }
 
     private:
         std::vector<std::pair<int, int>> data_;
     };
+
+    {
+        // #4383 : Make sure `py::make_*iterator` functions work with move-only iterators
+        using iterator_t = NonZeroIterator<std::pair<int, int>>;
+
+        static_assert(std::is_move_assignable<iterator_t>::value, "");
+        static_assert(std::is_move_constructible<iterator_t>::value, "");
+        static_assert(!std::is_copy_assignable<iterator_t>::value, "");
+        static_assert(!std::is_copy_constructible<iterator_t>::value, "");
+    }
+
     py::class_<IntPairs>(m, "IntPairs")
         .def(py::init<std::vector<std::pair<int, int>>>())
         .def(
             "nonzero",
             [](const IntPairs &s) {
                 return py::make_iterator(NonZeroIterator<std::pair<int, int>>(s.begin()),
                                          NonZeroSentinel());
@@ -555,8 +574,27 @@
     // test_iterator_rvp
     // #388: Can't make iterators via make_iterator() with different r/v policies
     static std::vector<int> list = {1, 2, 3};
     m.def("make_iterator_1",
           []() { return py::make_iterator<py::return_value_policy::copy>(list); });
     m.def("make_iterator_2",
           []() { return py::make_iterator<py::return_value_policy::automatic>(list); });
+
+    // test_iterator on c arrays
+    // #4100: ensure lvalue required as increment operand
+    class CArrayHolder {
+    public:
+        CArrayHolder(double x, double y, double z) {
+            values[0] = x;
+            values[1] = y;
+            values[2] = z;
+        };
+        double values[3];
+    };
+
+    py::class_<CArrayHolder>(m, "CArrayHolder")
+        .def(py::init<double, double, double>())
+        .def(
+            "__iter__",
+            [](const CArrayHolder &v) { return py::make_iterator(v.values, v.values + 3); },
+            py::keep_alive<0, 1>());
 }
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_sequences_and_iterators.py` & `python_prtree-0.6.1/third/pybind11/tests/test_sequences_and_iterators.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,25 +1,14 @@
-# -*- coding: utf-8 -*-
 import pytest
+from pytest import approx  # noqa: PT013
 
 from pybind11_tests import ConstructorStats
 from pybind11_tests import sequences_and_iterators as m
 
 
-def isclose(a, b, rel_tol=1e-05, abs_tol=0.0):
-    """Like math.isclose() from Python 3.5"""
-    return abs(a - b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol)
-
-
-def allclose(a_list, b_list, rel_tol=1e-05, abs_tol=0.0):
-    return all(
-        isclose(a, b, rel_tol=rel_tol, abs_tol=abs_tol) for a, b in zip(a_list, b_list)
-    )
-
-
 def test_slice_constructors():
     assert m.make_forward_slice_size_t() == slice(0, -1, 1)
     assert m.make_reversed_slice_object() == slice(None, None, -1)
 
 
 @pytest.mark.skipif(not m.has_optional, reason="no <optional>")
 def test_slice_constructors_explicit_optional():
@@ -65,14 +54,23 @@
         (3, 4),
         (0, 5),
     ]
     assert list(m.IntPairs([(1, 2), (3, 4), (0, 5)]).simple_keys()) == [1, 3, 0]
     assert list(m.IntPairs([(1, 2), (3, 4), (0, 5)]).simple_values()) == [2, 4, 5]
 
 
+def test_iterator_doc_annotations():
+    assert m.IntPairs.nonref.__doc__.endswith("-> Iterator[tuple[int, int]]\n")
+    assert m.IntPairs.nonref_keys.__doc__.endswith("-> Iterator[int]\n")
+    assert m.IntPairs.nonref_values.__doc__.endswith("-> Iterator[int]\n")
+    assert m.IntPairs.simple_iterator.__doc__.endswith("-> Iterator[tuple[int, int]]\n")
+    assert m.IntPairs.simple_keys.__doc__.endswith("-> Iterator[int]\n")
+    assert m.IntPairs.simple_values.__doc__.endswith("-> Iterator[int]\n")
+
+
 def test_iterator_referencing():
     """Test that iterators reference rather than copy their referents."""
     vec = m.VectorNonCopyableInt()
     vec.append(3)
     vec.append(5)
     assert [int(x) for x in vec] == [3, 5]
     # Increment everything to make sure the referents can be mutated
@@ -110,41 +108,43 @@
     cstats = ConstructorStats.get(m.Sequence)
 
     s = m.Sequence(5)
     assert cstats.values() == ["of size", "5"]
 
     assert "Sequence" in repr(s)
     assert len(s) == 5
-    assert s[0] == 0 and s[3] == 0
+    assert s[0] == 0
+    assert s[3] == 0
     assert 12.34 not in s
     s[0], s[3] = 12.34, 56.78
     assert 12.34 in s
-    assert isclose(s[0], 12.34) and isclose(s[3], 56.78)
+    assert s[0] == approx(12.34, rel=1e-05)
+    assert s[3] == approx(56.78, rel=1e-05)
 
     rev = reversed(s)
     assert cstats.values() == ["of size", "5"]
 
     rev2 = s[::-1]
     assert cstats.values() == ["of size", "5"]
 
     it = iter(m.Sequence(0))
     for _ in range(3):  # __next__ must continue to raise StopIteration
         with pytest.raises(StopIteration):
             next(it)
     assert cstats.values() == ["of size", "0"]
 
     expected = [0, 56.78, 0, 0, 12.34]
-    assert allclose(rev, expected)
-    assert allclose(rev2, expected)
+    assert rev == approx(expected, rel=1e-05)
+    assert rev2 == approx(expected, rel=1e-05)
     assert rev == rev2
 
     rev[0::2] = m.Sequence([2.0, 2.0, 2.0])
     assert cstats.values() == ["of size", "3", "from std::vector"]
 
-    assert allclose(rev, [2, 56.78, 2, 0, 2])
+    assert rev == approx([2, 56.78, 2, 0, 2], rel=1e-05)
 
     assert cstats.alive() == 4
     del it
     assert cstats.alive() == 3
     del s
     assert cstats.alive() == 2
     del rev
@@ -176,14 +176,18 @@
     with pytest.raises(BadLen):
         m.sequence_length(SequenceLike())
 
     assert m.sequence_length([1, 2, 3]) == 3
     assert m.sequence_length("hello") == 5
 
 
+def test_sequence_doc():
+    assert m.sequence_length.__doc__.strip() == "sequence_length(arg0: Sequence) -> int"
+
+
 def test_map_iterator():
     sm = m.StringMap({"hi": "bye", "black": "white"})
     assert sm["hi"] == "bye"
     assert len(sm) == 2
     assert sm["black"] == "white"
 
     with pytest.raises(KeyError):
@@ -247,7 +251,15 @@
 def test_iterator_rvp():
     """#388: Can't make iterators via make_iterator() with different r/v policies"""
     import pybind11_tests.sequences_and_iterators as m
 
     assert list(m.make_iterator_1()) == [1, 2, 3]
     assert list(m.make_iterator_2()) == [1, 2, 3]
     assert not isinstance(m.make_iterator_1(), type(m.make_iterator_2()))
+
+
+def test_carray_iterator():
+    """#4100: Check for proper iterator overload with C-Arrays"""
+    args_gt = [float(i) for i in range(3)]
+    arr_h = m.CArrayHolder(*args_gt)
+    args = list(arr_h)
+    assert args_gt == args
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_smart_ptr.cpp` & `python_prtree-0.6.1/third/pybind11/tests/test_smart_ptr.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -4,18 +4,14 @@
 
     Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
 
     All rights reserved. Use of this source code is governed by a
     BSD-style license that can be found in the LICENSE file.
 */
 
-#if defined(_MSC_VER) && _MSC_VER < 1910 // VS 2015's MSVC
-#    pragma warning(disable : 4702)      // unreachable code in system header (xatomic.h(382))
-#endif
-
 #include "object.h"
 #include "pybind11_tests.h"
 
 namespace {
 
 // This is just a wrapper around unique_ptr, but with extra fields to deliberately bloat up the
 // holder size to trigger the non-simple-layout internal instance layout for single inheritance
@@ -103,65 +99,68 @@
     std::string toString() const { return "MyObject3[" + std::to_string(value) + "]"; }
     virtual ~MyObject3() { print_destroyed(this); }
 
 private:
     int value;
 };
 
+template <typename T>
+std::unordered_set<T *> &pointer_set() {
+    // https://google.github.io/styleguide/cppguide.html#Static_and_Global_Variables
+    static auto singleton = new std::unordered_set<T *>();
+    return *singleton;
+}
+
 // test_unique_nodelete
 // Object with a private destructor
-class MyObject4;
-std::unordered_set<MyObject4 *> myobject4_instances;
 class MyObject4 {
 public:
     explicit MyObject4(int value) : value{value} {
         print_created(this);
-        myobject4_instances.insert(this);
+        pointer_set<MyObject4>().insert(this);
     }
     int value;
 
     static void cleanupAllInstances() {
-        auto tmp = std::move(myobject4_instances);
-        myobject4_instances.clear();
+        auto tmp = std::move(pointer_set<MyObject4>());
+        pointer_set<MyObject4>().clear();
         for (auto *o : tmp) {
             delete o;
         }
     }
 
 private:
     ~MyObject4() {
-        myobject4_instances.erase(this);
+        pointer_set<MyObject4>().erase(this);
         print_destroyed(this);
     }
 };
 
 // test_unique_deleter
 // Object with std::unique_ptr<T, D> where D is not matching the base class
 // Object with a protected destructor
-class MyObject4a;
-std::unordered_set<MyObject4a *> myobject4a_instances;
 class MyObject4a {
 public:
     explicit MyObject4a(int i) : value{i} {
         print_created(this);
-        myobject4a_instances.insert(this);
+        pointer_set<MyObject4a>().insert(this);
     };
     int value;
 
     static void cleanupAllInstances() {
-        auto tmp = std::move(myobject4a_instances);
-        myobject4a_instances.clear();
+        auto tmp = std::move(pointer_set<MyObject4a>());
+        pointer_set<MyObject4a>().clear();
         for (auto *o : tmp) {
             delete o;
         }
     }
 
 protected:
     virtual ~MyObject4a() {
-        myobject4a_instances.erase(this);
+        pointer_set<MyObject4a>().erase(this);
         print_destroyed(this);
     }
 };
 
 // Object derived but with public destructor and no Deleter in default holder
 class MyObject4b : public MyObject4a {
 public:
@@ -266,22 +265,22 @@
 
 } // namespace
 
 // ref<T> is a wrapper for 'Object' which uses intrusive reference counting
 // It is always possible to construct a ref<T> from an Object* pointer without
 // possible inconsistencies, hence the 'true' argument at the end.
 // Make pybind11 aware of the non-standard getter member function
-namespace pybind11 {
+namespace PYBIND11_NAMESPACE {
 namespace detail {
 template <typename T>
 struct holder_helper<ref<T>> {
     static const T *get(const ref<T> &p) { return p.get_ptr(); }
 };
 } // namespace detail
-} // namespace pybind11
+} // namespace PYBIND11_NAMESPACE
 
 // Make pybind aware of the ref-counted wrapper type (s):
 PYBIND11_DECLARE_HOLDER_TYPE(T, ref<T>, true);
 // The following is not required anymore for std::shared_ptr, but it should compile without error:
 PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>);
 PYBIND11_DECLARE_HOLDER_TYPE(T, huge_unique_ptr<T>);
 PYBIND11_DECLARE_HOLDER_TYPE(T, custom_unique_ptr<T>);
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_smart_ptr.py` & `python_prtree-0.6.1/third/pybind11/tests/test_smart_ptr.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 import pytest
 
 m = pytest.importorskip("pybind11_tests.smart_ptr")
 from pybind11_tests import ConstructorStats  # noqa: E402
 
 
 def test_smart_ptr(capture):
@@ -12,15 +11,15 @@
     ):
         assert o.getRefCount() == 1
         with capture:
             m.print_object_1(o)
             m.print_object_2(o)
             m.print_object_3(o)
             m.print_object_4(o)
-        assert capture == "MyObject1[{i}]\n".format(i=i) * 4
+        assert capture == f"MyObject1[{i}]\n" * 4
 
     for i, o in enumerate(
         [m.make_myobject1_1(), m.make_myobject1_2(), m.MyObject1(6), 7], start=4
     ):
         print(o)
         with capture:
             if not isinstance(o, int):
@@ -30,21 +29,19 @@
                 m.print_object_4(o)
             m.print_myobject1_1(o)
             m.print_myobject1_2(o)
             m.print_myobject1_3(o)
             m.print_myobject1_4(o)
 
         times = 4 if isinstance(o, int) else 8
-        assert capture == "MyObject1[{i}]\n".format(i=i) * times
+        assert capture == f"MyObject1[{i}]\n" * times
 
     cstats = ConstructorStats.get(m.MyObject1)
     assert cstats.alive() == 0
-    expected_values = ["MyObject1[{}]".format(i) for i in range(1, 7)] + [
-        "MyObject1[7]"
-    ] * 4
+    expected_values = [f"MyObject1[{i}]" for i in range(1, 7)] + ["MyObject1[7]"] * 4
     assert cstats.values() == expected_values
     assert cstats.default_constructions == 0
     assert cstats.copy_constructions == 0
     # assert cstats.move_constructions >= 0 # Doesn't invoke any
     assert cstats.copy_assignments == 0
     assert cstats.move_assignments == 0
 
@@ -54,15 +51,15 @@
     ):
         print(o)
         with capture:
             m.print_myobject2_1(o)
             m.print_myobject2_2(o)
             m.print_myobject2_3(o)
             m.print_myobject2_4(o)
-        assert capture == "MyObject2[{i}]\n".format(i=i) * 4
+        assert capture == f"MyObject2[{i}]\n" * 4
 
     cstats = ConstructorStats.get(m.MyObject2)
     assert cstats.alive() == 1
     o = None
     assert cstats.alive() == 0
     assert cstats.values() == ["MyObject2[8]", "MyObject2[6]", "MyObject2[7]"]
     assert cstats.default_constructions == 0
@@ -77,15 +74,15 @@
     ):
         print(o)
         with capture:
             m.print_myobject3_1(o)
             m.print_myobject3_2(o)
             m.print_myobject3_3(o)
             m.print_myobject3_4(o)
-        assert capture == "MyObject3[{i}]\n".format(i=i) * 4
+        assert capture == f"MyObject3[{i}]\n" * 4
 
     cstats = ConstructorStats.get(m.MyObject3)
     assert cstats.alive() == 1
     o = None
     assert cstats.alive() == 0
     assert cstats.values() == ["MyObject3[9]", "MyObject3[8]", "MyObject3[9]"]
     assert cstats.default_constructions == 0
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_stl.cpp` & `python_prtree-0.6.1/third/pybind11/tests/test_stl.cpp`

 * *Files 4% similar despite different names*

```diff
@@ -19,47 +19,48 @@
 
 #include <string>
 #include <vector>
 
 #if defined(PYBIND11_TEST_BOOST)
 #    include <boost/optional.hpp>
 
-namespace pybind11 {
+namespace PYBIND11_NAMESPACE {
 namespace detail {
 template <typename T>
 struct type_caster<boost::optional<T>> : optional_caster<boost::optional<T>> {};
 
 template <>
 struct type_caster<boost::none_t> : void_caster<boost::none_t> {};
 } // namespace detail
-} // namespace pybind11
+} // namespace PYBIND11_NAMESPACE
 #endif
 
 // Test with `std::variant` in C++17 mode, or with `boost::variant` in C++11/14
 #if defined(PYBIND11_HAS_VARIANT)
 using std::variant;
-#elif defined(PYBIND11_TEST_BOOST) && (!defined(_MSC_VER) || _MSC_VER >= 1910)
+#    define PYBIND11_TEST_VARIANT 1
+#elif defined(PYBIND11_TEST_BOOST)
 #    include <boost/variant.hpp>
-#    define PYBIND11_HAS_VARIANT 1
+#    define PYBIND11_TEST_VARIANT 1
 using boost::variant;
 
-namespace pybind11 {
+namespace PYBIND11_NAMESPACE {
 namespace detail {
 template <typename... Ts>
 struct type_caster<boost::variant<Ts...>> : variant_caster<boost::variant<Ts...>> {};
 
 template <>
 struct visit_helper<boost::variant> {
     template <typename... Args>
     static auto call(Args &&...args) -> decltype(boost::apply_visitor(args...)) {
         return boost::apply_visitor(args...);
     }
 };
 } // namespace detail
-} // namespace pybind11
+} // namespace PYBIND11_NAMESPACE
 #endif
 
 PYBIND11_MAKE_OPAQUE(std::vector<std::string, std::allocator<std::string>>);
 
 /// Issue #528: templated constructor
 struct TplCtorClass {
     template <typename T>
@@ -154,33 +155,39 @@
 
     explicit operator bool() const noexcept { return !storage.empty(); }
 
 private:
     std::vector<T> storage;
 };
 
-namespace pybind11 {
+namespace PYBIND11_NAMESPACE {
 namespace detail {
 template <typename T>
 struct type_caster<ReferenceSensitiveOptional<T>>
     : optional_caster<ReferenceSensitiveOptional<T>> {};
 } // namespace detail
-} // namespace pybind11
+} // namespace PYBIND11_NAMESPACE
 
 TEST_SUBMODULE(stl, m) {
     // test_vector
     m.def("cast_vector", []() { return std::vector<int>{1}; });
     m.def("load_vector", [](const std::vector<int> &v) { return v.at(0) == 1 && v.at(1) == 2; });
     // `std::vector<bool>` is special because it returns proxy objects instead of references
     m.def("cast_bool_vector", []() { return std::vector<bool>{true, false}; });
     m.def("load_bool_vector",
           [](const std::vector<bool> &v) { return v.at(0) == true && v.at(1) == false; });
     // Unnumbered regression (caused by #936): pointers to stl containers aren't castable
-    static std::vector<RValueCaster> lvv{2};
-    m.def("cast_ptr_vector", []() { return &lvv; });
+    m.def(
+        "cast_ptr_vector",
+        []() {
+            // Using no-destructor idiom to side-step warnings from overzealous compilers.
+            static auto *v = new std::vector<RValueCaster>{2};
+            return v;
+        },
+        py::return_value_policy::reference);
 
     // test_deque
     m.def("cast_deque", []() { return std::deque<int>{1}; });
     m.def("load_deque", [](const std::deque<int> &v) { return v.at(0) == 1 && v.at(1) == 2; });
 
     // test_array
     m.def("cast_array", []() { return std::array<int, 2>{{1, 2}}; });
@@ -231,14 +238,15 @@
     lvn["a"].emplace_back();        // add a list
     lvn["a"].back().emplace_back(); // add an array
     lvn["a"].emplace_back();        // another list
     lvn["a"].back().emplace_back(); // add an array
     lvn["b"].emplace_back();        // add a list
     lvn["b"].back().emplace_back(); // add an array
     lvn["b"].back().emplace_back(); // add another array
+    static std::vector<RValueCaster> lvv{2};
     m.def("cast_lv_vector", []() -> const decltype(lvv) & { return lvv; });
     m.def("cast_lv_array", []() -> const decltype(lva) & { return lva; });
     m.def("cast_lv_map", []() -> const decltype(lvm) & { return lvm; });
     m.def("cast_lv_nested", []() -> const decltype(lvn) & { return lvn; });
     // #853:
     m.def("cast_unique_ptr_vector", []() {
         std::vector<std::unique_ptr<UserType>> v;
@@ -420,38 +428,53 @@
 
 #ifdef PYBIND11_HAS_FILESYSTEM
     // test_fs_path
     m.attr("has_filesystem") = true;
     m.def("parent_path", [](const std::filesystem::path &p) { return p.parent_path(); });
 #endif
 
-#ifdef PYBIND11_HAS_VARIANT
+#ifdef PYBIND11_TEST_VARIANT
     static_assert(std::is_same<py::detail::variant_caster_visitor::result_type, py::handle>::value,
                   "visitor::result_type is required by boost::variant in C++11 mode");
 
     struct visitor {
         using result_type = const char *;
 
         result_type operator()(int) { return "int"; }
         result_type operator()(const std::string &) { return "std::string"; }
         result_type operator()(double) { return "double"; }
         result_type operator()(std::nullptr_t) { return "std::nullptr_t"; }
+#    if defined(PYBIND11_HAS_VARIANT)
+        result_type operator()(std::monostate) { return "std::monostate"; }
+#    endif
     };
 
     // test_variant
     m.def("load_variant", [](const variant<int, std::string, double, std::nullptr_t> &v) {
         return py::detail::visit_helper<variant>::call(visitor(), v);
     });
     m.def("load_variant_2pass", [](variant<double, int> v) {
         return py::detail::visit_helper<variant>::call(visitor(), v);
     });
     m.def("cast_variant", []() {
         using V = variant<int, std::string>;
         return py::make_tuple(V(5), V("Hello"));
     });
+
+#    if defined(PYBIND11_HAS_VARIANT)
+    // std::monostate tests.
+    m.def("load_monostate_variant",
+          [](const variant<std::monostate, int, std::string> &v) -> const char * {
+              return py::detail::visit_helper<variant>::call(visitor(), v);
+          });
+    m.def("cast_monostate_variant", []() {
+        using V = variant<std::monostate, int, std::string>;
+        return py::make_tuple(V{}, V(5), V("Hello"));
+    });
+#    endif
 #endif
 
     // #528: templated constructor
     // (no python tests: the test here is that this compiles)
     m.def("tpl_ctor_vector", [](std::vector<TplCtorClass> &) {});
     m.def("tpl_ctor_map", [](std::unordered_map<TplCtorClass, TplCtorClass> &) {});
     m.def("tpl_ctor_set", [](std::unordered_set<TplCtorClass> &) {});
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_stl.py` & `python_prtree-0.6.1/third/pybind11/tests/test_stl.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 import pytest
 
 from pybind11_tests import ConstructorStats, UserType
 from pybind11_tests import stl as m
 
 
 def test_vector(doc):
@@ -11,73 +10,80 @@
     assert lst == [1]
     lst.append(2)
     assert m.load_vector(lst)
     assert m.load_vector(tuple(lst))
 
     assert m.cast_bool_vector() == [True, False]
     assert m.load_bool_vector([True, False])
+    assert m.load_bool_vector((True, False))
 
-    assert doc(m.cast_vector) == "cast_vector() -> List[int]"
-    assert doc(m.load_vector) == "load_vector(arg0: List[int]) -> bool"
+    assert doc(m.cast_vector) == "cast_vector() -> list[int]"
+    assert doc(m.load_vector) == "load_vector(arg0: list[int]) -> bool"
 
     # Test regression caused by 936: pointers to stl containers weren't castable
     assert m.cast_ptr_vector() == ["lvalue", "lvalue"]
 
 
-def test_deque(doc):
+def test_deque():
     """std::deque <-> list"""
     lst = m.cast_deque()
     assert lst == [1]
     lst.append(2)
     assert m.load_deque(lst)
     assert m.load_deque(tuple(lst))
 
 
 def test_array(doc):
     """std::array <-> list"""
     lst = m.cast_array()
     assert lst == [1, 2]
     assert m.load_array(lst)
+    assert m.load_array(tuple(lst))
 
-    assert doc(m.cast_array) == "cast_array() -> List[int[2]]"
-    assert doc(m.load_array) == "load_array(arg0: List[int[2]]) -> bool"
+    assert doc(m.cast_array) == "cast_array() -> Annotated[list[int], FixedSize(2)]"
+    assert (
+        doc(m.load_array)
+        == "load_array(arg0: Annotated[list[int], FixedSize(2)]) -> bool"
+    )
 
 
 def test_valarray(doc):
     """std::valarray <-> list"""
     lst = m.cast_valarray()
     assert lst == [1, 4, 9]
     assert m.load_valarray(lst)
+    assert m.load_valarray(tuple(lst))
 
-    assert doc(m.cast_valarray) == "cast_valarray() -> List[int]"
-    assert doc(m.load_valarray) == "load_valarray(arg0: List[int]) -> bool"
+    assert doc(m.cast_valarray) == "cast_valarray() -> list[int]"
+    assert doc(m.load_valarray) == "load_valarray(arg0: list[int]) -> bool"
 
 
 def test_map(doc):
     """std::map <-> dict"""
     d = m.cast_map()
     assert d == {"key": "value"}
     assert "key" in d
     d["key2"] = "value2"
     assert "key2" in d
     assert m.load_map(d)
 
-    assert doc(m.cast_map) == "cast_map() -> Dict[str, str]"
-    assert doc(m.load_map) == "load_map(arg0: Dict[str, str]) -> bool"
+    assert doc(m.cast_map) == "cast_map() -> dict[str, str]"
+    assert doc(m.load_map) == "load_map(arg0: dict[str, str]) -> bool"
 
 
 def test_set(doc):
     """std::set <-> set"""
     s = m.cast_set()
     assert s == {"key1", "key2"}
     s.add("key3")
     assert m.load_set(s)
+    assert m.load_set(frozenset(s))
 
-    assert doc(m.cast_set) == "cast_set() -> Set[str]"
-    assert doc(m.load_set) == "load_set(arg0: Set[str]) -> bool"
+    assert doc(m.cast_set) == "cast_set() -> set[str]"
+    assert doc(m.load_set) == "load_set(arg0: set[str]) -> bool"
 
 
 def test_recursive_casting():
     """Tests that stl casters preserve lvalue/rvalue context for container values"""
     assert m.cast_rv_vector() == ["rvalue", "rvalue"]
     assert m.cast_lv_vector() == ["lvalue", "lvalue"]
     assert m.cast_rv_array() == ["rvalue", "rvalue", "rvalue"]
@@ -88,15 +94,16 @@
     assert m.cast_lv_nested() == {
         "a": [[["lvalue", "lvalue"]], [["lvalue", "lvalue"]]],
         "b": [[["lvalue", "lvalue"], ["lvalue", "lvalue"]]],
     }
 
     # Issue #853 test case:
     z = m.cast_unique_ptr_vector()
-    assert z[0].value == 7 and z[1].value == 42
+    assert z[0].value == 7
+    assert z[1].value == 42
 
 
 def test_move_out_container():
     """Properties use the `reference_internal` policy by default. If the underlying function
     returns an rvalue, the policy is automatically changed to `move` to avoid referencing
     a temporary. In case the return value is a container of user-defined types, the policy
     also needs to be applied to the elements, not just the container."""
@@ -260,14 +267,30 @@
     assert m.cast_variant() == (5, "Hello")
 
     assert (
         doc(m.load_variant) == "load_variant(arg0: Union[int, str, float, None]) -> str"
     )
 
 
+@pytest.mark.skipif(
+    not hasattr(m, "load_monostate_variant"), reason="no std::monostate"
+)
+def test_variant_monostate(doc):
+    assert m.load_monostate_variant(None) == "std::monostate"
+    assert m.load_monostate_variant(1) == "int"
+    assert m.load_monostate_variant("1") == "std::string"
+
+    assert m.cast_monostate_variant() == (None, 5, "Hello")
+
+    assert (
+        doc(m.load_monostate_variant)
+        == "load_monostate_variant(arg0: Union[None, int, str]) -> str"
+    )
+
+
 def test_vec_of_reference_wrapper():
     """#171: Can't return reference wrappers (or STL structures containing them)"""
     assert (
         str(m.return_vec_of_reference_wrapper(UserType(4)))
         == "[UserType(1), UserType(2), UserType(3), UserType(4)]"
     )
 
@@ -276,30 +299,30 @@
     """Passing nullptr or None to an STL container pointer is not expected to work"""
     with pytest.raises(TypeError) as excinfo:
         m.stl_pass_by_pointer()  # default value is `nullptr`
     assert (
         msg(excinfo.value)
         == """
         stl_pass_by_pointer(): incompatible function arguments. The following argument types are supported:
-            1. (v: List[int] = None) -> List[int]
+            1. (v: list[int] = None) -> list[int]
 
         Invoked with:
-    """  # noqa: E501 line too long
+    """
     )
 
     with pytest.raises(TypeError) as excinfo:
         m.stl_pass_by_pointer(None)
     assert (
         msg(excinfo.value)
         == """
         stl_pass_by_pointer(): incompatible function arguments. The following argument types are supported:
-            1. (v: List[int] = None) -> List[int]
+            1. (v: list[int] = None) -> list[int]
 
         Invoked with: None
-    """  # noqa: E501 line too long
+    """
     )
 
     assert m.stl_pass_by_pointer([1, 2, 3]) == [1, 2, 3]
 
 
 def test_missing_header_message():
     """Trying convert `list` to a `std::vector`, or vice versa, without including
@@ -343,15 +366,15 @@
     assert m.array_cast_sequence((1, 2, 3)) == [1, 2, 3]
 
 
 def test_issue_1561():
     """check fix for issue #1561"""
     bar = m.Issue1561Outer()
     bar.list = [m.Issue1561Inner("bar")]
-    bar.list
+    assert bar.list
     assert bar.list[0].data == "bar"
 
 
 def test_return_vector_bool_raw_ptr():
     # Add `while True:` for manual leak checking.
     v = m.return_vector_bool_raw_ptr()
     assert isinstance(v, list)
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_tagbased_polymorphic.cpp` & `python_prtree-0.6.1/third/pybind11/tests/test_tagbased_polymorphic.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -113,23 +113,23 @@
 
 std::string Animal::name_of_kind(Kind kind) {
     std::string raw_name = type_of_kind(kind)->name();
     py::detail::clean_type_id(raw_name);
     return raw_name;
 }
 
-namespace pybind11 {
+namespace PYBIND11_NAMESPACE {
 template <typename itype>
 struct polymorphic_type_hook<itype, detail::enable_if_t<std::is_base_of<Animal, itype>::value>> {
     static const void *get(const itype *src, const std::type_info *&type) {
         type = src ? Animal::type_of_kind(src->kind) : nullptr;
         return src;
     }
 };
-} // namespace pybind11
+} // namespace PYBIND11_NAMESPACE
 
 TEST_SUBMODULE(tagbased_polymorphic, m) {
     py::class_<Animal>(m, "Animal").def_readonly("name", &Animal::name);
     py::class_<Dog, Animal>(m, "Dog")
         .def(py::init<std::string>())
         .def_readwrite("sound", &Dog::sound)
         .def("bark", &Dog::bark);
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_tagbased_polymorphic.py` & `python_prtree-0.6.1/third/pybind11/tests/test_tagbased_polymorphic.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 from pybind11_tests import tagbased_polymorphic as m
 
 
 def test_downcast():
     zoo = m.create_zoo()
     assert [type(animal) for animal in zoo] == [
         m.Labrador,
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_thread.cpp` & `python_prtree-0.6.1/third/pybind11/tests/test_thread.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_thread.py` & `python_prtree-0.6.1/third/pybind11/tests/test_thread.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,29 +1,27 @@
-# -*- coding: utf-8 -*-
-
 import threading
 
 from pybind11_tests import thread as m
 
 
 class Thread(threading.Thread):
     def __init__(self, fn):
-        super(Thread, self).__init__()
+        super().__init__()
         self.fn = fn
         self.e = None
 
     def run(self):
         try:
             for i in range(10):
                 self.fn(i, i)
         except Exception as e:
             self.e = e
 
     def join(self):
-        super(Thread, self).join()
+        super().join()
         if self.e:
             raise self.e
 
 
 def test_implicit_conversion():
     a = Thread(m.test)
     b = Thread(m.test)
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_union.cpp` & `python_prtree-0.6.1/third/pybind11/tests/test_union.cpp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_virtual_functions.cpp` & `python_prtree-0.6.1/third/pybind11/tests/test_virtual_functions.cpp`

 * *Files 1% similar despite different names*

```diff
@@ -150,16 +150,15 @@
 #endif
     Movable get_movable(int a, int b) override {
         PYBIND11_OVERRIDE_PURE(Movable, NCVirt, get_movable, a, b);
     }
 };
 
 struct Base {
-    /* for some reason MSVC2015 can't compile this if the function is pure virtual */
-    virtual std::string dispatch() const { return {}; };
+    virtual std::string dispatch() const = 0;
     virtual ~Base() = default;
     Base() = default;
     Base(const Base &) = delete;
 };
 
 struct DispatchIssue : Base {
     std::string dispatch() const override {
@@ -170,15 +169,16 @@
 // An abstract adder class that uses visitor pattern to add two data
 // objects and send the result to the visitor functor
 struct AdderBase {
     struct Data {};
     using DataVisitor = std::function<void(const Data &)>;
 
     virtual void
-    operator()(const Data &first, const Data &second, const DataVisitor &visitor) const = 0;
+    operator()(const Data &first, const Data &second, const DataVisitor &visitor) const
+        = 0;
     virtual ~AdderBase() = default;
     AdderBase() = default;
     AdderBase(const AdderBase &) = delete;
 };
 
 struct Adder : AdderBase {
     void
@@ -339,17 +339,16 @@
     m.def("add3",
           [](const AdderBase::Data &first,
              const AdderBase::Data &second,
              const AdderBase::Data &third,
              const AdderBase &adder,
              const AdderBase::DataVisitor &visitor) {
               adder(first, second, [&](const AdderBase::Data &first_plus_second) {
-                  adder(first_plus_second,
-                        third,
-                        visitor); // NOLINT(readability-suspicious-call-argument)
+                  // NOLINTNEXTLINE(readability-suspicious-call-argument)
+                  adder(first_plus_second, third, visitor);
               });
           });
 
     // test_override_ref
     // #392/397: overriding reference-returning functions
     class OverrideTest {
     public:
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/test_virtual_functions.py` & `python_prtree-0.6.1/third/pybind11/tests/test_virtual_functions.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,51 +1,50 @@
-# -*- coding: utf-8 -*-
 import pytest
 
 import env  # noqa: F401
 
 m = pytest.importorskip("pybind11_tests.virtual_functions")
 from pybind11_tests import ConstructorStats  # noqa: E402
 
 
 def test_override(capture, msg):
     class ExtendedExampleVirt(m.ExampleVirt):
         def __init__(self, state):
-            super(ExtendedExampleVirt, self).__init__(state + 1)
+            super().__init__(state + 1)
             self.data = "Hello world"
 
         def run(self, value):
-            print("ExtendedExampleVirt::run(%i), calling parent.." % value)
-            return super(ExtendedExampleVirt, self).run(value + 1)
+            print(f"ExtendedExampleVirt::run({value}), calling parent..")
+            return super().run(value + 1)
 
         def run_bool(self):
             print("ExtendedExampleVirt::run_bool()")
             return False
 
         def get_string1(self):
             return "override1"
 
         def pure_virtual(self):
-            print("ExtendedExampleVirt::pure_virtual(): %s" % self.data)
+            print(f"ExtendedExampleVirt::pure_virtual(): {self.data}")
 
     class ExtendedExampleVirt2(ExtendedExampleVirt):
         def __init__(self, state):
-            super(ExtendedExampleVirt2, self).__init__(state + 1)
+            super().__init__(state + 1)
 
         def get_string2(self):
             return "override2"
 
     ex12 = m.ExampleVirt(10)
     with capture:
         assert m.runExampleVirt(ex12, 20) == 30
     assert (
         capture
         == """
         Original implementation of ExampleVirt::run(state=10, value=20, str1=default1, str2=default2)
-    """  # noqa: E501 line too long
+    """
     )
 
     with pytest.raises(RuntimeError) as excinfo:
         m.runExampleVirtVirtual(ex12)
     assert (
         msg(excinfo.value)
         == 'Tried to call pure virtual function "ExampleVirt::pure_virtual"'
@@ -55,15 +54,15 @@
     with capture:
         assert m.runExampleVirt(ex12p, 20) == 32
     assert (
         capture
         == """
         ExtendedExampleVirt::run(20), calling parent..
         Original implementation of ExampleVirt::run(state=11, value=21, str1=override1, str2=default2)
-    """  # noqa: E501 line too long
+    """
     )
     with capture:
         assert m.runExampleVirtBool(ex12p) is False
     assert capture == "ExtendedExampleVirt::run_bool()"
     with capture:
         m.runExampleVirtVirtual(ex12p)
     assert capture == "ExtendedExampleVirt::pure_virtual(): Hello world"
@@ -72,15 +71,15 @@
     with capture:
         assert m.runExampleVirt(ex12p2, 50) == 68
     assert (
         capture
         == """
         ExtendedExampleVirt::run(50), calling parent..
         Original implementation of ExampleVirt::run(state=17, value=51, str1=override1, str2=override2)
-    """  # noqa: E501 line too long
+    """
     )
 
     cstats = ConstructorStats.get(m.ExampleVirt)
     assert cstats.alive() == 3
     del ex12, ex12p, ex12p2
     assert cstats.alive() == 0
     assert cstats.values() == ["10", "11", "17"]
@@ -93,15 +92,15 @@
 
     If we just create and use an A instance directly, the trampoline initialization is
     bypassed and we only initialize an A() instead (for performance reasons).
     """
 
     class B(m.A):
         def __init__(self):
-            super(B, self).__init__()
+            super().__init__()
 
         def f(self):
             print("In python f()")
 
     # C++ version
     with capture:
         a = m.A()
@@ -133,15 +132,15 @@
     While the extra initialization and extra class layer has small virtual dispatch
     performance penalty, it also allows us to do more things with the trampoline
     class such as defining local variables and performing construction/destruction.
     """
 
     class B2(m.A2):
         def __init__(self):
-            super(B2, self).__init__()
+            super().__init__()
 
         def f(self):
             print("In python B2.f()")
 
     # No python subclass version
     with capture:
         a2 = m.A2()
@@ -189,16 +188,15 @@
 @pytest.mark.skipif(
     not hasattr(m, "NCVirt"), reason="NCVirt does not work on Intel/PGI/NVCC compilers"
 )
 def test_move_support():
     class NCVirtExt(m.NCVirt):
         def get_noncopyable(self, a, b):
             # Constructs and returns a new instance:
-            nc = m.NonCopyable(a * a, b * b)
-            return nc
+            return m.NonCopyable(a * a, b * b)
 
         def get_movable(self, a, b):
             # Return a referenced copy
             self.movable = m.Movable(a, b)
             return self.movable
 
     class NCVirtExt2(m.NCVirt):
@@ -241,40 +239,40 @@
     class PyClass1(m.DispatchIssue):
         def dispatch(self):
             return "Yay.."
 
     class PyClass2(m.DispatchIssue):
         def dispatch(self):
             with pytest.raises(RuntimeError) as excinfo:
-                super(PyClass2, self).dispatch()
+                super().dispatch()
             assert (
                 msg(excinfo.value)
                 == 'Tried to call pure virtual function "Base::dispatch"'
             )
 
             return m.dispatch_issue_go(PyClass1())
 
     b = PyClass2()
     assert m.dispatch_issue_go(b) == "Yay.."
 
 
-def test_recursive_dispatch_issue(msg):
+def test_recursive_dispatch_issue():
     """#3357: Recursive dispatch fails to find python function override"""
 
     class Data(m.Data):
         def __init__(self, value):
-            super(Data, self).__init__()
+            super().__init__()
             self.value = value
 
     class Adder(m.Adder):
         def __call__(self, first, second, visitor):
             # lambda is a workaround, which adds extra frame to the
             # current CPython thread. Removing lambda reveals the bug
             # [https://github.com/pybind/pybind11/issues/3357]
-            (lambda: visitor(Data(first.value + second.value)))()
+            (lambda: visitor(Data(first.value + second.value)))()  # noqa: PLC3002
 
     class StoreResultVisitor:
         def __init__(self):
             self.result = None
 
         def __call__(self, data):
             self.result = data.value
```

### Comparing `python_prtree-0.6.0/third/pybind11/tests/valgrind-numpy-scipy.supp` & `python_prtree-0.6.1/third/pybind11/tests/valgrind-numpy-scipy.supp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/tests/valgrind-python.supp` & `python_prtree-0.6.1/third/pybind11/tests/valgrind-python.supp`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/tools/FindCatch.cmake` & `python_prtree-0.6.1/third/pybind11/tools/FindCatch.cmake`

 * *Files 4% similar despite different names*

```diff
@@ -32,18 +32,22 @@
   endif()
 endfunction()
 
 # Download the single-header version of Catch
 function(_download_catch version destination_dir)
   message(STATUS "Downloading catch v${version}...")
   set(url https://github.com/philsquared/Catch/releases/download/v${version}/catch.hpp)
-  file(DOWNLOAD ${url} "${destination_dir}/catch.hpp" STATUS status)
+  file(
+    DOWNLOAD ${url} "${destination_dir}/catch.hpp"
+    STATUS status
+    LOG log)
   list(GET status 0 error)
   if(error)
-    message(FATAL_ERROR "Could not download ${url}")
+    string(REPLACE "\n" "\n  " log "  ${log}")
+    message(FATAL_ERROR "Could not download URL:\n" "  ${url}\n" "Log:\n" "${log}")
   endif()
   set(CATCH_INCLUDE_DIR
       "${destination_dir}"
       CACHE INTERNAL "")
 endfunction()
 
 # Look for catch locally
```

### Comparing `python_prtree-0.6.0/third/pybind11/tools/FindEigen3.cmake` & `python_prtree-0.6.1/third/pybind11/tools/FindEigen3.cmake`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/tools/FindPythonLibsNew.cmake` & `python_prtree-0.6.1/third/pybind11/tools/FindPythonLibsNew.cmake`

 * *Files 15% similar despite different names*

```diff
@@ -88,15 +88,31 @@
   if(NOT PYTHON_EXECUTABLE)
     unset(PYTHON_EXECUTABLE)
   endif()
 endif()
 
 # Use the Python interpreter to find the libs.
 if(NOT PythonLibsNew_FIND_VERSION)
-  set(PythonLibsNew_FIND_VERSION "")
+  set(PythonLibsNew_FIND_VERSION "3.6")
+endif()
+
+if(NOT CMAKE_VERSION VERSION_LESS "3.27")
+  cmake_policy(GET CMP0148 _pybind11_cmp0148)
+  if(NOT _pybind11_cmp0148)
+    message(
+      AUTHOR_WARNING
+        "Policy CMP0148 is not set: The FindPythonInterp and FindPythonLibs "
+        "modules are removed.  Run \"cmake --help-policy CMP0148\" for policy "
+        "details.  Use the cmake_policy command to set the policy and suppress "
+        "this warning, or preferably upgrade to using FindPython, either by "
+        "calling it explicitly before pybind11, or by setting "
+        "PYBIND11_FINDPYTHON ON before pybind11.")
+  endif()
+  cmake_policy(SET CMP0148 OLD)
+  unset(_pybind11_cmp0148)
 endif()
 
 find_package(PythonInterp ${PythonLibsNew_FIND_VERSION} ${_pythonlibs_required}
              ${_pythonlibs_quiet})
 
 if(NOT PYTHONINTERP_FOUND)
   set(PYTHONLIBS_FOUND FALSE)
@@ -123,18 +139,19 @@
 if USE_SYSCONFIG:
     scheme = s.get_default_scheme()
     if scheme == 'posix_local':
         # Debian's default scheme installs to /usr/local/ but we want to find headers in /usr/
         scheme = 'posix_prefix'
     print(s.get_path('platinclude', scheme))
     print(s.get_path('platlib'))
+    print(s.get_config_var('EXT_SUFFIX') or s.get_config_var('SO'))
 else:
     print(ds.get_python_inc(plat_specific=True));
     print(ds.get_python_lib(plat_specific=True));
-print(s.get_config_var('EXT_SUFFIX') or s.get_config_var('SO'));
+    print(ds.get_config_var('EXT_SUFFIX') or ds.get_config_var('SO'));
 print(hasattr(sys, 'gettotalrefcount')+0);
 print(struct.calcsize('@P'));
 print(s.get_config_var('LDVERSION') or s.get_config_var('VERSION'));
 print(s.get_config_var('LIBDIR') or '');
 print(s.get_config_var('MULTIARCH') or '');
 "
   RESULT_VARIABLE _PYTHON_SUCCESS
@@ -146,34 +163,55 @@
     message(FATAL_ERROR "Python config failure:\n${_PYTHON_ERROR_VALUE}")
   endif()
   set(PYTHONLIBS_FOUND FALSE)
   set(PythonLibsNew_FOUND FALSE)
   return()
 endif()
 
+option(
+  PYBIND11_PYTHONLIBS_OVERWRITE
+  "Overwrite cached values read from Python library (classic search). Turn off if cross-compiling and manually setting these values."
+  ON)
+# Can manually set values when cross-compiling
+macro(_PYBIND11_GET_IF_UNDEF lst index name)
+  if(PYBIND11_PYTHONLIBS_OVERWRITE OR NOT DEFINED "${name}")
+    list(GET "${lst}" "${index}" "${name}")
+  endif()
+endmacro()
+
 # Convert the process output into a list
 if(WIN32)
   string(REGEX REPLACE "\\\\" "/" _PYTHON_VALUES ${_PYTHON_VALUES})
 endif()
 string(REGEX REPLACE ";" "\\\\;" _PYTHON_VALUES ${_PYTHON_VALUES})
 string(REGEX REPLACE "\n" ";" _PYTHON_VALUES ${_PYTHON_VALUES})
-list(GET _PYTHON_VALUES 0 _PYTHON_VERSION_LIST)
-list(GET _PYTHON_VALUES 1 PYTHON_PREFIX)
-list(GET _PYTHON_VALUES 2 PYTHON_INCLUDE_DIR)
-list(GET _PYTHON_VALUES 3 PYTHON_SITE_PACKAGES)
-list(GET _PYTHON_VALUES 4 PYTHON_MODULE_EXTENSION)
-list(GET _PYTHON_VALUES 5 PYTHON_IS_DEBUG)
-list(GET _PYTHON_VALUES 6 PYTHON_SIZEOF_VOID_P)
-list(GET _PYTHON_VALUES 7 PYTHON_LIBRARY_SUFFIX)
-list(GET _PYTHON_VALUES 8 PYTHON_LIBDIR)
-list(GET _PYTHON_VALUES 9 PYTHON_MULTIARCH)
+_pybind11_get_if_undef(_PYTHON_VALUES 0 _PYTHON_VERSION_LIST)
+_pybind11_get_if_undef(_PYTHON_VALUES 1 PYTHON_PREFIX)
+_pybind11_get_if_undef(_PYTHON_VALUES 2 PYTHON_INCLUDE_DIR)
+_pybind11_get_if_undef(_PYTHON_VALUES 3 PYTHON_SITE_PACKAGES)
+_pybind11_get_if_undef(_PYTHON_VALUES 5 PYTHON_IS_DEBUG)
+_pybind11_get_if_undef(_PYTHON_VALUES 6 PYTHON_SIZEOF_VOID_P)
+_pybind11_get_if_undef(_PYTHON_VALUES 7 PYTHON_LIBRARY_SUFFIX)
+_pybind11_get_if_undef(_PYTHON_VALUES 8 PYTHON_LIBDIR)
+_pybind11_get_if_undef(_PYTHON_VALUES 9 PYTHON_MULTIARCH)
+
+list(GET _PYTHON_VALUES 4 _PYTHON_MODULE_EXT_SUFFIX)
+if(PYBIND11_PYTHONLIBS_OVERWRITE OR NOT DEFINED PYTHON_MODULE_DEBUG_POSTFIX)
+  get_filename_component(PYTHON_MODULE_DEBUG_POSTFIX "${_PYTHON_MODULE_EXT_SUFFIX}" NAME_WE)
+endif()
+if(PYBIND11_PYTHONLIBS_OVERWRITE OR NOT DEFINED PYTHON_MODULE_EXTENSION)
+  get_filename_component(PYTHON_MODULE_EXTENSION "${_PYTHON_MODULE_EXT_SUFFIX}" EXT)
+endif()
 
 # Make sure the Python has the same pointer-size as the chosen compiler
 # Skip if CMAKE_SIZEOF_VOID_P is not defined
-if(CMAKE_SIZEOF_VOID_P AND (NOT "${PYTHON_SIZEOF_VOID_P}" STREQUAL "${CMAKE_SIZEOF_VOID_P}"))
+# This should be skipped for (non-Apple) cross-compiles (like EMSCRIPTEN)
+if(NOT CMAKE_CROSSCOMPILING
+   AND CMAKE_SIZEOF_VOID_P
+   AND (NOT "${PYTHON_SIZEOF_VOID_P}" STREQUAL "${CMAKE_SIZEOF_VOID_P}"))
   if(PythonLibsNew_FIND_REQUIRED)
     math(EXPR _PYTHON_BITS "${PYTHON_SIZEOF_VOID_P} * 8")
     math(EXPR _CMAKE_BITS "${CMAKE_SIZEOF_VOID_P} * 8")
     message(FATAL_ERROR "Python config failure: Python is ${_PYTHON_BITS}-bit, "
                         "chosen compiler is  ${_CMAKE_BITS}-bit")
   endif()
   set(PYTHONLIBS_FOUND FALSE)
@@ -189,15 +227,17 @@
 set(PYTHON_VERSION "${PYTHON_VERSION_MAJOR}.${PYTHON_VERSION_MINOR}.${PYTHON_VERSION_PATCH}")
 
 # Make sure all directory separators are '/'
 string(REGEX REPLACE "\\\\" "/" PYTHON_PREFIX "${PYTHON_PREFIX}")
 string(REGEX REPLACE "\\\\" "/" PYTHON_INCLUDE_DIR "${PYTHON_INCLUDE_DIR}")
 string(REGEX REPLACE "\\\\" "/" PYTHON_SITE_PACKAGES "${PYTHON_SITE_PACKAGES}")
 
-if(CMAKE_HOST_WIN32)
+if(DEFINED PYTHON_LIBRARY)
+  # Don't write to PYTHON_LIBRARY if it's already set
+elseif(CMAKE_HOST_WIN32)
   set(PYTHON_LIBRARY "${PYTHON_PREFIX}/libs/python${PYTHON_LIBRARY_SUFFIX}.lib")
 
   # when run in a venv, PYTHON_PREFIX points to it. But the libraries remain in the
   # original python installation. They may be found relative to PYTHON_INCLUDE_DIR.
   if(NOT EXISTS "${PYTHON_LIBRARY}")
     get_filename_component(_PYTHON_ROOT ${PYTHON_INCLUDE_DIR} DIRECTORY)
     set(PYTHON_LIBRARY "${_PYTHON_ROOT}/libs/python${PYTHON_LIBRARY_SUFFIX}.lib")
@@ -255,15 +295,15 @@
 set(PYTHON_INCLUDE_DIRS "${PYTHON_INCLUDE_DIR}")
 set(PYTHON_LIBRARIES "${PYTHON_LIBRARY}")
 if(NOT PYTHON_DEBUG_LIBRARY)
   set(PYTHON_DEBUG_LIBRARY "")
 endif()
 set(PYTHON_DEBUG_LIBRARIES "${PYTHON_DEBUG_LIBRARY}")
 
-find_package_message(PYTHON "Found PythonLibs: ${PYTHON_LIBRARY}"
+find_package_message(PYTHON "Found PythonLibs: ${PYTHON_LIBRARIES}"
                      "${PYTHON_EXECUTABLE}${PYTHON_VERSION_STRING}")
 
 set(PYTHONLIBS_FOUND TRUE)
 set(PythonLibsNew_FOUND TRUE)
 
 if(NOT PYTHON_MODULE_PREFIX)
   set(PYTHON_MODULE_PREFIX "")
```

### Comparing `python_prtree-0.6.0/third/pybind11/tools/check-style.sh` & `python_prtree-0.6.1/third/pybind11/tools/check-style.sh`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/tools/cmake_uninstall.cmake.in` & `python_prtree-0.6.1/third/pybind11/tools/cmake_uninstall.cmake.in`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/pybind11/tools/make_changelog.py` & `python_prtree-0.6.1/third/pybind11/tools/make_changelog.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 #!/usr/bin/env python3
-# -*- coding: utf-8 -*-
+from __future__ import annotations
 
 import re
 
 import ghapi.all
 from rich import print
 from rich.syntax import Syntax
 
@@ -26,31 +26,57 @@
 api = ghapi.all.GhApi(owner="pybind", repo="pybind11")
 
 issues_pages = ghapi.page.paged(
     api.issues.list_for_repo, labels="needs changelog", state="closed"
 )
 issues = (issue for page in issues_pages for issue in page)
 missing = []
+cats_descr = {
+    "feat": "New Features",
+    "fix": "Bug fixes",
+    "fix(types)": "",
+    "fix(cmake)": "",
+    "docs": "Documentation",
+    "tests": "Tests",
+    "ci": "CI",
+    "chore": "Other",
+    "unknown": "Uncategorised",
+}
+cats: dict[str, list[str]] = {c: [] for c in cats_descr}
 
 for issue in issues:
-    changelog = ENTRY.findall(issue.body)
-    if changelog:
+    changelog = ENTRY.findall(issue.body or "")
+    if not changelog or not changelog[0]:
+        missing.append(issue)
+    else:
         (msg,) = changelog
+        if msg.startswith("- "):
+            msg = msg[2:]
         if not msg.startswith("* "):
             msg = "* " + msg
         if not msg.endswith("."):
             msg += "."
 
         msg += f"\n  `#{issue.number} <{issue.html_url}>`_"
-
-        print(Syntax(msg, "rst", theme="ansi_light", word_wrap=True))
+        for cat in cats:
+            if issue.title.lower().startswith(f"{cat}:"):
+                cats[cat].append(msg)
+                break
+        else:
+            cats["unknown"].append(msg)
+
+for cat, msgs in cats.items():
+    if msgs:
+        desc = cats_descr[cat]
+        print(f"[bold]{desc}:" if desc else f".. {cat}")
+        print()
+        for msg in msgs:
+            print(Syntax(msg, "rst", theme="ansi_light", word_wrap=True))
+            print()
         print()
-
-    else:
-        missing.append(issue)
 
 if missing:
     print()
     print("[blue]" + "-" * 30)
     print()
 
     for issue in missing:
```

### Comparing `python_prtree-0.6.0/third/pybind11/tools/pybind11Common.cmake` & `python_prtree-0.6.1/third/pybind11/tools/pybind11Common.cmake`

 * *Files 4% similar despite different names*

```diff
@@ -1,31 +1,30 @@
 #[======================================================[.rst
 
 Adds the following targets::
 
     pybind11::pybind11 - link to headers and pybind11
     pybind11::module - Adds module links
     pybind11::embed - Adds embed links
-    pybind11::lto - Link time optimizations (manual selection)
-    pybind11::thin_lto - Link time optimizations (manual selection)
+    pybind11::lto - Link time optimizations (only if CMAKE_INTERPROCEDURAL_OPTIMIZATION is not set)
+    pybind11::thin_lto - Link time optimizations (only if CMAKE_INTERPROCEDURAL_OPTIMIZATION is not set)
     pybind11::python_link_helper - Adds link to Python libraries
-    pybind11::python2_no_register - Avoid warning/error with Python 2 + C++14/7
     pybind11::windows_extras - MSVC bigobj and mp for building multithreaded
     pybind11::opt_size - avoid optimizations that increase code size
 
 Adds the following functions::
 
     pybind11_strip(target) - strip target after building on linux/macOS
     pybind11_find_import(module) - See if a module is installed.
 
 #]======================================================]
 
 # CMake 3.10 has an include_guard command, but we can't use that yet
 # include_guard(global) (pre-CMake 3.10)
-if(TARGET pybind11::lto)
+if(TARGET pybind11::pybind11)
   return()
 endif()
 
 # If we are in subdirectory mode, all IMPORTED targets must be GLOBAL. If we
 # are in CONFIG mode, they should be "normal" targets instead.
 # In CMake 3.11+ you can promote a target to global after you create it,
 # which might be simpler than this check.
@@ -62,39 +61,14 @@
 # Build an embed library target:
 add_library(pybind11::embed IMPORTED INTERFACE ${optional_global})
 set_property(
   TARGET pybind11::embed
   APPEND
   PROPERTY INTERFACE_LINK_LIBRARIES pybind11::pybind11)
 
-# ----------------------- no register ----------------------
-
-# Workaround for Python 2.7 and C++17 (C++14 as a warning) incompatibility
-# This adds the flags -Wno-register and -Wno-deprecated-register if the compiler
-# is Clang 3.9+ or AppleClang and the compile language is CXX, or /wd5033 for MSVC (all languages,
-# since MSVC didn't recognize COMPILE_LANGUAGE until CMake 3.11+).
-
-add_library(pybind11::python2_no_register INTERFACE IMPORTED ${optional_global})
-set(clang_4plus
-    "$<AND:$<CXX_COMPILER_ID:Clang>,$<NOT:$<VERSION_LESS:$<CXX_COMPILER_VERSION>,3.9>>>")
-set(no_register "$<OR:${clang_4plus},$<CXX_COMPILER_ID:AppleClang>>")
-
-if(MSVC AND CMAKE_VERSION VERSION_LESS 3.11)
-  set(cxx_no_register "${no_register}")
-else()
-  set(cxx_no_register "$<AND:$<COMPILE_LANGUAGE:CXX>,${no_register}>")
-endif()
-
-set(msvc "$<CXX_COMPILER_ID:MSVC>")
-
-set_property(
-  TARGET pybind11::python2_no_register
-  PROPERTY INTERFACE_COMPILE_OPTIONS
-           "$<${cxx_no_register}:-Wno-register;-Wno-deprecated-register>" "$<${msvc}:/wd5033>")
-
 # --------------------------- link helper ---------------------------
 
 add_library(pybind11::python_link_helper IMPORTED INTERFACE ${optional_global})
 
 if(CMAKE_VERSION VERSION_LESS 3.13)
   # In CMake 3.11+, you can set INTERFACE properties via the normal methods, and
   # this would be simpler.
@@ -118,15 +92,15 @@
 
 if(MSVC) # That's also clang-cl
   # /bigobj is needed for bigger binding projects due to the limit to 64k
   # addressable sections
   set_property(
     TARGET pybind11::windows_extras
     APPEND
-    PROPERTY INTERFACE_COMPILE_OPTIONS /bigobj)
+    PROPERTY INTERFACE_COMPILE_OPTIONS $<$<COMPILE_LANGUAGE:CXX>:/bigobj>)
 
   # /MP enables multithreaded builds (relevant when there are many files) for MSVC
   if("${CMAKE_CXX_COMPILER_ID}" STREQUAL "MSVC") # no Clang no Intel
     if(CMAKE_VERSION VERSION_LESS 3.11)
       set_property(
         TARGET pybind11::windows_extras
         APPEND
@@ -185,22 +159,34 @@
                           "(last two chars: ${VAL} not understood as a valid CXX std)")
     endif()
   endif()
 endif()
 
 # --------------------- Python specifics -------------------------
 
+# CMake 3.27 removes the classic FindPythonInterp if CMP0148 is NEW
+if(CMAKE_VERSION VERSION_LESS "3.27")
+  set(_pybind11_missing_old_python "OLD")
+else()
+  cmake_policy(GET CMP0148 _pybind11_missing_old_python)
+endif()
+
 # Check to see which Python mode we are in, new, old, or no python
 if(PYBIND11_NOPYTHON)
   set(_pybind11_nopython ON)
+  # We won't use new FindPython if PYBIND11_FINDPYTHON is defined and falselike
+  # Otherwise, we use if FindPythonLibs is missing or if FindPython was already used
 elseif(
-  PYBIND11_FINDPYTHON
-  OR Python_FOUND
-  OR Python2_FOUND
-  OR Python3_FOUND)
+  (NOT DEFINED PYBIND11_FINDPYTHON OR PYBIND11_FINDPYTHON)
+  AND (_pybind11_missing_old_python STREQUAL "NEW"
+       OR PYBIND11_FINDPYTHON
+       OR Python_FOUND
+       OR Python3_FOUND
+      ))
+
   # New mode
   include("${CMAKE_CURRENT_LIST_DIR}/pybind11NewTools.cmake")
 
 else()
 
   # Classic mode
   include("${CMAKE_CURRENT_LIST_DIR}/pybind11Tools.cmake")
@@ -232,16 +218,23 @@
       set(status_level FATAL_ERROR)
     else()
       set(status_level WARNING)
     endif()
 
     execute_process(
       COMMAND
-        ${${_Python}_EXECUTABLE} -c
-        "from pkg_resources import get_distribution; print(get_distribution('${PYPI_NAME}').version)"
+        ${${_Python}_EXECUTABLE} -c "
+try:
+    from importlib.metadata import version
+except ImportError:
+    from pkg_resources import get_distribution
+    def version(s):
+        return get_distribution(s).version
+print(version('${PYPI_NAME}'))
+        "
       RESULT_VARIABLE RESULT_PRESENT
       OUTPUT_VARIABLE PKG_VERSION
       ERROR_QUIET)
 
     string(STRIP "${PKG_VERSION}" PKG_VERSION)
 
     # If a result is present, this failed
@@ -314,33 +307,46 @@
     if(CMAKE_CXX_COMPILER_ID MATCHES "Clang" AND NOT APPLE)
       # Clang Gold plugin does not support -Os; append -O3 to MinSizeRel builds to override it
       set(linker_append ";$<$<CONFIG:MinSizeRel>:-O3>")
     elseif(CMAKE_CXX_COMPILER_ID MATCHES "GNU" AND NOT MINGW)
       set(cxx_append ";-fno-fat-lto-objects")
     endif()
 
-    if(CMAKE_SYSTEM_PROCESSOR MATCHES "ppc64le" OR CMAKE_SYSTEM_PROCESSOR MATCHES "mips64")
-      set(NO_FLTO_ARCH TRUE)
+    if(prefer_thin_lto)
+      set(thin "=thin")
     else()
-      set(NO_FLTO_ARCH FALSE)
+      set(thin "")
     endif()
 
-    if(CMAKE_CXX_COMPILER_ID MATCHES "Clang"
-       AND prefer_thin_lto
-       AND NOT NO_FLTO_ARCH)
+    if(CMAKE_SYSTEM_PROCESSOR MATCHES "ppc64le" OR CMAKE_SYSTEM_PROCESSOR MATCHES "mips64")
+      # Do nothing
+    elseif(CMAKE_SYSTEM_PROCESSOR MATCHES emscripten)
+      # This compile is very costly when cross-compiling, so set this without checking
+      set(PYBIND11_LTO_CXX_FLAGS "-flto${thin}${cxx_append}")
+      set(PYBIND11_LTO_LINKER_FLAGS "-flto${thin}${linker_append}")
+    elseif(CMAKE_CXX_COMPILER_ID MATCHES "Clang")
       _pybind11_return_if_cxx_and_linker_flags_work(
-        HAS_FLTO_THIN "-flto=thin${cxx_append}" "-flto=thin${linker_append}"
+        HAS_FLTO_THIN "-flto${thin}${cxx_append}" "-flto=${thin}${linker_append}"
         PYBIND11_LTO_CXX_FLAGS PYBIND11_LTO_LINKER_FLAGS)
     endif()
-
-    if(NOT HAS_FLTO_THIN AND NOT NO_FLTO_ARCH)
+    if(NOT HAS_FLTO_THIN)
       _pybind11_return_if_cxx_and_linker_flags_work(
         HAS_FLTO "-flto${cxx_append}" "-flto${linker_append}" PYBIND11_LTO_CXX_FLAGS
         PYBIND11_LTO_LINKER_FLAGS)
     endif()
+  elseif(CMAKE_CXX_COMPILER_ID MATCHES "IntelLLVM")
+    # IntelLLVM equivalent to LTO is called IPO; also IntelLLVM is WIN32/UNIX
+    # WARNING/HELP WANTED: This block of code is currently not covered by pybind11 GitHub Actions!
+    if(WIN32)
+      _pybind11_return_if_cxx_and_linker_flags_work(
+        HAS_INTEL_IPO "-Qipo" "-Qipo" PYBIND11_LTO_CXX_FLAGS PYBIND11_LTO_LINKER_FLAGS)
+    else()
+      _pybind11_return_if_cxx_and_linker_flags_work(
+        HAS_INTEL_IPO "-ipo" "-ipo" PYBIND11_LTO_CXX_FLAGS PYBIND11_LTO_LINKER_FLAGS)
+    endif()
   elseif(CMAKE_CXX_COMPILER_ID MATCHES "Intel")
     # Intel equivalent to LTO is called IPO
     _pybind11_return_if_cxx_and_linker_flags_work(HAS_INTEL_IPO "-ipo" "-ipo"
                                                   PYBIND11_LTO_CXX_FLAGS PYBIND11_LTO_LINKER_FLAGS)
   elseif(MSVC)
     # cmake only interprets libraries as linker flags when they start with a - (otherwise it
     # converts /LTCG to \LTCG as if it was a Windows path).  Luckily MSVC supports passing flags
@@ -384,19 +390,21 @@
         TARGET ${target}
         APPEND
         PROPERTY INTERFACE_LINK_OPTIONS "$<${not_debug}:${PYBIND11_LTO_LINKER_FLAGS}>")
     endif()
   endif()
 endfunction()
 
-add_library(pybind11::lto IMPORTED INTERFACE ${optional_global})
-_pybind11_generate_lto(pybind11::lto FALSE)
+if(NOT DEFINED CMAKE_INTERPROCEDURAL_OPTIMIZATION)
+  add_library(pybind11::lto IMPORTED INTERFACE ${optional_global})
+  _pybind11_generate_lto(pybind11::lto FALSE)
 
-add_library(pybind11::thin_lto IMPORTED INTERFACE ${optional_global})
-_pybind11_generate_lto(pybind11::thin_lto TRUE)
+  add_library(pybind11::thin_lto IMPORTED INTERFACE ${optional_global})
+  _pybind11_generate_lto(pybind11::thin_lto TRUE)
+endif()
 
 # ---------------------- pybind11_strip -----------------------------
 
 function(pybind11_strip target_name)
   # Strip unnecessary sections of the binary on Linux/macOS
   if(CMAKE_STRIP)
     if(APPLE)
```

### Comparing `python_prtree-0.6.0/third/pybind11/tools/pybind11Config.cmake.in` & `python_prtree-0.6.1/third/pybind11/tools/pybind11Config.cmake.in`

 * *Files 3% similar despite different names*

```diff
@@ -47,29 +47,29 @@
 
 ``pybind11::headers``
   Just the pybind11 headers and minimum compile requirements.
 ``pybind11::pybind11``
   Python headers too.
 ``pybind11::python_link_helper``
   Just the "linking" part of ``pybind11:module``, for CMake < 3.15.
-``pybind11::python2_no_register``
-  Quiets the warning/error when mixing C++14+ and Python 2, also included in ``pybind11::module``.
 ``pybind11::thin_lto``
   An alternative to ``INTERPROCEDURAL_OPTIMIZATION``.
 ``pybind11::lto``
   An alternative to ``INTERPROCEDURAL_OPTIMIZATION`` (also avoids thin LTO on clang).
 ``pybind11::windows_extras``
   Adds bigobj and mp for MSVC.
 
 Modes
 =====
 
 There are two modes provided; classic, which is built on the old Python
 discovery packages in CMake, or the new FindPython mode, which uses FindPython
-from 3.12+ forward (3.15+ _highly_ recommended).
+from 3.12+ forward (3.15+ _highly_ recommended). If you set the minimum or
+maximum version of CMake to 3.27+, then FindPython is the default (since
+FindPythonInterp/FindPythonLibs has been removed via policy `CMP0148`).
 
 New FindPython mode
 ^^^^^^^^^^^^^^^^^^^
 
 To activate this mode, either call ``find_package(Python COMPONENTS Interpreter Development)``
 before finding this package, or set the ``PYBIND11_FINDPYTHON`` variable to ON. In this mode,
 you can either use the basic targets, or use the FindPython tools:
@@ -145,15 +145,15 @@
 
 Add a module and setup all helpers. You can select the type of the library; the
 default is ``MODULE``. There are several options:
 
 ``OPT_SIZE``
   Optimize for size, even if the ``CMAKE_BUILD_TYPE`` is not ``MinSizeRel``.
 ``THIN_LTO``
-  Use thin TLO instead of regular if there's a choice (pybind11's selection
+  Use thin LTO instead of regular if there's a choice (pybind11's selection
   is disabled if ``CMAKE_INTERPROCEDURAL_OPTIMIZATIONS`` is set).
 ``WITHOUT_SOABI``
   Disable the SOABI component (``PYBIND11_NEWPYTHON`` mode only).
 ``NO_EXTRAS``
   Disable all extras, exit immediately after making the module.
 
 pybind11_strip
@@ -191,15 +191,15 @@
 ===============
 
 Using ``find_package`` with version info is not recommended except for release versions.
 
 .. code-block:: cmake
 
   find_package(pybind11 CONFIG)
-  find_package(pybind11 2.0 EXACT CONFIG REQUIRED)
+  find_package(pybind11 2.9 EXACT CONFIG REQUIRED)
 
 #]=============================================================================]
 @PACKAGE_INIT@
 
 # Location of pybind11/pybind11.h
 # This will be relative unless explicitly set as absolute
 set(pybind11_INCLUDE_DIR "@pybind11_INCLUDEDIR@")
```

### Comparing `python_prtree-0.6.0/third/pybind11/tools/pybind11NewTools.cmake` & `python_prtree-0.6.1/third/pybind11/tools/pybind11NewTools.cmake`

 * *Files 13% similar despite different names*

```diff
@@ -5,69 +5,95 @@
 # All rights reserved. Use of this source code is governed by a
 # BSD-style license that can be found in the LICENSE file.
 
 if(CMAKE_VERSION VERSION_LESS 3.12)
   message(FATAL_ERROR "You cannot use the new FindPython module with CMake < 3.12")
 endif()
 
-include_guard(GLOBAL)
+include_guard(DIRECTORY)
 
 get_property(
   is_config
   TARGET pybind11::headers
   PROPERTY IMPORTED)
 
 if(pybind11_FIND_QUIETLY)
   set(_pybind11_quiet QUIET)
 else()
   set(_pybind11_quiet "")
 endif()
 
-if(NOT Python_FOUND
-   AND NOT Python3_FOUND
-   AND NOT Python2_FOUND)
+if(NOT Python_FOUND AND NOT Python3_FOUND)
   if(NOT DEFINED Python_FIND_IMPLEMENTATIONS)
     set(Python_FIND_IMPLEMENTATIONS CPython PyPy)
   endif()
 
   # GitHub Actions like activation
   if(NOT DEFINED Python_ROOT_DIR AND DEFINED ENV{pythonLocation})
     set(Python_ROOT_DIR "$ENV{pythonLocation}")
   endif()
 
-  find_package(Python REQUIRED COMPONENTS Interpreter Development ${_pybind11_quiet})
+  # Development.Module support (required for manylinux) started in 3.18
+  if(CMAKE_VERSION VERSION_LESS 3.18)
+    set(_pybind11_dev_component Development)
+  else()
+    set(_pybind11_dev_component Development.Module OPTIONAL_COMPONENTS Development.Embed)
+  endif()
+
+  # Callers need to be able to access Python_EXECUTABLE
+  set(_pybind11_global_keyword "")
+  if(NOT is_config AND NOT DEFINED Python_ARTIFACTS_INTERACTIVE)
+    set(Python_ARTIFACTS_INTERACTIVE TRUE)
+    if(NOT CMAKE_VERSION VERSION_LESS 3.24)
+      set(_pybind11_global_keyword "GLOBAL")
+    endif()
+  endif()
+
+  find_package(Python 3.6 REQUIRED COMPONENTS Interpreter ${_pybind11_dev_component}
+                                              ${_pybind11_quiet} ${_pybind11_global_keyword})
 
   # If we are in submodule mode, export the Python targets to global targets.
   # If this behavior is not desired, FindPython _before_ pybind11.
-  if(NOT is_config)
-    set_property(TARGET Python::Python PROPERTY IMPORTED_GLOBAL TRUE)
+  if(NOT is_config
+     AND Python_ARTIFACTS_INTERACTIVE
+     AND _pybind11_global_keyword STREQUAL "")
+    if(TARGET Python::Python)
+      set_property(TARGET Python::Python PROPERTY IMPORTED_GLOBAL TRUE)
+    endif()
     set_property(TARGET Python::Interpreter PROPERTY IMPORTED_GLOBAL TRUE)
     if(TARGET Python::Module)
       set_property(TARGET Python::Module PROPERTY IMPORTED_GLOBAL TRUE)
     endif()
   endif()
+
+  # Explicitly export version for callers (including our own functions)
+  if(NOT is_config AND Python_ARTIFACTS_INTERACTIVE)
+    set(Python_VERSION
+        "${Python_VERSION}"
+        CACHE INTERNAL "")
+    set(Python_VERSION_MAJOR
+        "${Python_VERSION_MAJOR}"
+        CACHE INTERNAL "")
+    set(Python_VERSION_MINOR
+        "${Python_VERSION_MINOR}"
+        CACHE INTERNAL "")
+    set(Python_VERSION_PATCH
+        "${Python_VERSION_PATCH}"
+        CACHE INTERNAL "")
+  endif()
 endif()
 
 if(Python_FOUND)
   set(_Python
       Python
       CACHE INTERNAL "" FORCE)
-elseif(Python3_FOUND AND NOT Python2_FOUND)
+elseif(Python3_FOUND)
   set(_Python
       Python3
       CACHE INTERNAL "" FORCE)
-elseif(Python2_FOUND AND NOT Python3_FOUND)
-  set(_Python
-      Python2
-      CACHE INTERNAL "" FORCE)
-else()
-  message(AUTHOR_WARNING "Python2 and Python3 both present, pybind11 in "
-                         "PYBIND11_NOPYTHON mode (manually activate to silence warning)")
-  set(_pybind11_nopython ON)
-  return()
 endif()
 
 if(PYBIND11_MASTER_PROJECT)
   if(${_Python}_INTERPRETER_ID MATCHES "PyPy")
     message(STATUS "PyPy ${${_Python}_PyPy_VERSION} (Py ${${_Python}_VERSION})")
   else()
     message(STATUS "${_Python} ${${_Python}_VERSION}")
@@ -80,68 +106,81 @@
 if(NOT DEFINED ${_Python}_EXECUTABLE)
   message(
     FATAL_ERROR
       "${_Python} was found without the Interpreter component. Pybind11 requires this component.")
 
 endif()
 
-if(NOT ${_Python}_EXECUTABLE STREQUAL PYBIND11_PYTHON_EXECUTABLE_LAST)
+if(DEFINED PYBIND11_PYTHON_EXECUTABLE_LAST AND NOT ${_Python}_EXECUTABLE STREQUAL
+                                               PYBIND11_PYTHON_EXECUTABLE_LAST)
   # Detect changes to the Python version/binary in subsequent CMake runs, and refresh config if needed
   unset(PYTHON_IS_DEBUG CACHE)
   unset(PYTHON_MODULE_EXTENSION CACHE)
-  set(PYBIND11_PYTHON_EXECUTABLE_LAST
-      "${${_Python}_EXECUTABLE}"
-      CACHE INTERNAL "Python executable during the last CMake run")
 endif()
 
+set(PYBIND11_PYTHON_EXECUTABLE_LAST
+    "${${_Python}_EXECUTABLE}"
+    CACHE INTERNAL "Python executable during the last CMake run")
+
 if(NOT DEFINED PYTHON_IS_DEBUG)
   # Debug check - see https://stackoverflow.com/questions/646518/python-how-to-detect-debug-Interpreter
   execute_process(
     COMMAND "${${_Python}_EXECUTABLE}" "-c"
             "import sys; sys.exit(hasattr(sys, 'gettotalrefcount'))"
     RESULT_VARIABLE _PYTHON_IS_DEBUG)
   set(PYTHON_IS_DEBUG
       "${_PYTHON_IS_DEBUG}"
       CACHE INTERNAL "Python debug status")
 endif()
 
 # Get the suffix - SO is deprecated, should use EXT_SUFFIX, but this is
 # required for PyPy3 (as of 7.3.1)
-if(NOT DEFINED PYTHON_MODULE_EXTENSION)
+if(NOT DEFINED PYTHON_MODULE_EXTENSION OR NOT DEFINED PYTHON_MODULE_DEBUG_POSTFIX)
   execute_process(
     COMMAND
       "${${_Python}_EXECUTABLE}" "-c"
       "import sys, importlib; s = importlib.import_module('distutils.sysconfig' if sys.version_info < (3, 10) else 'sysconfig'); print(s.get_config_var('EXT_SUFFIX') or s.get_config_var('SO'))"
-    OUTPUT_VARIABLE _PYTHON_MODULE_EXTENSION
-    ERROR_VARIABLE _PYTHON_MODULE_EXTENSION_ERR
+    OUTPUT_VARIABLE _PYTHON_MODULE_EXT_SUFFIX
+    ERROR_VARIABLE _PYTHON_MODULE_EXT_SUFFIX_ERR
     OUTPUT_STRIP_TRAILING_WHITESPACE)
 
-  if(_PYTHON_MODULE_EXTENSION STREQUAL "")
+  if(_PYTHON_MODULE_EXT_SUFFIX STREQUAL "")
     message(
       FATAL_ERROR "pybind11 could not query the module file extension, likely the 'distutils'"
-                  "package is not installed. Full error message:\n${_PYTHON_MODULE_EXTENSION_ERR}")
+                  "package is not installed. Full error message:\n${_PYTHON_MODULE_EXT_SUFFIX_ERR}"
+    )
   endif()
 
   # This needs to be available for the pybind11_extension function
-  set(PYTHON_MODULE_EXTENSION
-      "${_PYTHON_MODULE_EXTENSION}"
-      CACHE INTERNAL "")
+  if(NOT DEFINED PYTHON_MODULE_DEBUG_POSTFIX)
+    get_filename_component(_PYTHON_MODULE_DEBUG_POSTFIX "${_PYTHON_MODULE_EXT_SUFFIX}" NAME_WE)
+    set(PYTHON_MODULE_DEBUG_POSTFIX
+        "${_PYTHON_MODULE_DEBUG_POSTFIX}"
+        CACHE INTERNAL "")
+  endif()
+
+  if(NOT DEFINED PYTHON_MODULE_EXTENSION)
+    get_filename_component(_PYTHON_MODULE_EXTENSION "${_PYTHON_MODULE_EXT_SUFFIX}" EXT)
+    set(PYTHON_MODULE_EXTENSION
+        "${_PYTHON_MODULE_EXTENSION}"
+        CACHE INTERNAL "")
+  endif()
 endif()
 
 # Python debug libraries expose slightly different objects before 3.8
 # https://docs.python.org/3.6/c-api/intro.html#debugging-builds
 # https://stackoverflow.com/questions/39161202/how-to-work-around-missing-pymodule-create2-in-amd64-win-python35-d-lib
 if(PYTHON_IS_DEBUG)
   set_property(
     TARGET pybind11::pybind11
     APPEND
     PROPERTY INTERFACE_COMPILE_DEFINITIONS Py_DEBUG)
 endif()
 
-# Check on every access - since Python2 and Python3 could have been used - do nothing in that case.
+# Check on every access - since Python can change - do nothing in that case.
 
 if(DEFINED ${_Python}_INCLUDE_DIRS)
   # Only add Python for build - must be added during the import for config
   # since it has to be re-discovered.
   #
   # This needs to be a target to be included after the local pybind11
   # directory, just in case there there is an installed pybind11 sitting
@@ -155,21 +194,14 @@
     APPEND
     PROPERTY INTERFACE_LINK_LIBRARIES pybind11::python_headers)
   set(pybind11_INCLUDE_DIRS
       "${pybind11_INCLUDE_DIR}" "${${_Python}_INCLUDE_DIRS}"
       CACHE INTERNAL "Directories where pybind11 and possibly Python headers are located")
 endif()
 
-if(DEFINED ${_Python}_VERSION AND ${_Python}_VERSION VERSION_LESS 3)
-  set_property(
-    TARGET pybind11::pybind11
-    APPEND
-    PROPERTY INTERFACE_LINK_LIBRARIES pybind11::python2_no_register)
-endif()
-
 # In CMake 3.18+, you can find these separately, so include an if
 if(TARGET ${_Python}::Python)
   set_property(
     TARGET pybind11::embed
     APPEND
     PROPERTY INTERFACE_LINK_LIBRARIES ${_Python}::Python)
 endif()
@@ -201,16 +233,14 @@
     set(lib_type MODULE)
   endif()
 
   if("${_Python}" STREQUAL "Python")
     python_add_library(${target_name} ${lib_type} ${ARG_UNPARSED_ARGUMENTS})
   elseif("${_Python}" STREQUAL "Python3")
     python3_add_library(${target_name} ${lib_type} ${ARG_UNPARSED_ARGUMENTS})
-  elseif("${_Python}" STREQUAL "Python2")
-    python2_add_library(${target_name} ${lib_type} ${ARG_UNPARSED_ARGUMENTS})
   else()
     message(FATAL_ERROR "Cannot detect FindPython version: ${_Python}")
   endif()
 
   target_link_libraries(${target_name} PRIVATE pybind11::headers)
 
   if(lib_type STREQUAL "MODULE")
@@ -219,18 +249,14 @@
     target_link_libraries(${target_name} PRIVATE pybind11::embed)
   endif()
 
   if(MSVC)
     target_link_libraries(${target_name} PRIVATE pybind11::windows_extras)
   endif()
 
-  if(DEFINED ${_Python}_VERSION AND ${_Python}_VERSION VERSION_LESS 3)
-    target_link_libraries(${target_name} PRIVATE pybind11::python2_no_register)
-  endif()
-
   # -fvisibility=hidden is required to allow multiple modules compiled against
   # different pybind versions to work properly, and for some features (e.g.
   # py::module_local).  We force it on everything inside the `pybind11`
   # namespace; also turning it on for a pybind module compilation here avoids
   # potential warnings or issues from having mixed hidden/non-hidden types.
   if(NOT DEFINED CMAKE_CXX_VISIBILITY_PRESET)
     set_target_properties(${target_name} PROPERTIES CXX_VISIBILITY_PRESET "hidden")
@@ -253,26 +279,33 @@
     if(ARG_THIN_LTO)
       target_link_libraries(${target_name} PRIVATE pybind11::thin_lto)
     else()
       target_link_libraries(${target_name} PRIVATE pybind11::lto)
     endif()
   endif()
 
-  if(NOT MSVC AND NOT ${CMAKE_BUILD_TYPE} MATCHES Debug|RelWithDebInfo)
-    # Strip unnecessary sections of the binary on Linux/macOS
-    pybind11_strip(${target_name})
+  if(DEFINED CMAKE_BUILD_TYPE) # see https://github.com/pybind/pybind11/issues/4454
+    # Use case-insensitive comparison to match the result of $<CONFIG:cfgs>
+    string(TOUPPER "${CMAKE_BUILD_TYPE}" uppercase_CMAKE_BUILD_TYPE)
+    if(NOT MSVC AND NOT "${uppercase_CMAKE_BUILD_TYPE}" MATCHES DEBUG|RELWITHDEBINFO)
+      # Strip unnecessary sections of the binary on Linux/macOS
+      pybind11_strip(${target_name})
+    endif()
   endif()
 
   if(MSVC)
     target_link_libraries(${target_name} PRIVATE pybind11::windows_extras)
   endif()
 
   if(ARG_OPT_SIZE)
     target_link_libraries(${target_name} PRIVATE pybind11::opt_size)
   endif()
 endfunction()
 
 function(pybind11_extension name)
   # The extension is precomputed
-  set_target_properties(${name} PROPERTIES PREFIX "" SUFFIX "${PYTHON_MODULE_EXTENSION}")
-
+  set_target_properties(
+    ${name}
+    PROPERTIES PREFIX ""
+               DEBUG_POSTFIX "${PYTHON_MODULE_DEBUG_POSTFIX}"
+               SUFFIX "${PYTHON_MODULE_EXTENSION}")
 endfunction()
```

### Comparing `python_prtree-0.6.0/third/pybind11/tools/pybind11Tools.cmake` & `python_prtree-0.6.1/third/pybind11/tools/pybind11Tools.cmake`

 * *Files 17% similar despite different names*

```diff
@@ -39,15 +39,15 @@
   set(PYBIND11_PYTHON_VERSION
       ""
       CACHE STRING "Python version to use for compiling modules")
 endif()
 
 # A user can set versions manually too
 set(Python_ADDITIONAL_VERSIONS
-    "3.11;3.10;3.9;3.8;3.7;3.6;3.5;3.4"
+    "3.12;3.11;3.10;3.9;3.8;3.7;3.6"
     CACHE INTERNAL "")
 
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_LIST_DIR}")
 find_package(PythonLibsNew ${PYBIND11_PYTHON_VERSION} MODULE REQUIRED ${_pybind11_quiet})
 list(REMOVE_AT CMAKE_MODULE_PATH -1)
 
 # Makes a normal variable a cached variable
@@ -61,14 +61,15 @@
 endmacro()
 
 # Cache variables so pybind11_add_module can be used in parent projects
 _pybind11_promote_to_cache(PYTHON_INCLUDE_DIRS)
 _pybind11_promote_to_cache(PYTHON_LIBRARIES)
 _pybind11_promote_to_cache(PYTHON_MODULE_PREFIX)
 _pybind11_promote_to_cache(PYTHON_MODULE_EXTENSION)
+_pybind11_promote_to_cache(PYTHON_MODULE_DEBUG_POSTFIX)
 _pybind11_promote_to_cache(PYTHON_VERSION_MAJOR)
 _pybind11_promote_to_cache(PYTHON_VERSION_MINOR)
 _pybind11_promote_to_cache(PYTHON_VERSION)
 _pybind11_promote_to_cache(PYTHON_IS_DEBUG)
 
 if(PYBIND11_MASTER_PROJECT)
   if(PYTHON_MODULE_EXTENSION MATCHES "pypy")
@@ -111,37 +112,52 @@
 if(PYTHON_IS_DEBUG)
   set_property(
     TARGET pybind11::pybind11
     APPEND
     PROPERTY INTERFACE_COMPILE_DEFINITIONS Py_DEBUG)
 endif()
 
-set_property(
-  TARGET pybind11::module
-  APPEND
-  PROPERTY
-    INTERFACE_LINK_LIBRARIES pybind11::python_link_helper
-    "$<$<OR:$<PLATFORM_ID:Windows>,$<PLATFORM_ID:Cygwin>>:$<BUILD_INTERFACE:${PYTHON_LIBRARIES}>>")
+# The <3.11 code here does not support release/debug builds at the same time, like on vcpkg
+if(CMAKE_VERSION VERSION_LESS 3.11)
+  set_property(
+    TARGET pybind11::module
+    APPEND
+    PROPERTY
+      INTERFACE_LINK_LIBRARIES
+      pybind11::python_link_helper
+      "$<$<OR:$<PLATFORM_ID:Windows>,$<PLATFORM_ID:Cygwin>>:$<BUILD_INTERFACE:${PYTHON_LIBRARIES}>>"
+  )
 
-if(PYTHON_VERSION VERSION_LESS 3)
   set_property(
-    TARGET pybind11::pybind11
+    TARGET pybind11::embed
     APPEND
-    PROPERTY INTERFACE_LINK_LIBRARIES pybind11::python2_no_register)
-endif()
+    PROPERTY INTERFACE_LINK_LIBRARIES pybind11::pybind11 $<BUILD_INTERFACE:${PYTHON_LIBRARIES}>)
+else()
+  # The IMPORTED INTERFACE library here is to ensure that "debug" and "release" get processed outside
+  # of a generator expression - https://gitlab.kitware.com/cmake/cmake/-/issues/18424, as they are
+  # target_link_library keywords rather than real libraries.
+  add_library(pybind11::_ClassicPythonLibraries IMPORTED INTERFACE)
+  target_link_libraries(pybind11::_ClassicPythonLibraries INTERFACE ${PYTHON_LIBRARIES})
+  target_link_libraries(
+    pybind11::module
+    INTERFACE
+      pybind11::python_link_helper
+      "$<$<OR:$<PLATFORM_ID:Windows>,$<PLATFORM_ID:Cygwin>>:pybind11::_ClassicPythonLibraries>")
 
-set_property(
-  TARGET pybind11::embed
-  APPEND
-  PROPERTY INTERFACE_LINK_LIBRARIES pybind11::pybind11 $<BUILD_INTERFACE:${PYTHON_LIBRARIES}>)
+  target_link_libraries(pybind11::embed INTERFACE pybind11::pybind11
+                                                  pybind11::_ClassicPythonLibraries)
+endif()
 
 function(pybind11_extension name)
   # The prefix and extension are provided by FindPythonLibsNew.cmake
-  set_target_properties(${name} PROPERTIES PREFIX "${PYTHON_MODULE_PREFIX}"
-                                           SUFFIX "${PYTHON_MODULE_EXTENSION}")
+  set_target_properties(
+    ${name}
+    PROPERTIES PREFIX "${PYTHON_MODULE_PREFIX}"
+               DEBUG_POSTFIX "${PYTHON_MODULE_DEBUG_POSTFIX}"
+               SUFFIX "${PYTHON_MODULE_EXTENSION}")
 endfunction()
 
 # Build a Python extension module:
 # pybind11_add_module(<name> [MODULE | SHARED] [EXCLUDE_FROM_ALL]
 #                     [NO_EXTRAS] [THIN_LTO] [OPT_SIZE] source1 [source2 ...])
 #
 function(pybind11_add_module target_name)
@@ -196,16 +212,20 @@
     if(ARG_THIN_LTO)
       target_link_libraries(${target_name} PRIVATE pybind11::thin_lto)
     else()
       target_link_libraries(${target_name} PRIVATE pybind11::lto)
     endif()
   endif()
 
-  if(NOT MSVC AND NOT ${CMAKE_BUILD_TYPE} MATCHES Debug|RelWithDebInfo)
-    pybind11_strip(${target_name})
+  if(DEFINED CMAKE_BUILD_TYPE) # see https://github.com/pybind/pybind11/issues/4454
+    # Use case-insensitive comparison to match the result of $<CONFIG:cfgs>
+    string(TOUPPER "${CMAKE_BUILD_TYPE}" uppercase_CMAKE_BUILD_TYPE)
+    if(NOT MSVC AND NOT "${uppercase_CMAKE_BUILD_TYPE}" MATCHES DEBUG|RELWITHDEBINFO)
+      pybind11_strip(${target_name})
+    endif()
   endif()
 
   if(MSVC)
     target_link_libraries(${target_name} PRIVATE pybind11::windows_extras)
   endif()
 
   if(ARG_OPT_SIZE)
```

### Comparing `python_prtree-0.6.0/third/pybind11/tools/setup_global.py.in` & `python_prtree-0.6.1/third/pybind11/tools/setup_global.py.in`

 * *Files 18% similar despite different names*

```diff
@@ -1,21 +1,15 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
+#!/usr/bin/env python3
 
 # Setup script for pybind11-global (in the sdist or in tools/setup_global.py in the repository)
 # This package is targeted for easy use from CMake.
 
-import contextlib
 import glob
 import os
 import re
-import shutil
-import subprocess
-import sys
-import tempfile
 
 # Setuptools has to be before distutils
 from setuptools import setup
 
 from distutils.command.install_headers import install_headers
 
 class InstallHeadersNested(install_headers):
@@ -29,17 +23,19 @@
             self.mkpath(dst)
             (out, _) = self.copy_file(header, dst)
             self.outfiles.append(out)
 
 
 main_headers = glob.glob("pybind11/include/pybind11/*.h")
 detail_headers = glob.glob("pybind11/include/pybind11/detail/*.h")
+eigen_headers = glob.glob("pybind11/include/pybind11/eigen/*.h")
 stl_headers = glob.glob("pybind11/include/pybind11/stl/*.h")
 cmake_files = glob.glob("pybind11/share/cmake/pybind11/*.cmake")
-headers = main_headers + detail_headers + stl_headers
+pkgconfig_files = glob.glob("pybind11/share/pkgconfig/*.pc")
+headers = main_headers + detail_headers + stl_headers + eigen_headers
 
 cmdclass = {"install_headers": InstallHeadersNested}
 $extra_cmd
 
 # This will _not_ affect installing from wheels,
 # only building wheels or installing from SDist.
 # Primarily intended on Windows, where this is sometimes
@@ -53,13 +49,15 @@
 setup(
     name="pybind11_global",
     version="$version",
     packages=[],
     headers=headers,
     data_files=[
         (base + "share/cmake/pybind11", cmake_files),
+        (base + "share/pkgconfig", pkgconfig_files),
         (base + "include/pybind11", main_headers),
         (base + "include/pybind11/detail", detail_headers),
+        (base + "include/pybind11/eigen", eigen_headers),
         (base + "include/pybind11/stl", stl_headers),
     ],
     cmdclass=cmdclass,
 )
```

### Comparing `python_prtree-0.6.0/third/pybind11/tools/setup_main.py.in` & `python_prtree-0.6.1/third/pybind11/tools/setup_main.py.in`

 * *Files 15% similar despite different names*

```diff
@@ -1,9 +1,8 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
+#!/usr/bin/env python3
 
 # Setup script (in the sdist or in tools/setup_main.py in the repository)
 
 from setuptools import setup
 
 cmdclass = {}
 $extra_cmd
@@ -12,23 +11,27 @@
     name="pybind11",
     version="$version",
     download_url='https://github.com/pybind/pybind11/tarball/v$version',
     packages=[
         "pybind11",
         "pybind11.include.pybind11",
         "pybind11.include.pybind11.detail",
+        "pybind11.include.pybind11.eigen",
         "pybind11.include.pybind11.stl",
         "pybind11.share.cmake.pybind11",
+        "pybind11.share.pkgconfig",
     ],
     package_data={
-        "pybind11": ["py.typed", "*.pyi"],
+        "pybind11": ["py.typed"],
         "pybind11.include.pybind11": ["*.h"],
         "pybind11.include.pybind11.detail": ["*.h"],
+        "pybind11.include.pybind11.eigen": ["*.h"],
         "pybind11.include.pybind11.stl": ["*.h"],
         "pybind11.share.cmake.pybind11": ["*.cmake"],
+        "pybind11.share.pkgconfig": ["*.pc"],
     },
     extras_require={
         "global": ["pybind11_global==$version"]
         },
     entry_points={
         "console_scripts": [
              "pybind11-config = pybind11.__main__:main",
```

### Comparing `python_prtree-0.6.0/third/snappy/.appveyor.yml` & `python_prtree-0.6.1/third/snappy/.appveyor.yml`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/snappy/.travis.yml` & `python_prtree-0.6.1/third/snappy/.travis.yml`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/snappy/CMakeLists.txt` & `python_prtree-0.6.1/third/snappy/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/snappy/CONTRIBUTING.md` & `python_prtree-0.6.1/third/snappy/CONTRIBUTING.md`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/snappy/COPYING` & `python_prtree-0.6.1/third/snappy/COPYING`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/snappy/NEWS` & `python_prtree-0.6.1/third/snappy/NEWS`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/snappy/README.md` & `python_prtree-0.6.1/third/snappy/README.md`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/snappy/cmake/SnappyConfig.cmake.in` & `python_prtree-0.6.1/third/snappy/cmake/SnappyConfig.cmake.in`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/snappy/cmake/config.h.in` & `python_prtree-0.6.1/third/snappy/cmake/config.h.in`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/snappy/docs/README.md` & `python_prtree-0.6.1/third/snappy/docs/README.md`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/snappy/format_description.txt` & `python_prtree-0.6.1/third/snappy/format_description.txt`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/snappy/framing_format.txt` & `python_prtree-0.6.1/third/snappy/framing_format.txt`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/snappy/snappy-c.cc` & `python_prtree-0.6.1/third/snappy/snappy-c.cc`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/snappy/snappy-c.h` & `python_prtree-0.6.1/third/snappy/snappy-c.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/snappy/snappy-internal.h` & `python_prtree-0.6.1/third/snappy/snappy-internal.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/snappy/snappy-sinksource.cc` & `python_prtree-0.6.1/third/snappy/snappy-sinksource.cc`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/snappy/snappy-sinksource.h` & `python_prtree-0.6.1/third/snappy/snappy-sinksource.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/snappy/snappy-stubs-internal.cc` & `python_prtree-0.6.1/third/snappy/snappy-stubs-internal.cc`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/snappy/snappy-stubs-internal.h` & `python_prtree-0.6.1/third/snappy/snappy-stubs-internal.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/snappy/snappy-stubs-public.h.in` & `python_prtree-0.6.1/third/snappy/snappy-stubs-public.h.in`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/snappy/snappy-test.cc` & `python_prtree-0.6.1/third/snappy/snappy-test.cc`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/snappy/snappy-test.h` & `python_prtree-0.6.1/third/snappy/snappy-test.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/snappy/snappy.cc` & `python_prtree-0.6.1/third/snappy/snappy.cc`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/snappy/snappy.h` & `python_prtree-0.6.1/third/snappy/snappy.h`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/snappy/snappy_compress_fuzzer.cc` & `python_prtree-0.6.1/third/snappy/snappy_compress_fuzzer.cc`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/snappy/snappy_uncompress_fuzzer.cc` & `python_prtree-0.6.1/third/snappy/snappy_uncompress_fuzzer.cc`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/snappy/snappy_unittest.cc` & `python_prtree-0.6.1/third/snappy/snappy_unittest.cc`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/snappy/testdata/alice29.txt` & `python_prtree-0.6.1/third/snappy/testdata/alice29.txt`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/snappy/testdata/asyoulik.txt` & `python_prtree-0.6.1/third/snappy/testdata/asyoulik.txt`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/snappy/testdata/baddata1.snappy` & `python_prtree-0.6.1/third/snappy/testdata/baddata1.snappy`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/snappy/testdata/baddata2.snappy` & `python_prtree-0.6.1/third/snappy/testdata/baddata2.snappy`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/snappy/testdata/baddata3.snappy` & `python_prtree-0.6.1/third/snappy/testdata/baddata3.snappy`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/snappy/testdata/fireworks.jpeg` & `python_prtree-0.6.1/third/snappy/testdata/fireworks.jpeg`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/snappy/testdata/geo.protodata` & `python_prtree-0.6.1/third/snappy/testdata/geo.protodata`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/snappy/testdata/html` & `python_prtree-0.6.1/third/snappy/testdata/html`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/snappy/testdata/html_x_4` & `python_prtree-0.6.1/third/snappy/testdata/html_x_4`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/snappy/testdata/kppkn.gtb` & `python_prtree-0.6.1/third/snappy/testdata/kppkn.gtb`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/snappy/testdata/lcet10.txt` & `python_prtree-0.6.1/third/snappy/testdata/lcet10.txt`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/snappy/testdata/paper-100k.pdf` & `python_prtree-0.6.1/third/snappy/testdata/paper-100k.pdf`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/snappy/testdata/plrabn12.txt` & `python_prtree-0.6.1/third/snappy/testdata/plrabn12.txt`

 * *Files identical despite different names*

### Comparing `python_prtree-0.6.0/third/snappy/testdata/urls.10K` & `python_prtree-0.6.1/third/snappy/testdata/urls.10K`

 * *Files identical despite different names*

