# Comparing `tmp/pyqpanda-3.8.3.2-cp39-none-win_amd64.whl.zip` & `tmp/pyqpanda-3.8.3.3-cp39-none-win_amd64.whl.zip`

## zipinfo {}

```diff
@@ -1,73 +1,74 @@
-Zip file size: 5959409 bytes, number of entries: 71
--rw-rw-rw-  2.0 fat      863 b- defN 24-Apr-03 08:06 pyqpanda/__init__.py
--rw-rw-rw-  2.0 fat   963240 b- defN 24-Apr-03 08:06 pyqpanda/msvcr120.dll
--rw-rw-rw-  2.0 fat     1339 b- defN 24-Apr-03 08:06 pyqpanda/optimizerTest.py
--rw-rw-rw-  2.0 fat 10516480 b- defN 24-Apr-03 08:30 pyqpanda/pyQPanda.pyd
--rw-rw-rw-  2.0 fat   302603 b- defN 24-Apr-03 08:30 pyqpanda/pyQPanda.pyi
--rw-rw-rw-  2.0 fat     2865 b- defN 24-Apr-03 08:06 pyqpanda/utils.py
--rw-rw-rw-  2.0 fat      109 b- defN 24-Apr-03 08:06 pyqpanda/Algorithm/__init__.py
--rw-rw-rw-  2.0 fat     2570 b- defN 24-Apr-03 08:06 pyqpanda/Algorithm/fragments.py
--rw-rw-rw-  2.0 fat     8587 b- defN 24-Apr-03 08:06 pyqpanda/Algorithm/hamiltonian_simulation.py
--rw-rw-rw-  2.0 fat      109 b- defN 24-Apr-03 08:06 pyqpanda/Algorithm/QuantumCircuitLearning/__init__.py
--rw-rw-rw-  2.0 fat     7045 b- defN 24-Apr-03 08:06 pyqpanda/Algorithm/QuantumCircuitLearning/quantum_circuit_learning.py
--rw-rw-rw-  2.0 fat      100 b- defN 24-Apr-03 08:06 pyqpanda/Algorithm/QuantumGradient/__init__.py
--rw-rw-rw-  2.0 fat    18414 b- defN 24-Apr-03 08:06 pyqpanda/Algorithm/QuantumGradient/quantum_gradient.py
--rw-rw-rw-  2.0 fat      761 b- defN 24-Apr-03 08:06 pyqpanda/Algorithm/QuantumGradient/quantum_gradient_qaoa_test.py
--rw-rw-rw-  2.0 fat      109 b- defN 24-Apr-03 08:06 pyqpanda/Algorithm/VariationalQuantumEigensolver/__init__.py
--rw-rw-rw-  2.0 fat    12413 b- defN 24-Apr-03 08:06 pyqpanda/Algorithm/VariationalQuantumEigensolver/vqe.py
--rw-rw-rw-  2.0 fat     1831 b- defN 24-Apr-03 08:06 pyqpanda/Algorithm/demo/Deustch_Jozsa.py
--rw-rw-rw-  2.0 fat     2271 b- defN 24-Apr-03 08:06 pyqpanda/Algorithm/demo/Grover.py
--rw-rw-rw-  2.0 fat       35 b- defN 24-Apr-03 08:06 pyqpanda/Algorithm/demo/__init__.py
--rw-rw-rw-  2.0 fat      406 b- defN 24-Apr-03 08:06 pyqpanda/Algorithm/test/__init__.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-Apr-03 08:06 pyqpanda/Algorithm/test/hamiltonian_simulation_test.py
--rw-rw-rw-  2.0 fat    12140 b- defN 24-Apr-03 08:06 pyqpanda/Algorithm/test/qaoa_maxcut_test.py
--rw-rw-rw-  2.0 fat      350 b- defN 24-Apr-03 08:06 pyqpanda/Algorithm/test/qaoa_test.py
--rw-rw-rw-  2.0 fat     1285 b- defN 24-Apr-03 08:06 pyqpanda/Algorithm/test/qcl_test.py
--rw-rw-rw-  2.0 fat     7190 b- defN 24-Apr-03 08:06 pyqpanda/Algorithm/test/quantum_gradient_qaoa_test.py
--rw-rw-rw-  2.0 fat     1981 b- defN 24-Apr-03 08:06 pyqpanda/Algorithm/test/state_preparation_test.py
--rw-rw-rw-  2.0 fat     1175 b- defN 24-Apr-03 08:06 pyqpanda/Algorithm/test/test_script.py
--rw-rw-rw-  2.0 fat     1045 b- defN 24-Apr-03 08:06 pyqpanda/Algorithm/test/test_utils.py
--rw-rw-rw-  2.0 fat     1692 b- defN 24-Apr-03 08:06 pyqpanda/Algorithm/test/vqe_test.py
--rw-rw-rw-  2.0 fat      154 b- defN 24-Apr-03 08:06 pyqpanda/Hamiltonian/__init__.py
--rw-rw-rw-  2.0 fat     1250 b- defN 24-Apr-03 08:06 pyqpanda/Hamiltonian/chemistry_client.py
--rw-rw-rw-  2.0 fat      178 b- defN 24-Apr-03 08:06 pyqpanda/Hamiltonian/PauliOperator/__init__.py
--rw-rw-rw-  2.0 fat       30 b- defN 24-Apr-03 08:06 pyqpanda/Hamiltonian/test/__init__.py
--rw-rw-rw-  2.0 fat      315 b- defN 24-Apr-03 08:06 pyqpanda/Hamiltonian/test/hamiltonian_test.py
--rw-rw-rw-  2.0 fat   283136 b- defN 24-Apr-03 08:30 pyqpanda/Kyber/Kyber.pyd
--rw-rw-rw-  2.0 fat   110592 b- defN 24-Apr-03 08:31 pyqpanda/Kyber/Kyber_SM2.pyd
--rw-rw-rw-  2.0 fat      130 b- defN 24-Apr-03 08:06 pyqpanda/Kyber/__init__.py
--rw-rw-rw-  2.0 fat     4064 b- defN 24-Apr-03 08:06 pyqpanda/Kyber/setup-cpython.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-Apr-03 08:06 pyqpanda/Operator/__init__.py
--rw-rw-rw-  2.0 fat  3317760 b- defN 24-Apr-03 08:29 pyqpanda/Operator/pyQPandaOperator.pyd
--rw-rw-rw-  2.0 fat    15567 b- defN 24-Apr-03 08:29 pyqpanda/Operator/pyQPandaOperator.pyi
--rw-rw-rw-  2.0 fat    32040 b- defN 24-Apr-03 08:06 pyqpanda/OriginService/PilotOSMachine.py
--rw-rw-rw-  2.0 fat    67443 b- defN 24-Apr-03 08:06 pyqpanda/OriginService/QCloudMachine.py
--rw-rw-rw-  2.0 fat      165 b- defN 24-Apr-03 08:06 pyqpanda/OriginService/__init__.py
--rw-rw-rw-  2.0 fat      709 b- defN 24-Apr-03 08:06 pyqpanda/TorchLayer/Torch_.py
--rw-rw-rw-  2.0 fat      163 b- defN 24-Apr-03 08:06 pyqpanda/TorchLayer/__init__.py
--rw-rw-rw-  2.0 fat      895 b- defN 24-Apr-03 08:06 pyqpanda/TorchLayer/basic_eng.py
--rw-rw-rw-  2.0 fat      848 b- defN 24-Apr-03 08:06 pyqpanda/TorchLayer/cir_angle.py
--rw-rw-rw-  2.0 fat     3709 b- defN 24-Apr-03 08:06 pyqpanda/TorchLayer/torchlayer.py
--rw-rw-rw-  2.0 fat      265 b- defN 24-Apr-03 08:06 pyqpanda/Variational/VariationalCircuit.py
--rw-rw-rw-  2.0 fat      366 b- defN 24-Apr-03 08:06 pyqpanda/Variational/__init__.py
--rw-rw-rw-  2.0 fat     2487 b- defN 24-Apr-03 08:06 pyqpanda/Variational/variational_qaoa_citcuit.py
--rw-rw-rw-  2.0 fat      598 b- defN 24-Apr-03 08:06 pyqpanda/Visualization/__init__.py
--rw-rw-rw-  2.0 fat    29805 b- defN 24-Apr-03 08:06 pyqpanda/Visualization/bloch.py
--rw-rw-rw-  2.0 fat    15445 b- defN 24-Apr-03 08:06 pyqpanda/Visualization/bloch_plot.py
--rw-rw-rw-  2.0 fat    19822 b- defN 24-Apr-03 08:06 pyqpanda/Visualization/circuit_composer.py
--rw-rw-rw-  2.0 fat     5151 b- defN 24-Apr-03 08:06 pyqpanda/Visualization/circuit_draw.py
--rw-rw-rw-  2.0 fat     7514 b- defN 24-Apr-03 08:06 pyqpanda/Visualization/circuit_info.py
--rw-rw-rw-  2.0 fat     5385 b- defN 24-Apr-03 08:06 pyqpanda/Visualization/circuit_style.py
--rw-rw-rw-  2.0 fat     1362 b- defN 24-Apr-03 08:06 pyqpanda/Visualization/draw_probability_map.py
--rw-rw-rw-  2.0 fat     1299 b- defN 24-Apr-03 08:06 pyqpanda/Visualization/exceptions.py
--rw-rw-rw-  2.0 fat    67480 b- defN 24-Apr-03 08:06 pyqpanda/Visualization/matplotlib_draw.py
--rw-rw-rw-  2.0 fat    10396 b- defN 24-Apr-03 08:06 pyqpanda/Visualization/parameterexpression.py
--rw-rw-rw-  2.0 fat     4875 b- defN 24-Apr-03 08:06 pyqpanda/Visualization/pi_check.py
--rw-rw-rw-  2.0 fat    14211 b- defN 24-Apr-03 08:06 pyqpanda/Visualization/quantum_state_plot.py
--rw-rw-rw-  2.0 fat      831 b- defN 24-Apr-03 08:06 pyqpanda/Visualization/utils.py
--rw-rw-rw-  2.0 fat    11558 b- defN 24-Apr-03 08:31 pyqpanda-3.8.3.2.dist-info/LICENSE
--rw-rw-rw-  2.0 fat      946 b- defN 24-Apr-03 08:31 pyqpanda-3.8.3.2.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 24-Apr-03 08:31 pyqpanda-3.8.3.2.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       22 b- defN 24-Apr-03 08:31 pyqpanda-3.8.3.2.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     6654 b- defN 24-Apr-03 08:31 pyqpanda-3.8.3.2.dist-info/RECORD
-71 files, 15914720 bytes uncompressed, 5948653 bytes compressed:  62.6%
+Zip file size: 6468695 bytes, number of entries: 72
+-rw-rw-rw-  2.0 fat      863 b- defN 24-Apr-12 10:05 pyqpanda/__init__.py
+-rw-rw-rw-  2.0 fat   364032 b- defN 24-Apr-12 10:29 pyqpanda/libcurl.dll
+-rw-rw-rw-  2.0 fat   963240 b- defN 24-Apr-12 10:05 pyqpanda/msvcr120.dll
+-rw-rw-rw-  2.0 fat     1339 b- defN 24-Apr-12 10:05 pyqpanda/optimizerTest.py
+-rw-rw-rw-  2.0 fat 11475456 b- defN 24-Apr-12 10:29 pyqpanda/pyQPanda.pyd
+-rw-rw-rw-  2.0 fat   322948 b- defN 24-Apr-12 10:29 pyqpanda/pyQPanda.pyi
+-rw-rw-rw-  2.0 fat     2865 b- defN 24-Apr-12 10:05 pyqpanda/utils.py
+-rw-rw-rw-  2.0 fat      109 b- defN 24-Apr-12 10:05 pyqpanda/Algorithm/__init__.py
+-rw-rw-rw-  2.0 fat     2570 b- defN 24-Apr-12 10:05 pyqpanda/Algorithm/fragments.py
+-rw-rw-rw-  2.0 fat     8587 b- defN 24-Apr-12 10:05 pyqpanda/Algorithm/hamiltonian_simulation.py
+-rw-rw-rw-  2.0 fat      109 b- defN 24-Apr-12 10:05 pyqpanda/Algorithm/QuantumCircuitLearning/__init__.py
+-rw-rw-rw-  2.0 fat     7045 b- defN 24-Apr-12 10:05 pyqpanda/Algorithm/QuantumCircuitLearning/quantum_circuit_learning.py
+-rw-rw-rw-  2.0 fat      100 b- defN 24-Apr-12 10:05 pyqpanda/Algorithm/QuantumGradient/__init__.py
+-rw-rw-rw-  2.0 fat    18414 b- defN 24-Apr-12 10:05 pyqpanda/Algorithm/QuantumGradient/quantum_gradient.py
+-rw-rw-rw-  2.0 fat      761 b- defN 24-Apr-12 10:05 pyqpanda/Algorithm/QuantumGradient/quantum_gradient_qaoa_test.py
+-rw-rw-rw-  2.0 fat      109 b- defN 24-Apr-12 10:05 pyqpanda/Algorithm/VariationalQuantumEigensolver/__init__.py
+-rw-rw-rw-  2.0 fat    12413 b- defN 24-Apr-12 10:05 pyqpanda/Algorithm/VariationalQuantumEigensolver/vqe.py
+-rw-rw-rw-  2.0 fat     1831 b- defN 24-Apr-12 10:05 pyqpanda/Algorithm/demo/Deustch_Jozsa.py
+-rw-rw-rw-  2.0 fat     2271 b- defN 24-Apr-12 10:05 pyqpanda/Algorithm/demo/Grover.py
+-rw-rw-rw-  2.0 fat       35 b- defN 24-Apr-12 10:05 pyqpanda/Algorithm/demo/__init__.py
+-rw-rw-rw-  2.0 fat      406 b- defN 24-Apr-12 10:05 pyqpanda/Algorithm/test/__init__.py
+-rw-rw-rw-  2.0 fat        0 b- defN 24-Apr-12 10:05 pyqpanda/Algorithm/test/hamiltonian_simulation_test.py
+-rw-rw-rw-  2.0 fat    12140 b- defN 24-Apr-12 10:05 pyqpanda/Algorithm/test/qaoa_maxcut_test.py
+-rw-rw-rw-  2.0 fat      350 b- defN 24-Apr-12 10:05 pyqpanda/Algorithm/test/qaoa_test.py
+-rw-rw-rw-  2.0 fat     1285 b- defN 24-Apr-12 10:05 pyqpanda/Algorithm/test/qcl_test.py
+-rw-rw-rw-  2.0 fat     7190 b- defN 24-Apr-12 10:05 pyqpanda/Algorithm/test/quantum_gradient_qaoa_test.py
+-rw-rw-rw-  2.0 fat     1981 b- defN 24-Apr-12 10:05 pyqpanda/Algorithm/test/state_preparation_test.py
+-rw-rw-rw-  2.0 fat     1175 b- defN 24-Apr-12 10:05 pyqpanda/Algorithm/test/test_script.py
+-rw-rw-rw-  2.0 fat     1045 b- defN 24-Apr-12 10:05 pyqpanda/Algorithm/test/test_utils.py
+-rw-rw-rw-  2.0 fat     1692 b- defN 24-Apr-12 10:05 pyqpanda/Algorithm/test/vqe_test.py
+-rw-rw-rw-  2.0 fat      154 b- defN 24-Apr-12 10:05 pyqpanda/Hamiltonian/__init__.py
+-rw-rw-rw-  2.0 fat     1250 b- defN 24-Apr-12 10:05 pyqpanda/Hamiltonian/chemistry_client.py
+-rw-rw-rw-  2.0 fat      178 b- defN 24-Apr-12 10:05 pyqpanda/Hamiltonian/PauliOperator/__init__.py
+-rw-rw-rw-  2.0 fat       30 b- defN 24-Apr-12 10:05 pyqpanda/Hamiltonian/test/__init__.py
+-rw-rw-rw-  2.0 fat      315 b- defN 24-Apr-12 10:05 pyqpanda/Hamiltonian/test/hamiltonian_test.py
+-rw-rw-rw-  2.0 fat   283136 b- defN 24-Apr-12 10:30 pyqpanda/Kyber/Kyber.pyd
+-rw-rw-rw-  2.0 fat   111104 b- defN 24-Apr-12 10:30 pyqpanda/Kyber/Kyber_SM2.pyd
+-rw-rw-rw-  2.0 fat      130 b- defN 24-Apr-12 10:05 pyqpanda/Kyber/__init__.py
+-rw-rw-rw-  2.0 fat     4064 b- defN 24-Apr-12 10:05 pyqpanda/Kyber/setup-cpython.py
+-rw-rw-rw-  2.0 fat        0 b- defN 24-Apr-12 10:05 pyqpanda/Operator/__init__.py
+-rw-rw-rw-  2.0 fat  3338752 b- defN 24-Apr-12 10:28 pyqpanda/Operator/pyQPandaOperator.pyd
+-rw-rw-rw-  2.0 fat    15567 b- defN 24-Apr-12 10:28 pyqpanda/Operator/pyQPandaOperator.pyi
+-rw-rw-rw-  2.0 fat    37802 b- defN 24-Apr-12 10:05 pyqpanda/OriginService/PilotOSMachine.py
+-rw-rw-rw-  2.0 fat    67443 b- defN 24-Apr-12 10:05 pyqpanda/OriginService/QCloudMachine.py
+-rw-rw-rw-  2.0 fat      165 b- defN 24-Apr-12 10:05 pyqpanda/OriginService/__init__.py
+-rw-rw-rw-  2.0 fat      709 b- defN 24-Apr-12 10:05 pyqpanda/TorchLayer/Torch_.py
+-rw-rw-rw-  2.0 fat      163 b- defN 24-Apr-12 10:05 pyqpanda/TorchLayer/__init__.py
+-rw-rw-rw-  2.0 fat      895 b- defN 24-Apr-12 10:05 pyqpanda/TorchLayer/basic_eng.py
+-rw-rw-rw-  2.0 fat      848 b- defN 24-Apr-12 10:05 pyqpanda/TorchLayer/cir_angle.py
+-rw-rw-rw-  2.0 fat     3709 b- defN 24-Apr-12 10:05 pyqpanda/TorchLayer/torchlayer.py
+-rw-rw-rw-  2.0 fat      265 b- defN 24-Apr-12 10:05 pyqpanda/Variational/VariationalCircuit.py
+-rw-rw-rw-  2.0 fat      366 b- defN 24-Apr-12 10:05 pyqpanda/Variational/__init__.py
+-rw-rw-rw-  2.0 fat     2487 b- defN 24-Apr-12 10:05 pyqpanda/Variational/variational_qaoa_citcuit.py
+-rw-rw-rw-  2.0 fat      599 b- defN 24-Apr-12 10:05 pyqpanda/Visualization/__init__.py
+-rw-rw-rw-  2.0 fat    29805 b- defN 24-Apr-12 10:05 pyqpanda/Visualization/bloch.py
+-rw-rw-rw-  2.0 fat    15445 b- defN 24-Apr-12 10:05 pyqpanda/Visualization/bloch_plot.py
+-rw-rw-rw-  2.0 fat    19822 b- defN 24-Apr-12 10:05 pyqpanda/Visualization/circuit_composer.py
+-rw-rw-rw-  2.0 fat     5151 b- defN 24-Apr-12 10:05 pyqpanda/Visualization/circuit_draw.py
+-rw-rw-rw-  2.0 fat     7514 b- defN 24-Apr-12 10:05 pyqpanda/Visualization/circuit_info.py
+-rw-rw-rw-  2.0 fat     5385 b- defN 24-Apr-12 10:05 pyqpanda/Visualization/circuit_style.py
+-rw-rw-rw-  2.0 fat     1363 b- defN 24-Apr-12 10:05 pyqpanda/Visualization/draw_probability_map.py
+-rw-rw-rw-  2.0 fat     1299 b- defN 24-Apr-12 10:05 pyqpanda/Visualization/exceptions.py
+-rw-rw-rw-  2.0 fat    67480 b- defN 24-Apr-12 10:05 pyqpanda/Visualization/matplotlib_draw.py
+-rw-rw-rw-  2.0 fat    10396 b- defN 24-Apr-12 10:05 pyqpanda/Visualization/parameterexpression.py
+-rw-rw-rw-  2.0 fat     4875 b- defN 24-Apr-12 10:05 pyqpanda/Visualization/pi_check.py
+-rw-rw-rw-  2.0 fat    14211 b- defN 24-Apr-12 10:05 pyqpanda/Visualization/quantum_state_plot.py
+-rw-rw-rw-  2.0 fat      831 b- defN 24-Apr-12 10:05 pyqpanda/Visualization/utils.py
+-rw-rw-rw-  2.0 fat    11558 b- defN 24-Apr-12 10:30 pyqpanda-3.8.3.3.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat      946 b- defN 24-Apr-12 10:30 pyqpanda-3.8.3.3.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 24-Apr-12 10:30 pyqpanda-3.8.3.3.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       22 b- defN 24-Apr-12 10:30 pyqpanda-3.8.3.3.dist-info/top_level.txt
+?rw-rw-r--  2.0 fat     6733 b- defN 24-Apr-12 10:30 pyqpanda-3.8.3.3.dist-info/RECORD
+72 files, 17285420 bytes uncompressed, 6457823 bytes compressed:  62.6%
```

## zipnote {}

```diff
@@ -1,10 +1,13 @@
 Filename: pyqpanda/__init__.py
 Comment: 
 
+Filename: pyqpanda/libcurl.dll
+Comment: 
+
 Filename: pyqpanda/msvcr120.dll
 Comment: 
 
 Filename: pyqpanda/optimizerTest.py
 Comment: 
 
 Filename: pyqpanda/pyQPanda.pyd
@@ -192,23 +195,23 @@
 
 Filename: pyqpanda/Visualization/quantum_state_plot.py
 Comment: 
 
 Filename: pyqpanda/Visualization/utils.py
 Comment: 
 
-Filename: pyqpanda-3.8.3.2.dist-info/LICENSE
+Filename: pyqpanda-3.8.3.3.dist-info/LICENSE
 Comment: 
 
-Filename: pyqpanda-3.8.3.2.dist-info/METADATA
+Filename: pyqpanda-3.8.3.3.dist-info/METADATA
 Comment: 
 
-Filename: pyqpanda-3.8.3.2.dist-info/WHEEL
+Filename: pyqpanda-3.8.3.3.dist-info/WHEEL
 Comment: 
 
-Filename: pyqpanda-3.8.3.2.dist-info/top_level.txt
+Filename: pyqpanda-3.8.3.3.dist-info/top_level.txt
 Comment: 
 
-Filename: pyqpanda-3.8.3.2.dist-info/RECORD
+Filename: pyqpanda-3.8.3.3.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## pyqpanda/pyQPanda.pyi

```diff
@@ -4178,21 +4178,21 @@
 
     def build_get_state_tomography_density(self, shot: int, chip_id: int = 2, is_amend: bool = True, is_mapping: bool = True, is_optimization: bool = True) -> str:
         """
         """
         ...
 
     @overload
-    def build_init_object(self, arg0: QProg, arg1: str, arg2: int) -> None:
+    def build_init_object(self, prog: QProg, task_name: str = 'QPanda Experiment', task_from: int = 4) -> None:
         """
         """
         ...
 
     @overload
-    def build_init_object(self, arg0: str, arg1: str, arg2: int) -> None:
+    def build_init_object(self, prog_str: str, task_name: str = 'QPanda Experiment', task_from: int = 4) -> None:
         """
         """
         ...
 
     def build_noise_measure(self, shots: int) -> str:
         """
         """
@@ -4287,14 +4287,29 @@
 
     def set_qcloud_url(self, cloud_url: str) -> None:
         """
         """
         ...
 
 
+class QCloudTaskConfig:
+    """
+    """
+    chip_id: real_chip_type
+    cloud_token: str
+    open_amend: bool
+    open_mapping: bool
+    open_optimization: bool
+    shots: int
+    def __init__(self) -> None:
+        """
+        """
+        ...
+
+
 class QError:
     """
     Quantum QError Type
     
     Members:
     
       UndefineError
@@ -4712,35 +4727,226 @@
     para: List[float]
     def __init__(self, arg0: str, arg1: int, arg2: int, arg3: str, arg4: float, arg5: List[float]) -> None:
         """
         """
         ...
 
 
+class QPilotMachine:
+    """
+    pliot machine
+    """
+    def __init__(self) -> None:
+        """
+        """
+        ...
+
+    def build_noise_params(self, nose_model_type: int, single_params: List[float], double_params: List[float]) -> PilotNoiseParams:
+        """
+        """
+        ...
+
+    def execute_callback_full_amplitude_expectation(self, prog_str: str, hamiltonian: List[Tuple[Dict[int,str],float]], qubit_vec: List[int], cb_func: Callable[[ErrorCode,float],None], chip_id: int = 33554433) -> ErrorCode:
+        """
+        """
+        ...
+
+    def execute_callback_full_amplitude_measure_task(self, prog_str: str, cb_func: Callable[[ErrorCode,Dict[str,float]],None], chip_id: int = 33554433, shots: int = 1000) -> ErrorCode:
+        """
+        """
+        ...
+
+    def execute_callback_full_amplitude_pmeasure_task(self, prog_str: str, qubit_vec: List[int], cb_func: Callable[[ErrorCode,Dict[str,float]],None], chip_id: int = 33554433) -> ErrorCode:
+        """
+        """
+        ...
+
+    def execute_callback_measure_task(self, prog_str: str, cb_func: Callable[[ErrorCode,Dict[str,float]],None], chip_id: int = 33554432, b_mapping: bool = True, b_optimization: bool = True, shots: int = 1000, specified_block: List[int] = []) -> ErrorCode:
+        """
+        """
+        ...
+
+    def execute_callback_noise_measure_task(self, prog_str: str, noise_params: PilotNoiseParams, cb_func: Callable[[ErrorCode,Dict[str,float]],None], chip_id: int = 33554433, shots: int = 1000) -> ErrorCode:
+        """
+        """
+        ...
+
+    def execute_callback_partial_amplitude_task(self, prog_str: str, target_amplitude_vec: List[str], cb_func: Callable[[ErrorCode,Dict[str,complex]],None], chip_id: int = 33554433) -> ErrorCode:
+        """
+        """
+        ...
+
+    def execute_callback_single_amplitude_task(self, prog_str: str, target_amplitude: str, cb_func: Callable[[ErrorCode,complex],None], chip_id: int = 33554433) -> ErrorCode:
+        """
+        """
+        ...
+
+    def execute_full_amplitude_expectation(self, prog_str: str, hamiltonian: List[Tuple[Dict[int,str],float]], qubit_vec: List[int], chip_id: int = 33554433) -> float:
+        """
+        """
+        ...
+
+    def execute_full_amplitude_measure_task(self, prog_str: str, chip_id: int = 33554433, shots: int = 1000) -> Dict[str,float]:
+        """
+        """
+        ...
+
+    def execute_full_amplitude_pmeasure_task(self, prog_str: str, qubit_vec: List[int], chip_id: int = 33554433) -> Dict[str,float]:
+        """
+        """
+        ...
+
+    def execute_measure_task(self, prog_str: str, chip_id: int = 33554432, b_mapping: bool = True, b_optimization: bool = True, shots: int = 1000, specified_block: List[int] = []) -> List[Dict[str,float]]:
+        """
+        """
+        ...
+
+    def execute_noise_measure_task(self, prog_str: str, noise_params: PilotNoiseParams, chip_id: int = 33554433, shots: int = 1000) -> Dict[str,float]:
+        """
+        """
+        ...
+
+    def execute_partial_amplitude_task(self, prog_str: str, target_amplitude_vec: List[str], chip_id: int = 33554433) -> Dict[str,complex]:
+        """
+        """
+        ...
+
+    def execute_single_amplitude_task(self, prog_str: str, target_amplitude: str, chip_id: int = 33554433) -> complex:
+        """
+        """
+        ...
+
+    def init(self, pilot_url: str, log_cout: bool = False) -> bool:
+        """
+        """
+        ...
+
+    def init_withconfig(self, config_path: str = 'pilotmachine.conf') -> bool:
+        """
+        """
+        ...
+
+
 class QPilotOSService(QuantumMachine):
     """
     origin quantum pilot OS Machine
     """
     def __init__(self, machine_type: str = 'CPU') -> None:
         """
         """
         ...
 
+    def _get_qst_density_result(self, task_id: str) -> list:
+        """
+        """
+        ...
+
+    def _get_qst_fidelity_result(self, task_id: str) -> list:
+        """
+        """
+        ...
+
+    def _get_qst_result(self, task_id: str) -> list:
+        """
+        """
+        ...
+
+    def async_em_compute(self, parameter_json: str) -> str:
+        """
+        """
+        ...
+
+    def async_real_chip_expectation(self, prog: QProg, hamiltonian: str, qubits: List[int] = [], shot: int = 1000, chip_id: int = 33554432, is_amend: bool = True, is_mapping: bool = True, is_optimization: bool = True, specified_block: List[int] = [], describe: str = '') -> str:
+        """
+        deprecated, use request instead.
+        """
+        ...
+
+    @overload
+    def async_real_chip_measure(self, prog: QProg, shot: int = 1000, chip_id: int = 33554432, is_amend: bool = True, is_mapping: bool = True, is_optimization: bool = True, specified_block: List[int] = [], is_prob_counts: bool = True, describe: str = '') -> str:
+        """
+        """
+        ...
+
+    @overload
+    def async_real_chip_measure(self, ir: str, shot: int = 1000, chip_id: int = 33554432, is_amend: bool = True, is_mapping: bool = True, is_optimization: bool = True, specified_block: List[int] = [], is_prob_counts: bool = True, describe: str = '') -> str:
+        """
+        """
+        ...
+
+    @overload
+    def async_real_chip_measure(self, prog: List[QProg], shot: int = 1000, chip_id: int = 33554432, is_amend: bool = True, is_mapping: bool = True, is_optimization: bool = True, specified_block: List[int] = [], is_prob_counts: bool = True, describe: str = '') -> str:
+        """
+        """
+        ...
+
+    @overload
+    def async_real_chip_measure(self, ir: List[str], shot: int = 1000, chip_id: int = 33554432, is_amend: bool = True, is_mapping: bool = True, is_optimization: bool = True, specified_block: List[int] = [], is_prob_counts: bool = True, describe: str = '') -> str:
+        """
+        """
+        ...
+
+    @overload
+    def async_real_chip_measure(self, prog: List[QProg], config_str: str) -> str:
+        """
+        """
+        ...
+
+    @overload
+    def async_real_chip_measure_vec(self, prog: List[QProg], shot: int = 1000, chip_id: int = 33554432, is_amend: bool = True, is_mapping: bool = True, is_optimization: bool = True, specified_block: List[int] = [], is_prob_counts: bool = True, describe: str = '') -> str:
+        """
+        """
+        ...
+
+    @overload
+    def async_real_chip_measure_vec(self, ir: List[str], shot: int = 1000, chip_id: int = 33554432, is_amend: bool = True, is_mapping: bool = True, is_optimization: bool = True, specified_block: List[int] = [], is_prob_counts: bool = True, describe: str = '') -> str:
+        """
+        """
+        ...
+
+    def async_real_chip_qst(self, prog: QProg, shot: int = 1000, chip_id: int = 33554432, is_amend: bool = True, is_mapping: bool = True, is_optimization: bool = True, specified_block: List[int] = [], describe: str = '') -> str:
+        """
+        """
+        ...
+
+    def async_real_chip_qst_density(self, prog: QProg, shot: int = 1000, chip_id: int = 33554432, is_amend: bool = True, is_mapping: bool = True, is_optimization: bool = True, specified_block: List[int] = [], describe: str = '') -> str:
+        """
+        """
+        ...
+
+    def async_real_chip_qst_fidelity(self, prog: QProg, shot: int = 1000, chip_id: int = 33554432, is_amend: bool = True, is_mapping: bool = True, is_optimization: bool = True, specified_block: List[int] = [], describe: str = '') -> str:
+        """
+        """
+        ...
+
+    def build_expectation_task_msg(self, prog: QProg, hamiltonian: str, qubits: List[int] = [], shot: int = 1000, chip_id: int = 33554432, is_amend: bool = True, is_mapping: bool = True, is_optimization: bool = True, specified_block: List[int] = [], task_describe: str = '') -> str:
+        """
+        use C++ to build a expectation task body.
+        """
+        ...
+
     def build_init_msg(self, api_key: str) -> str:
         """
         """
         ...
 
+    def build_qst_task_msg(self, prog: QProg, shot: int = 1000, chip_id: int = 33554432, is_amend: bool = True, is_mapping: bool = True, is_optimization: bool = True, specified_block: List[int] = [], task_describe: str = '') -> str:
+        """
+        use C++ to build ordinary qst task msg body
+        """
+        ...
+
     def build_query_msg(self, task_id: str) -> str:
         """
         """
         ...
 
     def build_task_msg(self, prog: List[QProg], shot: int, chip_id: int, is_amend: bool, is_mapping: bool, is_optimization: bool, specified_block: List[int], task_describe: str) -> str:
         """
+        use c++ to build real chip measure task msg body.
         """
         ...
 
     @overload
     def cAlloc(self) -> ClassicalCondition:
         """
         Allocate a cbit
@@ -4778,35 +4984,90 @@
     @overload
     def cFree_all(self) -> None:
         """
         Free all of cbits
         """
         ...
 
+    def em_compute(self, parameter_json: str) -> List[float]:
+        """
+        """
+        ...
+
     def finalize(self) -> None:
         """
         finalize
         """
         ...
 
+    def get_expectation_result(self, task_id: str) -> list:
+        """
+        """
+        ...
+
+    @overload
+    def get_measure_result(self, task_id: str) -> list:
+        """
+        """
+        ...
+
+    @overload
+    def get_measure_result(self, task_id: str) -> list:
+        """
+        """
+        ...
+
     def get_token(self, rep_json: str) -> ErrorCode:
         """
         """
         ...
 
+    @overload
     def init(self) -> None:
         """
         """
         ...
 
+    @overload
+    def init(self, url: str, log_cout: bool = False, api_key: str = None) -> None:
+        """
+        """
+        ...
+
+    @overload
+    def init(self, url: str, log_cout: bool = False, username: str = None, password: str = None) -> None:
+        """
+        """
+        ...
+
     def init_config(self, url: str, log_cout: bool) -> None:
         """
         """
         ...
 
+    def noise_learning(self, parameter_json: str = True) -> str:
+        """
+        """
+        ...
+
+    def output_version(self) -> str:
+        """
+        """
+        ...
+
+    def pMeasureBinindex(self, prog: QProg, index: str, backendID: int = 33554433) -> float:
+        """
+        """
+        ...
+
+    def pMeasureDecindex(self, prog: QProg, index: str, backendID: int = 33554433) -> float:
+        """
+        """
+        ...
+
     def parse_prob_counts_result(self, result_str: List[str]) -> List[Dict[str,int]]:
         """
         Parse result str to map<string, double>
         Args:
             result_str: Taeget result string
         
         Returns:
@@ -4841,19 +5102,35 @@
             dict: map<string, double>
         Raises:
             none
         
         """
         ...
 
+    def parser_expectation_result(self, json_str: str) -> list:
+        """
+        deprecated, use Python's json lib.
+        """
+        ...
+
     def parser_sync_result(self, json_str: str) -> list:
         """
         """
         ...
 
+    def pmeasure_subset(self, prog: QProg, amplitude: List[str], backendID: int = 33554433) -> Dict[str,complex]:
+        """
+        """
+        ...
+
+    def probRunDict(self, prog: QProg, qubit_vec: List[int], backendID: int = 33554433) -> Dict[str,float]:
+        """
+        """
+        ...
+
     def qAlloc(self) -> Qubit:
         """
         Allocate a qubit
         """
         ...
 
     def qAlloc_many(self, qubit_num: int) -> List[Qubit]:
@@ -4879,14 +5156,143 @@
     @overload
     def qFree_all(self, arg0: QVec) -> None:
         """
         Free all of qubits
         """
         ...
 
+    def query_compile_prog(self, task_id: str, without_compensate: bool = True) -> list:
+        """
+        Query Task compile prog by task_id
+        Args:
+            without_compensate: whether return the prog without angle compensate
+        
+        Returns:
+            bool: whether find compile prog success
+        Raises:
+            none
+        
+        """
+        ...
+
+    @overload
+    def query_task_state(self, task_id: str) -> list:
+        """
+        Query Task State by task_id
+        Args:
+            task_id: Taeget task id, got by async_real_chip_measure
+        
+        Returns:
+            string: task state: 2: Running; 3: Finished; 4: Failed
+            string: task result string
+        Raises:
+            none
+        
+        
+        """
+        ...
+
+    @overload
+    def query_task_state(self, task_id: str, is_save: bool, file_path: str = '') -> list:
+        """
+        """
+        ...
+
+    def query_task_state_vec(self, task_id: str) -> list:
+        """
+        Query Task State by task_id
+        Args:
+            task_id: Taeget task id, got by async_real_chip_measure
+        
+        Returns:
+            string: task state: 2: Running; 3: Finished; 4: Failed
+            array: task result array
+        Raises:
+            none
+        
+        """
+        ...
+
+    def real_chip_expectation(self, prog: QProg, hamiltonian: str, qubits: List[int] = [], shot: int = 1000, chip_id: int = 33554432, is_amend: bool = True, is_mapping: bool = True, is_optimization: bool = True, specified_block: List[int] = [], describe: str = '') -> float:
+        """
+        deprecated, use request instead.
+        """
+        ...
+
+    @overload
+    def real_chip_measure(self, prog: QProg, shot: int = 1000, chip_id: int = 33554432, is_amend: bool = True, is_mapping: bool = True, is_optimization: bool = True, specified_block: List[int] = [], describe: str = '') -> Dict[str,float]:
+        """
+        """
+        ...
+
+    @overload
+    def real_chip_measure(self, ir: str, shot: int = 1000, chip_id: int = 33554432, is_amend: bool = True, is_mapping: bool = True, is_optimization: bool = True, specified_block: List[int] = [], describe: str = '') -> Dict[str,float]:
+        """
+        """
+        ...
+
+    @overload
+    def real_chip_measure(self, prog: List[QProg], shot: int = 1000, chip_id: int = 33554432, is_amend: bool = True, is_mapping: bool = True, is_optimization: bool = True, specified_block: List[int] = [], describe: str = '') -> List[Dict[str,float]]:
+        """
+        """
+        ...
+
+    @overload
+    def real_chip_measure(self, ir: List[str], shot: int = 1000, chip_id: int = 33554432, is_amend: bool = True, is_mapping: bool = True, is_optimization: bool = True, specified_block: List[int] = [], describe: str = '') -> List[Dict[str,float]]:
+        """
+        """
+        ...
+
+    @overload
+    def real_chip_measure(self, prog: List[QProg], config_str: str) -> str:
+        """
+        """
+        ...
+
+    @overload
+    def real_chip_measure_prob_count(self, ir: str, shot: int = 1000, chip_id: int = 33554432, is_mapping: bool = True, is_optimization: bool = True, specified_block: List[int] = [], describe: str = '') -> Dict[str,int]:
+        """
+        """
+        ...
+
+    @overload
+    def real_chip_measure_prob_count(self, prog: QProg, shot: int = 1000, chip_id: int = 33554432, is_mapping: bool = True, is_optimization: bool = True, specified_block: List[int] = [], describe: str = '') -> Dict[str,int]:
+        """
+        """
+        ...
+
+    @overload
+    def real_chip_measure_prob_count(self, ir: List[str], shot: int = 1000, chip_id: int = 33554432, is_mapping: bool = True, is_optimization: bool = True, specified_block: List[int] = [], describe: str = '') -> List[Dict[str,int]]:
+        """
+        """
+        ...
+
+    @overload
+    def real_chip_measure_prob_count(self, prog: List[QProg], shot: int = 1000, chip_id: int = 33554432, is_mapping: bool = True, is_optimization: bool = True, specified_block: List[int] = [], describe: str = '') -> List[Dict[str,int]]:
+        """
+        """
+        ...
+
+    @overload
+    def real_chip_measure_vec(self, prog: List[QProg], shot: int = 1000, chip_id: int = 33554432, is_amend: bool = True, is_mapping: bool = True, is_optimization: bool = True, specified_block: List[int] = [], describe: str = '') -> List[Dict[str,float]]:
+        """
+        """
+        ...
+
+    @overload
+    def real_chip_measure_vec(self, ir: List[str], shot: int = 1000, chip_id: int = 33554432, is_amend: bool = True, is_mapping: bool = True, is_optimization: bool = True, specified_block: List[int] = [], describe: str = '') -> List[Dict[str,float]]:
+        """
+        """
+        ...
+
+    def runWithConfiguration(self, prog: QProg, shots: int = 1000, backend_id: int = 33554433, noise_model: Noise = ...) -> Dict[str,int]:
+        """
+        """
+        ...
+
     def set_config(self, max_qubit: int, max_cbit: int) -> None:
         """
         set QVM max qubit and max cbit
         
         Args:
             max_qubit: quantum machine max qubit num 
             max_cbit: quantum machine max cbit num 
@@ -5628,15 +6034,15 @@
         
         Raises:
             run_fail: An error occurred in allocated qubits of QuantumMachine
         
         """
         ...
 
-    def get_allocate_qubits(self) -> QVec:
+    def get_allocate_qubits(self) -> List[Qubit]:
         """
         Get allocated qubits of QuantumMachine
         
         Args:
             none
         
         Returns:
@@ -11131,14 +11537,72 @@
     
     Returns:
         none
     
     """
     ...
 
+@overload
+def calculate_quantum_volume(noise_qvm: NoiseQVM, qubit_list: List[List[int]], ntrials: int, shots: int = 1000) -> int:
+    """
+    calculate quantum volume
+    
+    Args:
+        noise_qvm: noise quantum machine
+        qubit_list: qubit list 
+        ntrials: ntrials
+        shots: measure shots
+    
+    Returns:
+        result data dict
+    Raises:
+        run_fail: An error occurred in calculate_quantum_volume
+    
+    
+    """
+    ...
+
+@overload
+def calculate_quantum_volume(cloud_qvm, qubit_list: List[List[int]], ntrials: int, shots: int = 1000) -> int:
+    """
+    calculate quantum volume
+    
+    Args:
+        noise_qvm: noise quantum machine
+        qubit_list: qubit list 
+        ntrials: ntrials
+        shots: measure shots
+    
+    Returns:
+        result data dict
+    Raises:
+        run_fail: An error occurred in calculate_quantum_volume
+    
+    
+    """
+    ...
+
+@overload
+def calculate_quantum_volume(config: QCloudTaskConfig, qubit_list: List[List[int]], ntrials: int) -> int:
+    """
+    calculate quantum volume
+    
+    Args:
+        config: QCloudTaskConfig
+        qubit_list: qubit list 
+        ntrials: ntrials
+    
+    Returns:
+        result data dict
+    Raises:
+        run_fail: An error occurred in calculate_quantum_volume
+    
+    """
+    ...
+
 def cast_qprog_qcircuit(qprog: QProg) -> QCircuit:
     """
     Cast QProg to QCircuit
     
     Args:
         qprog: quantum prog 
     
@@ -11809,14 +12273,102 @@
     ...
 
 def dot(arg0: var, arg1: var) -> var:
     """
     """
     ...
 
+@overload
+def double_gate_xeb(config: QCloudTaskConfig, qubit0: int, qubit1: int, clifford_range: List[int], num_circuits: int, gate_type: GateType = GateType.CZ_GATE) -> Dict[int,float]:
+    """
+    double gate xeb
+    
+    Args:
+        qvm: quantum machine
+        qubit0: double qubit 0
+        qubit1: double qubit 1
+        clifford_range: clifford range list
+        num_circuits: the num of circuits
+        interleaved_gates: interleaved gates list
+    
+    Returns:
+        result data dict
+    Raises:
+        run_fail: An error occurred in double_gate_xeb
+    
+    
+    """
+    ...
+
+@overload
+def double_gate_xeb(qvm: QuantumMachine, qubit0: Qubit, qubit1: Qubit, clifford_range: List[int], num_circuits: int, shots: int, chip_id: int = 2, gate_type: GateType = GateType.CZ_GATE) -> Dict[int,float]:
+    """
+    double gate xeb
+    
+    Args:
+        qvm: quantum machine
+        qubit0: double qubit 0
+        qubit1: double qubit 1
+        clifford_range: clifford range list
+        num_circuits: the num of circuits
+        shots: measure shots
+        chip type: RealChipType
+        interleaved_gates: interleaved gates list
+    
+    Returns:
+        result data dict
+    Raises:
+        run_fail: An error occurred in double_gate_xeb
+    
+    """
+    ...
+
+@overload
+def double_qubit_rb(qvm: QuantumMachine, qubit0: Qubit, qubit1: Qubit, clifford_range: List[int], num_circuits: int, shots: int, chip_id: int = 2, interleaved_gates: List[QGate] = []) -> Dict[int,float]:
+    """
+    double qubit rb with WU YUAN chip
+    Args:
+        qvm: quantum machine
+        qubit0: double qubit 0
+        qubit1: double qubit 1
+        clifford_range: clifford range list
+        num_circuits: the num of circuits
+        shots: measure shots
+        chip type: RealChipType
+        interleaved_gates: interleaved gates list
+    
+    Returns:
+        result data dict
+    Raises:
+        run_fail: An error occurred in double_qubit_rb
+    
+    
+    """
+    ...
+
+@overload
+def double_qubit_rb(config: QCloudTaskConfig, qubit0: int, qubit1: int, clifford_range: List[int], num_circuits: int, interleaved_gates: List[QGate] = []) -> Dict[int,float]:
+    """
+    double qubit rb with origin chip
+    Args:
+        config: QCloudTaskConfig
+        qubit0: double qubit 0
+        qubit1: double qubit 1
+        clifford_range: clifford range list
+        num_circuits: the num of circuits
+        interleaved_gates: interleaved gates list
+    
+    Returns:
+        result data dict
+    Raises:
+        run_fail: An error occurred in double_qubit_rb
+    
+    """
+    ...
+
 def draw_qprog_latex(prog: QProg, auto_wrap_len: int = 100, output_file: str = 'QCircuit.tex', with_logo: bool = False, itr_start: NodeIter = NodeIter(), itr_end: NodeIter = NodeIter()) -> str:
     """
     Convert a quantum prog/circuit to latex source code, and save the source code to file in current path with name QCircuit.tex
     Args:
         QProg: quantum prog 
         auto_wrap_len: defaut is 100 
         output_file: result output file name 
@@ -12078,15 +12630,15 @@
         node_iter:  gate node iter in qprog
     
     Returns:
         the front one and back node info of node_iter in qprog
     """
     ...
 
-def get_all_used_qubits(qprog: QProg) -> QVec:
+def get_all_used_qubits(qprog: QProg) -> List[Qubit]:
     """
     Get all the used quantum bits in the input prog
     Args:
         qprog: quantum program
     
     Returns:
         all used qubits
@@ -12143,15 +12695,15 @@
         qubit_num : allocate qubit num
     Raises:
         run_fail: An error occurred in get_allocate_qubit_num
     
     """
     ...
 
-def get_allocate_qubits() -> QVec:
+def get_allocate_qubits() -> List[Qubit]:
     """
     Get allocated qubits of QuantumMachine
     
     Args:
         none
     
     Returns:
@@ -13252,14 +13804,57 @@
     ...
 
 def sin(arg0: var) -> var:
     """
     """
     ...
 
+@overload
+def single_qubit_rb(qvm: QuantumMachine, qubit: Qubit, clifford_range: List[int], num_circuits: int, shots: int, chip_id: int = 2, interleaved_gates: List[QGate] = []) -> Dict[int,float]:
+    """
+    Single qubit rb with WU YUAN chip
+    
+    Args:
+        qvm: quantum machine
+        qubit: single qubit
+        clifford_range: clifford range list
+        num_circuits: the num of circuits
+        shots: measure shots
+        chip type: RealChipType
+        interleaved_gates: interleaved gates list
+    
+    Returns:
+        result data dict
+    Raises:
+        run_fail: An error occurred in single_qubit_rb
+    
+    
+    """
+    ...
+
+@overload
+def single_qubit_rb(config: QCloudTaskConfig, qubit: int, clifford_range: List[int], num_circuits: int, interleaved_gates: List[QGate] = []) -> Dict[int,float]:
+    """
+    Single qubit rb with origin chip
+    
+    Args:
+        config: quantum QCloudTaskConfig
+        qubit: single qubit
+        clifford_range: clifford range list
+        num_circuits: the num of circuits
+        interleaved_gates: interleaved gates list
+    
+    Returns:
+        result data dict
+    Raises:
+        run_fail: An error occurred in single_qubit_rb
+    
+    """
+    ...
+
 def softmax(arg0: var) -> var:
     """
     """
     ...
 
 def split_complex_points(complex_points: List[int], max_connect_degree: int, topo_data: List[List[int]], split_method: ComplexVertexSplitMethod = ComplexVertexSplitMethod.LINEAR) -> List[Tuple[int,List[List[int]]]]:
     """
```

## pyqpanda/OriginService/PilotOSMachine.py

```diff
@@ -44,14 +44,16 @@
         --------
         >>> qm = QPilotOSMachine('Pilot')
 
         """
         self.PilotURL = ''
         self.PilotIp = ''
         self.PilotPort = ''
+        self.APIKey = ''
+        self.LogCout = ''
         return super().__init__(name)
     
     def _build_task_msg(self, prog : List[QProg] = None, shot : int = None, 
                        chip_id : int = None, is_amend : bool = True, is_mapping : bool = True, 
                        is_optimization : bool = True, specified_block : List[int] = [], task_describe : str = '') -> str:
         """Build submit Quantum compute task request json str, however this is a private method.
 
@@ -76,89 +78,81 @@
 
         Returns
         -------
         str
 
         """
         return super().build_task_msg(prog, shot, chip_id, is_amend, is_mapping, is_optimization, specified_block, task_describe)
-    
-    def _real_chip_expectation(self, prog : Union[QProg, str], hamiltonian : str, qubits : List[int] = None,
+
+    def _build_expectation_task_msg(self, prog : Union[QProg, str], hamiltonian : str, qubits : List[int] = None,
                                shot : int = None, chip_id : int = None, is_amend : bool = True, is_mapping : bool = True, 
-                               is_optimization : bool = True, specified_block : List[int] = [], task_describe : str = '') -> float:
-        """Build submit Quantum expectation task request json str, however this is a private method.
+                               is_optimization : bool = True, specified_block : List[int] = [], task_describe : str = '') -> str:
+        """call C++ function to build expectation task message   
 
         Parameters
         ----------
         prog : QProg
             The quantum program you want to compute.
         hamiltonian : 
             Hamiltonian parameters.
         qubits : 
-            measurement qubit 
+            measurement qubit.
         shot : int
             Repeate run quantum program times.
         chip_id : int
             The quantum chip ID .
         is_amend : bool
             Whether amend task result.
         is_mapping : bool
             Whether mapping logical Qubit to Physical Qubit.
         is_optimization : bool
             Whether optimize your quantum program.
         specified_block : List[int]
             Your specifed Qubit block .
         task_describe : str
-            The detailed infomation to describe your quantum program.
+            The detailed infomation to describe your quantum program, such as which kind of algorithm, what can this program compute.
 
         Returns
         -------
-        float
-
+        string
+            if success, return expectation task message.
         """
-        if type(prog) == str:
-            prog = convert_originir_str_to_qprog(prog, self)[0]
-        return super().real_chip_expectation(prog, hamiltonian, qubits, shot, chip_id, is_amend, is_mapping, is_optimization, specified_block, task_describe)
+        return super().build_expectation_task_msg(prog, hamiltonian, qubits, shot, chip_id, is_amend, is_mapping, is_optimization, specified_block, task_describe)
     
-    def _async_real_chip_expectation(self, prog : Union[QProg, str], hamiltonian : str, qubits : List[int] = None,
-                               shot : int = None, chip_id : int = None, is_amend : bool = True, is_mapping : bool = True, 
-                               is_optimization : bool = True, specified_block : List[int] = [], task_describe : str = '') -> str:
-        """Build submit Quantum expectation task request json str, however this is a private method.
+    def _build_qst_task_msg(self, prog : QProg, shot : int = None, chip_id : int = None, is_amend : bool = True, 
+                            is_mapping : bool = True, is_optimization : bool = True, specified_block : List[int] = [], 
+                            task_describe : str = '') -> str:
+        """call C++ function to build qst task message   
 
         Parameters
         ----------
         prog : QProg
             The quantum program you want to compute.
-        hamiltonian : 
-            Hamiltonian parameters.
-        qubits : 
-            measurement qubit 
         shot : int
             Repeate run quantum program times.
         chip_id : int
             The quantum chip ID .
         is_amend : bool
             Whether amend task result.
         is_mapping : bool
             Whether mapping logical Qubit to Physical Qubit.
         is_optimization : bool
             Whether optimize your quantum program.
         specified_block : List[int]
             Your specifed Qubit block .
         task_describe : str
-            The detailed infomation to describe your quantum program.
+            The detailed infomation to describe your quantum program, such as which kind of algorithm, what can this program compute.
 
         Returns
         -------
-        float
-
+        string
+            if success, return qst task message.
         """
-        if type(prog) == str:
-            prog = convert_originir_str_to_qprog(prog, self)[0]
-        return super().async_real_chip_expectation(prog, hamiltonian, qubits, shot, chip_id, is_amend, is_mapping, is_optimization, specified_block, task_describe)
-
+        return super().build_qst_task_msg(prog, shot, chip_id, is_amend, is_mapping, is_optimization, specified_block, task_describe)
+    
     def get_expectation_result(self, task_id : str) -> list:
         """ get expectation task result
 
         Parameters
         ----------
         task_id : str
             expectation task id.
@@ -180,17 +174,47 @@
 
         Returns
         -------
         str
 
         """
         return super().build_query_msg(task_id)
+    
+    def _retry_get_task_result(self, task_id : str, task_resp : list) -> None:
+        """if tcp connection is closed, use http method instead. It's should be a private method, used in _tcp_recv func.
+
+        Parameters
+        ----------
+        task_id : str
+            your task id
+        task_resp : list
+            task result
+        """
+        while True:
+            print("retry get task result...")
+            try :
+                query_result = self.query_task_state(task_id) 
+            except Exception as e : 
+                print(e)
+                continue
+                          
+            if query_result[0] == '3' or query_result[0] == '4' or query_result[0] == '35':
+                # Assemble the return message body
+                task_info_kv = "{{\"taskId\":\"{}\", \"errCode\":{}, \"errInfo\":\"{}\", \"taskResult\":{},\"probCount\":{}}}"          \
+                .format(task_id, query_result[2], query_result[3], json.dumps(query_result[1], indent=None), json.dumps(query_result[4], indent=None))
+                task_resp.append(True)
+                task_resp.append(task_info_kv)
+                break
+            else:
+                print(f"state : {query_result[0]}")
+                time.sleep(1)
+                continue
 
     def _tcp_recv(self, ip : str, port : int, task_id : str) -> list:
-        """Receive message using TCP protocol, however this is a private method.
+        """Receive task result message, if success, use tcp protocol, otherwise retry with http protocol.
 
         Parameters
         ----------
         ip : str
             The PilotOS IP address.
         port : str
             The PilotOS port.
@@ -198,15 +222,22 @@
             The task id of your task.
 
         Returns
         -------
         list
 
         """
-        return super().tcp_recv(ip, port, task_id)
+        task_result = []
+        task_resp = super().tcp_recv(ip, port, task_id)
+        if task_resp[0] : # success, use tcp method
+            task_result = task_resp
+        else : # failed, use http mothod
+            self._retry_get_task_result(task_id, task_result)
+        
+        return task_result 
 
     def _parser_sync_result(self, json_str) -> list:
         """Parse sync compute task result to list, however this is a private method.
 
         Parameters
         ----------
         json_str : str
@@ -214,14 +245,48 @@
 
         Returns
         -------
         list
 
         """
         return super().parser_sync_result(json_str)
+    
+    def _parser_expectation_result(self, json_str) -> float:
+        """Parse expectation result, however this is a private method.
+
+        Parameters
+        ----------
+        json_str : str
+            The json str contains expectation task result.
+
+        Returns
+        -------
+        float
+            if success, return expectation result, else print error info and return none
+        """
+        result_str = json.loads(json_str)
+        if result_str['errCode'] != 0 :
+            print("error, " + result_str['errInfo'])
+            return
+        return float(result_str['taskResult'][0])
+    
+    def get_qst_result(self, task_id: str) -> list:
+        """ get qst task result through task_id
+
+        Parameters
+        ----------
+        task_id : str
+            the task_id you want to query
+
+        Returns
+        -------
+        list
+            The list contains the information of qst task.
+        """
+        return super()._get_qst_result(task_id)
 
     def _send_request(self, str_url : str = None, req : str = None, resp : list = None) -> bool:
         """Send request to PilotOS, however this is a private method.
 
         Parameters
         ----------
         str_url : str
@@ -355,14 +420,16 @@
 
         """
         if url is not None:
             parsed_url = urlparse(url)
             self.PilotURL = url
             self.PilotIp = parsed_url.hostname
             self.PilotPort = parsed_url.port
+            self.APIKey = api_key
+            self.LogCout = log_cout
 
             super().init_config(url,log_cout)
             login_req = super().build_init_msg(api_key)
             login_url = url + '/management/pilotosmachinelogin'
             resp = []
             if self._send_request(login_url, login_req, resp):
                 if super().get_token(resp[0]) == ErrorCode.NO_ERROR_FOUND:
@@ -453,44 +520,31 @@
         """
         proglist = self._get_prog(prog)
         req_str = self._build_task_msg(proglist, shot, chip_id, is_amend, is_mapping, is_optimization, specified_block, describe)
         url = self.PilotURL + '/task/realQuantum/run'
         resp = []
         send_ok = self._send_request(url, req_str, resp)
         if not send_ok:
-            result = ['{"errCode": 3, "errInfo": "Error: Send request failed!"}']
-            print(result[0])
-            return result
+            print('{"errCode": 3, "errInfo": "Error: Send request failed!"}')
+            return
         else:
             parsed_data = json.loads(resp[0])
             if 'taskId' in parsed_data:
                 task_id = parsed_data['taskId']
+                task_resp = self._tcp_recv(self.PilotIp, int(self.PilotPort), task_id)
+                if task_resp[0]:
+                    result = self._parser_sync_result(task_resp[1])
+                else:
+                    print("the task result retrieval failed, please retry later")
+                    return
             else:
                 print('The taskId key is not present in the JSON data.')
-            task_resp = self._tcp_recv(self.PilotIp, int(self.PilotPort), task_id)
-            if task_resp[0]:
-                err_info = json.loads(task_resp[1])
-                result = self._parser_sync_result(task_resp[1])
-                return result[0]
-            else:
-                while True:
-                    query_result = self.query_task_state(self, task_id)               
-                    if query_result[0] == '3':
-                        pass
-                    elif query_result[0] == '4' or query_result[0] == '35':
-                        print(f"state: {query_result[0]}")
-                        print(f"errCode: {query_result[2]}")
-                        print(f"errInfo: {query_result[3]}")
-                        #print(f"Task measure failed Please measure later, errInfo:{query_result[1]}")
-                        break
-                    else:
-                        print(f"state: {query_result[0]}")
-                        time.sleep(1) #2
-                        continue
-                    return task_resp[1]
+                return
+            
+        return result[0]   
 
     def async_real_chip_measure(self, prog : Union[List[str], List[QProg], str, QProg], shot = 1000, chip_id = None, 
                         is_amend = True, is_mapping = True, is_optimization = True, 
                         specified_block = [], describe = '') -> str:
         """Using async way to compute your Quantum Program, then you need to query task result from task_id.
 
         Parameters
@@ -547,19 +601,19 @@
     def real_chip_expectation(self, prog : Union[QProg, str], hamiltonian : str, qubits : List[int] = None,
                                shot : int = None, chip_id : int = None, is_amend : bool = True, is_mapping : bool = True, 
                                is_optimization : bool = True, specified_block : List[int] = [], task_describe : str = '') -> float:
         """submit Quantum expectation task, and get the expectation result.    
 
         Parameters
         ----------
-        prog : QProg
+        prog : Union[QProg, str]
             The quantum program you want to compute.
-        hamiltonian : 
+        hamiltonian : str 
             Hamiltonian parameters.
-        qubits : 
+        qubits : List[int]
             measurement qubit 
         shot : int
             Repeate run quantum program times.
         chip_id : int
             The quantum chip ID .
         is_amend : bool
             Whether amend task result.
@@ -571,32 +625,54 @@
             Your specifed Qubit block .
         task_describe : str
             The detailed infomation to describe your quantum program, such as which kind of algorithm, what can this program compute.
 
         Returns
         -------
         float
-            expectation task result
+            if success, return the expectation task result. Otherwise return empty.
         """
-        return self._real_chip_expectation(prog, hamiltonian, qubits, shot, chip_id, is_amend, is_mapping, is_optimization,
-                                              specified_block, task_describe)
+        if type(prog) == str:
+            prog = convert_originir_str_to_qprog(prog, self)[0]
+        req_str = self._build_expectation_task_msg(prog, hamiltonian, qubits, shot, chip_id, is_amend, is_mapping, is_optimization, specified_block, task_describe)
+        url = self.PilotURL + '/task/realQuantum/run'
+        resp = []
+        send_ok = self._send_request(url, req_str, resp)
+        if not send_ok:
+            print('{"errCode": 3, "errInfo": "Error: Send request failed!"}')
+            return
+        else:
+            parsed_data = json.loads(resp[0])
+            if 'taskId' in parsed_data:
+                task_id = parsed_data['taskId']
+                task_resp = self._tcp_recv(self.PilotIp, int(self.PilotPort), task_id)
+                if task_resp[0]:  # success in acquiring task result
+                    result = self._parser_expectation_result(task_resp[1])
+                else: # failed in acquiring task result
+                    print("The task result retrieval failed, please retry later.")
+                    return
+            else:
+                print('The taskId key is not present in the JSON data.')
+                return
+            
+        return result
         
 
     def async_real_chip_expectation(self, prog : Union[QProg, str], hamiltonian : str, qubits : List[int] = None,
                                     shot : int = None, chip_id : int = None, is_amend : bool = True, is_mapping : bool = True, 
                                     is_optimization : bool = True, specified_block : List[int] = [], task_describe : str = '') -> str:
         """async submit Quantum expectation task, and return the task id.    
 
         Parameters
         ----------
-        prog : QProg
+        prog : Union[QProg, str]
             The quantum program you want to compute.
-        hamiltonian : 
+        hamiltonian : str 
             Hamiltonian parameters.
-        qubits : 
+        qubits : List[int] 
             measurement qubit 
         shot : int
             Repeate run quantum program times.
         chip_id : int
             The quantum chip ID .
         is_amend : bool
             Whether amend task result.
@@ -610,17 +686,84 @@
             The detailed infomation to describe your quantum program, such as which kind of algorithm, what can this program compute.
 
         Returns
         -------
         str
             return expectation task id, you need query task result by using task id.
         """
+        if type(prog) == str:
+            prog = convert_originir_str_to_qprog(prog, self)[0]
+        proglist = self._get_prog(prog)
+        req_str = self._build_expectation_task_msg(prog, hamiltonian, qubits, shot, chip_id, is_amend, is_mapping, is_optimization, specified_block, task_describe)
+        url = self.PilotURL + '/task/realQuantum/run'
+        resp = []
+        send_ok = self._send_request(url, req_str, resp)
+        if not send_ok:
+            print('Error: Send request failed!')
+            return
+        else:
+            print(f"Receive: {resp[0]}")
+            parsed_data = json.loads(resp[0])
+            if 'taskId' in parsed_data:
+                task_id = parsed_data['taskId']
+            else:
+                print(f'The taskId key is not present in the JSON data. reply: {parsed_data}')
+                return
+
+        return task_id
         
-        return self._async_real_chip_expectation(prog, hamiltonian, qubits, shot, chip_id, is_amend, is_mapping, is_optimization,
-                                              specified_block, task_describe)
+    def async_real_chip_qst(self, prog : Union[str, QProg], shot = 1000, chip_id = None, 
+                        is_amend = True, is_mapping = True, is_optimization = True, 
+                        specified_block = [], describe = '') -> list:
+        """Using async way to compute QST task, then you need to query task result from task_id.
+
+        Parameters
+        ----------
+        prog : Union[str, QProg]
+            The quantum program you want to compute.
+        shot : int
+            Repeate run quantum program times.
+        chip_id : int
+            The quantum chip ID .
+        is_amend : bool
+            Whether amend task result.
+        is_mapping : bool
+            Whether mapping logical Qubit to Physical Qubit.
+        is_optimization : bool
+            Whether optimize your quantum program.
+        specified_block : List[int]
+            Your specifed Qubit block .
+        describe : str
+            The detailed infomation to describe your quantum program, such as which kind of algorithm, what can this program compute.
+
+        Returns
+        -------
+        str
+            your task id which can query task result
+        """
+        
+        if type(prog) == str:
+            prog = convert_originir_str_to_qprog(prog, self)[0]
+        req_str = self._build_qst_task_msg(prog, shot, chip_id, is_amend, is_mapping, is_optimization, specified_block, describe)
+        url = self.PilotURL + '/task/realQuantum/run'
+        resp = []
+        send_ok = self._send_request(url, req_str, resp)
+        if not send_ok:
+            print('Error: Send request failed!')
+            return
+        else:
+            print(f"Receive: {resp[0]}")
+            parsed_data = json.loads(resp[0])
+            if 'taskId' in parsed_data:
+                task_id = parsed_data['taskId']
+            else:
+                print(f'The taskId key is not present in the JSON data. reply: {parsed_data}')
+                return
+        
+        return task_id
         
     def query_task_state(self, task_id : str, file_path : str = None) -> list:
         """Query task result from task_id.
 
         Parameters
         ----------
         task_id : str
@@ -697,15 +840,15 @@
         """
         req_str = self._build_query_msg(task_id)
         req_url = self.PilotURL + '/task/realQuantum/query'
         resp =[]
         send_ok = self._send_request(req_url, req_str, resp)
         if not send_ok:
             print('Error: Send request failed!')
-            return 'Error: Send request failed"}'
+            return ["connect failed"]
         else:
             parsed_data = json.loads(resp[0])
             if 'taskState' in parsed_data and 'taskResult' in parsed_data and 'errCode' in parsed_data and 'errInfo' in parsed_data:    
                 task_state = parsed_data['taskState']
                 if task_state == '3':
                     if file_path is not None:
                         if len(file_path) > 0 and file_path[-1] != "/":
@@ -721,18 +864,22 @@
                             os.makedirs(os.path.dirname(file_path), exist_ok=True)
                         with open(file_path, 'w') as file:
                             file.write(resp[0])
 
                 task_result = parsed_data['taskResult']
                 err_code = parsed_data['errCode']
                 err_info = parsed_data['errInfo']
-                res = [task_state, task_result, err_code, err_info]
-                return res
+                if "probCount" in parsed_data : 
+                    prob_count = '[' + parsed_data["probCount"][0] + ']'
+                else : 
+                    prob_count = "[]"
+                res = [task_state, task_result, err_code, err_info, prob_count]
             else:
                 print(f'Query task info error! reply str: {resp[0]}')
+        return res 
 
     def get_task_list_result(self, task_id : list, file_path : str = None) -> list:
         """Get task result through task id list.
 
         Parameters
         ----------
         task_id : list
@@ -761,17 +908,15 @@
         """
         return_list = []
         for item in task_id:
             single_result = self.query_task_state(item, file_path)
             if single_result[0] == '3':
                 return_list.append({'task_id' : item, 'task_result' : single_result[1]})
 
-        return return_list    
-
-
+        return return_list     
 
     def parse_probability_result(self, result_str : list) -> list:
         """Parse async task probability result to a list contains dict.
 
         Parameters
         ----------
         result_str : str
```

### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

## pyqpanda/Visualization/__init__.py

```diff
@@ -2,15 +2,15 @@
 QPanda Python\n
 Copyright (C) Origin Quantum 2017-2020\n
 Licensed Under Apache Licence 2.0
 '''
 
 from .circuit_draw import draw_qprog
 from .circuit_draw import show_prog_info_count
-from .draw_probability_map import draw_probaility
+from .draw_probability_map import draw_probability
 from .draw_probability_map import draw_probability_dict
 from .quantum_state_plot import plot_state_city
 from .quantum_state_plot import plot_density_matrix
 from .quantum_state_plot import state_to_density_matrix
 from .bloch_plot import plot_bloch_circuit
 from .bloch_plot import plot_bloch_vector
 from .bloch_plot import plot_bloch_multivector
```

## pyqpanda/Visualization/draw_probability_map.py

```diff
@@ -1,14 +1,14 @@
 import matplotlib.pyplot as plt
 import matplotlib as mpl
 
 plt.switch_backend('agg')
 
 
-def draw_probaility(list):
+def draw_probability(list):
     """Draw a quantum state probaility dict
 
     Args:
         list : the quantum state probaility dict
 
     Returns: 
         no return
```

## Comparing `pyqpanda-3.8.3.2.dist-info/LICENSE` & `pyqpanda-3.8.3.3.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `pyqpanda-3.8.3.2.dist-info/METADATA` & `pyqpanda-3.8.3.3.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: pyqpanda
-Version: 3.8.3.2
+Version: 3.8.3.3
 Summary: pyQPanda is Python wrapper of QPanda.
 Author: OriginQ
 License: Apache Licence
 Platform: UNKNOWN
 Classifier: Development Status :: 4 - Beta
 Classifier: Operating System :: MacOS :: MacOS X
 Classifier: Operating System :: Microsoft :: Windows :: Windows 10
```

## Comparing `pyqpanda-3.8.3.2.dist-info/RECORD` & `pyqpanda-3.8.3.3.dist-info/RECORD`

 * *Files 4% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 pyqpanda/__init__.py,sha256=fmkOe5eyJjC9-jHrDeZQBuxr7-Mh-qr9eMuqal6tTaQ,863
+pyqpanda/libcurl.dll,sha256=l29tkvswJMMKHLGeSJX3CW5xtu99zQQv2QL51BfNOLE,364032
 pyqpanda/msvcr120.dll,sha256=lGHy5K3VxlAQKs3gxiN3_4bZsZ_CDQAD8ybM1HTot7k,963240
 pyqpanda/optimizerTest.py,sha256=ed-SwkgBJZXqQ5opSJ_REC11jldSdFkV5DvHSpzvuxY,1339
-pyqpanda/pyQPanda.pyd,sha256=pUuRAwoMJguH3gS1y6PGilPZDiENh2UrObl1HrTBamw,10516480
-pyqpanda/pyQPanda.pyi,sha256=fRuwJ7Mc30WUXhrIETr5lrEFMW_onaeyzbw1LYEftfc,302603
+pyqpanda/pyQPanda.pyd,sha256=mxJFo0-kGW-Rq9eBcdn4GFt2r7W5Z8B7-GMVBsE91VY,11475456
+pyqpanda/pyQPanda.pyi,sha256=EhqLOp1LdNWwI1DYrgeUW4UTGxtQO7nL-SzgCDa9o78,322948
 pyqpanda/utils.py,sha256=GU1EQtsCEMARcPxXxr2cGCopRCsh5ahhUIOnd7MJBVc,2865
 pyqpanda/Algorithm/__init__.py,sha256=eZuQqnhDQGg9Ur251VxRn-oCpVKpD3e3Si7U5-LICmI,109
 pyqpanda/Algorithm/fragments.py,sha256=toKkpkYjWKIAkuNZKnGJNK95Lbo9yLt8bRMtxCBG88k,2570
 pyqpanda/Algorithm/hamiltonian_simulation.py,sha256=Z7OnIVdL6DZHQRSD0oKyzqjpgqqfKmmac8yai6X58eE,8587
 pyqpanda/Algorithm/QuantumCircuitLearning/__init__.py,sha256=eZuQqnhDQGg9Ur251VxRn-oCpVKpD3e3Si7U5-LICmI,109
 pyqpanda/Algorithm/QuantumCircuitLearning/quantum_circuit_learning.py,sha256=borkJdB2PwVSxD4N-w3Go7fmOj5Z6dXh_jr91C8C5eg,7045
 pyqpanda/Algorithm/QuantumGradient/__init__.py,sha256=-0UFToKfAhFraO1UJlDk06vn3cGPQ06xDLIKWK6nbj0,100
@@ -28,44 +29,44 @@
 pyqpanda/Algorithm/test/test_utils.py,sha256=DmWiCMWLrJDqgWwosHjwNGVD9gGKBC9L7XvUNEEw7A8,1045
 pyqpanda/Algorithm/test/vqe_test.py,sha256=jxcP6mAQvvOJCLYbJ3h_IoMkG2lXv-WGxHhpczsSpsU,1692
 pyqpanda/Hamiltonian/__init__.py,sha256=0xz1GbGuZ4NDV-FwaOCcCeQ1UBJt8GXfWCLTz4Fh0dg,154
 pyqpanda/Hamiltonian/chemistry_client.py,sha256=HOpes4Xhv8P-U_s84JdFJG3edxEuqfq2tTIStUf6Ivc,1250
 pyqpanda/Hamiltonian/PauliOperator/__init__.py,sha256=NKE3vRAIef7_xlfkcB9v9p1zYYD5sqMu8HIDKLuqDzw,178
 pyqpanda/Hamiltonian/test/__init__.py,sha256=fnvTiGwOMBp_-SWQOijQ2QUpYB8zsI9lCP_l9WeoMg4,30
 pyqpanda/Hamiltonian/test/hamiltonian_test.py,sha256=gAKjDK5zroKhCGgP4WfxU8btA4wJvqs52tgomm_uV0g,315
-pyqpanda/Kyber/Kyber.pyd,sha256=dlvtmGB4C7aIv87FfVhsWMWXh8okLsSSYdf8dczWWKw,283136
-pyqpanda/Kyber/Kyber_SM2.pyd,sha256=AxXfjFmvpSqOzJD8yy71JGjaHoiFGBS9brxj8Gwx4cQ,110592
+pyqpanda/Kyber/Kyber.pyd,sha256=ZooF8AVo8LNAZy8JHBPeqLTuqZtbpMTCdMcWYHC6Ua8,283136
+pyqpanda/Kyber/Kyber_SM2.pyd,sha256=Li5z0m77VxSzGh2aAF2s7gjB9NLKQIwyesBXLjTtMtE,111104
 pyqpanda/Kyber/__init__.py,sha256=sMdF7fTClM__bgYlehU86mnHCTi2IqrvIDbUfLFqLkQ,130
 pyqpanda/Kyber/setup-cpython.py,sha256=JtaD8PdY2QyXDhs_UtwK_FuG1oM-AMHVeFFb4h4cDV8,4064
 pyqpanda/Operator/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-pyqpanda/Operator/pyQPandaOperator.pyd,sha256=-bJT515qY5AeQIo-wf_h8RJogORUCxnF-ZjBP5FZlj4,3317760
+pyqpanda/Operator/pyQPandaOperator.pyd,sha256=UGWpF-aNnTa8q1Jn3u9peyCrVVsgV0c70juayjPqnXU,3338752
 pyqpanda/Operator/pyQPandaOperator.pyi,sha256=WJm-M7IHbEUgDPnajXOfqJn4kRiKo3ECdPYnc2d-3OI,15567
-pyqpanda/OriginService/PilotOSMachine.py,sha256=UhdFS8y-FmfsZeZ0vYQMt2tV4I733DBCnCNrnQBZ2ls,32040
+pyqpanda/OriginService/PilotOSMachine.py,sha256=L7gZUaozHyvJeDeMVzYiD_g_8UxcX1Ww-7bhAjvnEqI,37802
 pyqpanda/OriginService/QCloudMachine.py,sha256=j-M7oHqtP6lK9Riv_KN-CrQHPf44uMXasZXAP5T9IEM,67443
 pyqpanda/OriginService/__init__.py,sha256=P77uotjTzUj-jasxm_R-4rfR1sBaJo86tzBwqkQfLlc,165
 pyqpanda/TorchLayer/Torch_.py,sha256=lgWsrS722a6ZyZ2EUbSNqP5W_-yU2-EiP5lGp3rV-rM,709
 pyqpanda/TorchLayer/__init__.py,sha256=X6k9Zk3N6iNW02bZburUm4E1WpysXThlbJisDXBx8iI,163
 pyqpanda/TorchLayer/basic_eng.py,sha256=qdj8OT_qFgLsyr8XRqkLFaxKMc31R7wkZWarJ44teSo,895
 pyqpanda/TorchLayer/cir_angle.py,sha256=ZBY3pzyWFgwjALW-cDwfmjJnqHRkwbUA_NaTtxDFWM4,848
 pyqpanda/TorchLayer/torchlayer.py,sha256=o5A56kjr0TyS14kCGLQCNjtmQTjWlANkrGZvMdTVak8,3709
 pyqpanda/Variational/VariationalCircuit.py,sha256=wFqQRvB1CqFpY77PFJdl1B7sWJf8JVBcoR1Unw21ldc,265
 pyqpanda/Variational/__init__.py,sha256=_jXlVgzW8aN8DXTAZWq5QKVB4PN-XkPSc682hWs3n9s,366
 pyqpanda/Variational/variational_qaoa_citcuit.py,sha256=vq_fcKLV873B6vTbncF_-YiItCY2chcXId-AMckH2Aw,2487
-pyqpanda/Visualization/__init__.py,sha256=mBNoyoWcEubUuuBQNHQCacG9jXXNhSvfOrtlFrMbMRU,598
+pyqpanda/Visualization/__init__.py,sha256=80wXyUpcpsLr6zhJJgbH6taLeEhn6oo52mE-Bgzz-oQ,599
 pyqpanda/Visualization/bloch.py,sha256=neff1YgKKBP1-u1zVxoHNA28WSRA_J74EztPFo6_UWw,29805
 pyqpanda/Visualization/bloch_plot.py,sha256=Z4SyCVND7NdtbR6hVtDcSFitKrMmKGXhc4gGHU8eJNc,15445
 pyqpanda/Visualization/circuit_composer.py,sha256=aVLfBu8Ih_0jHg9CE1BbW0pR3sRCX98Y2iC9U2M2Ubs,19822
 pyqpanda/Visualization/circuit_draw.py,sha256=eoWKGmQjJzgpyJ6V6a24de6tFrKDC87ls-1MySYWScA,5151
 pyqpanda/Visualization/circuit_info.py,sha256=ueUsUAYPHgVr3GnTQRAakJ2-1GNynFOCpP8wPyJd7ns,7514
 pyqpanda/Visualization/circuit_style.py,sha256=qTsp31mvAs190507oknNczQjBSQaxQ4XC8QWxVjMDMM,5385
-pyqpanda/Visualization/draw_probability_map.py,sha256=zMmQvHs6StQWEqw0YMJC-A2QjfSf_KvRvzAa6M-H4L0,1362
+pyqpanda/Visualization/draw_probability_map.py,sha256=jRZctrlDLvXItY_eVNkZVczxMuIVE-I3cmjiCCeYBEY,1363
 pyqpanda/Visualization/exceptions.py,sha256=nKmgWkjbJCdzr-EttmSlU--rS1DPgLqD4kDdq5b1YNs,1299
 pyqpanda/Visualization/matplotlib_draw.py,sha256=1cNw6yuYv4OWOF4_pP2xsdktM0VUW3y6b1quUw5x0mw,67480
 pyqpanda/Visualization/parameterexpression.py,sha256=kqXeap_sY1EBfKIKq_enPxvLMuzN9ONu2RpsczP6qmc,10396
 pyqpanda/Visualization/pi_check.py,sha256=0pDKv-WHFeCY8HHOU52Xnz6jWg1y1u04uF8rI1vkPyI,4875
 pyqpanda/Visualization/quantum_state_plot.py,sha256=K46nJrv-NA_-o6862d4-hoti4aG4vTOYobg1-6kSW9Q,14211
 pyqpanda/Visualization/utils.py,sha256=Dm5wWvRNRmjZjG2rImmDnxj5m00dJAdwM3EBe86ZsHI,831
-pyqpanda-3.8.3.2.dist-info/LICENSE,sha256=HrhfyXIkWY2tGFK11kg7vPCqhgh5DcxleloqdhrpyMY,11558
-pyqpanda-3.8.3.2.dist-info/METADATA,sha256=tr0aCBbyKL-jozLT1nB7iwvNbvK9FDAmuldeK-4StjA,946
-pyqpanda-3.8.3.2.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
-pyqpanda-3.8.3.2.dist-info/top_level.txt,sha256=roDWq_FlskoKuRjqzBCuctLnWUHQFHGtE9mHrgC9vKA,22
-pyqpanda-3.8.3.2.dist-info/RECORD,,
+pyqpanda-3.8.3.3.dist-info/LICENSE,sha256=HrhfyXIkWY2tGFK11kg7vPCqhgh5DcxleloqdhrpyMY,11558
+pyqpanda-3.8.3.3.dist-info/METADATA,sha256=xaMCwWDJ_AQ8gpOOZ1Mdly6QY49pjIpB2xfLrHaLhKw,946
+pyqpanda-3.8.3.3.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
+pyqpanda-3.8.3.3.dist-info/top_level.txt,sha256=roDWq_FlskoKuRjqzBCuctLnWUHQFHGtE9mHrgC9vKA,22
+pyqpanda-3.8.3.3.dist-info/RECORD,,
```

